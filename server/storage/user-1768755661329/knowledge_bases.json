[
  {
    "id": "1768757382195",
    "title": "react",
    "description": "新的空白知识库，等待您导入内容。",
    "tag": "General",
    "progress": 0,
    "status": "未开始",
    "lastUpdated": "2026/1/19",
    "files": [
      {
        "id": "17687574930800.6607225731553065",
        "name": "vuejs.md",
        "type": "md",
        "size": "1025.1 KB",
        "date": "2026/1/19",
        "content": "Directory structure:\n└── vuejs-translations-docs-zh-cn/\n    ├── README.md\n    ├── env.d.ts\n    ├── LICENSE\n    ├── netlify.toml\n    ├── package.json\n    ├── tsconfig.json\n    ├── vercel.json\n    ├── .editorconfig\n    ├── .npmrc\n    ├── .prettierignore\n    ├── .prettierrc\n    ├── .zhlintcaseignore\n    ├── .zhlintrc\n    ├── assets/\n    │   └── FileExplorer.vue\n    ├── scripts/\n    │   └── sync.js\n    ├── src/\n    │   ├── index.md\n    │   ├── about/\n    │   │   ├── coc.md\n    │   │   ├── community-guide.md\n    │   │   ├── faq.md\n    │   │   ├── privacy.md\n    │   │   ├── releases.md\n    │   │   ├── team.md\n    │   │   ├── translation.md\n    │   │   └── team/\n    │   │       ├── Member.ts\n    │   │       ├── members-core.json\n    │   │       ├── members-emeriti.json\n    │   │       ├── members-partner.json\n    │   │       ├── TeamHero.vue\n    │   │       ├── TeamList.vue\n    │   │       ├── TeamMember.vue\n    │   │       └── TeamPage.vue\n    │   ├── api/\n    │   │   ├── api.data.ts\n    │   │   ├── ApiIndex.vue\n    │   │   ├── application.md\n    │   │   ├── built-in-components.md\n    │   │   ├── built-in-directives.md\n    │   │   ├── built-in-special-attributes.md\n    │   │   ├── built-in-special-elements.md\n    │   │   ├── compile-time-flags.md\n    │   │   ├── component-instance.md\n    │   │   ├── composition-api-dependency-injection.md\n    │   │   ├── composition-api-helpers.md\n    │   │   ├── composition-api-lifecycle.md\n    │   │   ├── composition-api-setup.md\n    │   │   ├── custom-elements.md\n    │   │   ├── custom-renderer.md\n    │   │   ├── general.md\n    │   │   ├── index.md\n    │   │   ├── options-composition.md\n    │   │   ├── options-lifecycle.md\n    │   │   ├── options-misc.md\n    │   │   ├── options-rendering.md\n    │   │   ├── options-state.md\n    │   │   ├── reactivity-advanced.md\n    │   │   ├── reactivity-core.md\n    │   │   ├── reactivity-utilities.md\n    │   │   ├── render-function.md\n    │   │   ├── sfc-css-features.md\n    │   │   ├── sfc-script-setup.md\n    │   │   ├── sfc-spec.md\n    │   │   ├── ssr.md\n    │   │   └── utility-types.md\n    │   ├── ecosystem/\n    │   │   ├── newsletters.md\n    │   │   ├── themes.md\n    │   │   └── themes/\n    │   │       ├── ThemeContact.vue\n    │   │       ├── ThemeHero.vue\n    │   │       ├── ThemeList.vue\n    │   │       ├── ThemeListItem.vue\n    │   │       ├── ThemePage.vue\n    │   │       ├── ThemeProduct.vue\n    │   │       └── themes.json\n    │   ├── error-reference/\n    │   │   ├── errors.data.ts\n    │   │   ├── ErrorsTable.vue\n    │   │   └── index.md\n    │   ├── examples/\n    │   │   ├── ExampleRepl.vue\n    │   │   ├── examples.data.ts\n    │   │   ├── index.md\n    │   │   ├── utils.ts\n    │   │   └── src/\n    │   │       ├── attribute-bindings/\n    │   │       │   ├── description.txt\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       ├── style.css\n    │   │       │       └── template.html\n    │   │       ├── cells/\n    │   │       │   ├── description.txt\n    │   │       │   ├── store.js\n    │   │       │   ├── App/\n    │   │       │   │   ├── composition.js\n    │   │       │   │   ├── options.js\n    │   │       │   │   ├── style.css\n    │   │       │   │   └── template.html\n    │   │       │   └── Cell/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       ├── style.css\n    │   │       │       └── template.html\n    │   │       ├── circle-drawer/\n    │   │       │   ├── description.txt\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       ├── style.css\n    │   │       │       └── template.html\n    │   │       ├── conditionals-and-loops/\n    │   │       │   ├── description.txt\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       └── template.html\n    │   │       ├── counter/\n    │   │       │   ├── description.txt\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       └── template.html\n    │   │       ├── crud/\n    │   │       │   ├── description.txt\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       ├── style.css\n    │   │       │       └── template.html\n    │   │       ├── fetching-data/\n    │   │       │   ├── description.txt\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       ├── style.css\n    │   │       │       └── template.html\n    │   │       ├── flight-booker/\n    │   │       │   ├── description.txt\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       ├── style.css\n    │   │       │       └── template.html\n    │   │       ├── form-bindings/\n    │   │       │   ├── description.txt\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       └── template.html\n    │   │       ├── grid/\n    │   │       │   ├── description.txt\n    │   │       │   ├── App/\n    │   │       │   │   ├── composition.js\n    │   │       │   │   ├── options.js\n    │   │       │   │   └── template.html\n    │   │       │   └── Grid/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       ├── style.css\n    │   │       │       └── template.html\n    │   │       ├── handling-input/\n    │   │       │   ├── description.txt\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       ├── style.css\n    │   │       │       └── template.html\n    │   │       ├── hello-world/\n    │   │       │   ├── description.txt\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       └── template.html\n    │   │       ├── list-transition/\n    │   │       │   ├── description.txt\n    │   │       │   ├── import-map.json\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       ├── style.css\n    │   │       │       └── template.html\n    │   │       ├── markdown/\n    │   │       │   ├── description.txt\n    │   │       │   ├── import-map.json\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       ├── style.css\n    │   │       │       └── template.html\n    │   │       ├── modal/\n    │   │       │   ├── description.txt\n    │   │       │   ├── App/\n    │   │       │   │   ├── composition.js\n    │   │       │   │   ├── options.js\n    │   │       │   │   └── template.html\n    │   │       │   └── Modal/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       ├── style.css\n    │   │       │       └── template.html\n    │   │       ├── simple-component/\n    │   │       │   ├── description.txt\n    │   │       │   ├── App/\n    │   │       │   │   ├── composition.js\n    │   │       │   │   ├── options.js\n    │   │       │   │   └── template.html\n    │   │       │   └── TodoItem/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       └── template.html\n    │   │       ├── svg/\n    │   │       │   ├── description.txt\n    │   │       │   ├── util.js\n    │   │       │   ├── App/\n    │   │       │   │   ├── composition.js\n    │   │       │   │   ├── options.js\n    │   │       │   │   ├── style.css\n    │   │       │   │   └── template.html\n    │   │       │   ├── AxisLabel/\n    │   │       │   │   ├── composition.js\n    │   │       │   │   ├── options.js\n    │   │       │   │   └── template.html\n    │   │       │   └── PolyGraph/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       └── template.html\n    │   │       ├── temperature-converter/\n    │   │       │   ├── description.txt\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       └── template.html\n    │   │       ├── timer/\n    │   │       │   ├── description.txt\n    │   │       │   └── App/\n    │   │       │       ├── composition.js\n    │   │       │       ├── options.js\n    │   │       │       ├── style.css\n    │   │       │       └── template.html\n    │   │       └── tree/\n    │   │           ├── description.txt\n    │   │           ├── App/\n    │   │           │   ├── composition.js\n    │   │           │   ├── options.js\n    │   │           │   ├── style.css\n    │   │           │   └── template.html\n    │   │           └── TreeItem/\n    │   │               ├── composition.js\n    │   │               ├── options.js\n    │   │               └── template.html\n    │   ├── glossary/\n    │   │   └── index.md\n    │   ├── guide/\n    │   │   ├── introduction.md\n    │   │   ├── quick-start.md\n    │   │   ├── best-practices/\n    │   │   │   ├── accessibility.md\n    │   │   │   ├── performance.md\n    │   │   │   ├── production-deployment.md\n    │   │   │   └── security.md\n    │   │   ├── built-ins/\n    │   │   │   ├── keep-alive.md\n    │   │   │   ├── suspense.md\n    │   │   │   ├── teleport.md\n    │   │   │   ├── transition-group.md\n    │   │   │   ├── transition.md\n    │   │   │   ├── keep-alive-demos/\n    │   │   │   │   ├── CompA.vue\n    │   │   │   │   ├── CompB.vue\n    │   │   │   │   └── SwitchComponent.vue\n    │   │   │   └── transition-demos/\n    │   │   │       ├── Basic.vue\n    │   │   │       ├── BetweenComponents.vue\n    │   │   │       ├── BetweenElements.vue\n    │   │   │       ├── CssAnimation.vue\n    │   │   │       ├── JsHooks.vue\n    │   │   │       ├── ListBasic.vue\n    │   │   │       ├── ListMove.vue\n    │   │   │       ├── ListStagger.vue\n    │   │   │       ├── NestedTransitions.vue\n    │   │   │       └── SlideFade.vue\n    │   │   ├── components/\n    │   │   │   ├── async.md\n    │   │   │   ├── attrs.md\n    │   │   │   ├── events.md\n    │   │   │   ├── props.md\n    │   │   │   ├── provide-inject.md\n    │   │   │   ├── registration.md\n    │   │   │   ├── slots.md\n    │   │   │   └── v-model.md\n    │   │   ├── essentials/\n    │   │   │   ├── application.md\n    │   │   │   ├── class-and-style.md\n    │   │   │   ├── component-basics.md\n    │   │   │   ├── computed.md\n    │   │   │   ├── conditional.md\n    │   │   │   ├── event-handling.md\n    │   │   │   ├── forms.md\n    │   │   │   ├── lifecycle.md\n    │   │   │   ├── list.md\n    │   │   │   ├── reactivity-fundamentals.md\n    │   │   │   ├── template-refs.md\n    │   │   │   ├── template-syntax.md\n    │   │   │   └── watchers.md\n    │   │   ├── extras/\n    │   │   │   ├── animation.md\n    │   │   │   ├── composition-api-faq.md\n    │   │   │   ├── reactivity-in-depth.md\n    │   │   │   ├── reactivity-transform.md\n    │   │   │   ├── render-function.md\n    │   │   │   ├── rendering-mechanism.md\n    │   │   │   ├── ways-of-using-vue.md\n    │   │   │   ├── web-components.md\n    │   │   │   └── demos/\n    │   │   │       ├── AnimateWatcher.vue\n    │   │   │       ├── Colors.vue\n    │   │   │       ├── DisabledButton.vue\n    │   │   │       ├── ElasticHeader.vue\n    │   │   │       ├── SpreadSheet.vue\n    │   │   │       ├── SpreadSheetCell.vue\n    │   │   │       └── spreadSheetStore.js\n    │   │   ├── reusability/\n    │   │   │   ├── composables.md\n    │   │   │   ├── custom-directives.md\n    │   │   │   ├── mouse.js\n    │   │   │   └── plugins.md\n    │   │   ├── scaling-up/\n    │   │   │   ├── routing.md\n    │   │   │   ├── sfc.md\n    │   │   │   ├── ssr.md\n    │   │   │   ├── state-management.md\n    │   │   │   ├── testing.md\n    │   │   │   └── tooling.md\n    │   │   └── typescript/\n    │   │       ├── composition-api.md\n    │   │       ├── options-api.md\n    │   │       └── overview.md\n    │   ├── partners/\n    │   │   ├── [partnerId].md\n    │   │   ├── [partnerId].paths.ts\n    │   │   ├── all.md\n    │   │   ├── index.md\n    │   │   ├── partners.json\n    │   │   └── components/\n    │   │       ├── PartnerAll.vue\n    │   │       ├── PartnerCard.vue\n    │   │       ├── PartnerHero.vue\n    │   │       ├── PartnerJoin.vue\n    │   │       ├── PartnerLanding.vue\n    │   │       ├── PartnerList.vue\n    │   │       ├── PartnerLocation.vue\n    │   │       ├── PartnerPage.vue\n    │   │       ├── type.ts\n    │   │       └── utils.ts\n    │   ├── public/\n    │   │   ├── 404.html\n    │   │   ├── _headers\n    │   │   ├── _redirects\n    │   │   ├── CNAME\n    │   │   ├── funding.json\n    │   │   └── service-worker.js\n    │   ├── sponsor/\n    │   │   └── index.md\n    │   ├── style-guide/\n    │   │   └── PLEADE_DO_NOT_TRANSLATE.md\n    │   ├── translations/\n    │   │   └── index.md\n    │   └── tutorial/\n    │       ├── index.md\n    │       ├── tutorial.data.ts\n    │       ├── TutorialRepl.vue\n    │       └── src/\n    │           ├── step-1/\n    │           │   ├── description.md\n    │           │   └── App/\n    │           │       └── template.html\n    │           ├── step-10/\n    │           │   ├── description.md\n    │           │   ├── _hint/\n    │           │   │   └── App/\n    │           │   │       ├── composition.js\n    │           │   │       └── options.js\n    │           │   └── App/\n    │           │       ├── composition.js\n    │           │       ├── options.js\n    │           │       └── template.html\n    │           ├── step-11/\n    │           │   ├── description.md\n    │           │   ├── _hint/\n    │           │   │   └── App/\n    │           │   │       ├── composition.js\n    │           │   │       ├── options.js\n    │           │   │       └── template.html\n    │           │   ├── App/\n    │           │   │   ├── composition.js\n    │           │   │   ├── options.js\n    │           │   │   └── template.html\n    │           │   └── ChildComp/\n    │           │       └── template.html\n    │           ├── step-12/\n    │           │   ├── description.md\n    │           │   ├── _hint/\n    │           │   │   └── App/\n    │           │   │       └── template.html\n    │           │   ├── App/\n    │           │   │   ├── composition.js\n    │           │   │   ├── options.js\n    │           │   │   └── template.html\n    │           │   └── ChildComp/\n    │           │       ├── composition.js\n    │           │       ├── options.js\n    │           │       └── template.html\n    │           ├── step-13/\n    │           │   ├── description.md\n    │           │   ├── _hint/\n    │           │   │   └── App/\n    │           │   │       └── template.html\n    │           │   ├── App/\n    │           │   │   ├── composition.js\n    │           │   │   ├── options.js\n    │           │   │   └── template.html\n    │           │   └── ChildComp/\n    │           │       ├── composition.js\n    │           │       ├── options.js\n    │           │       └── template.html\n    │           ├── step-14/\n    │           │   ├── description.md\n    │           │   ├── _hint/\n    │           │   │   └── App/\n    │           │   │       └── template.html\n    │           │   ├── App/\n    │           │   │   ├── composition.js\n    │           │   │   ├── options.js\n    │           │   │   └── template.html\n    │           │   └── ChildComp/\n    │           │       └── template.html\n    │           ├── step-15/\n    │           │   ├── description.md\n    │           │   ├── import-map.json\n    │           │   └── App/\n    │           │       ├── composition.js\n    │           │       ├── options.js\n    │           │       ├── style.css\n    │           │       └── template.html\n    │           ├── step-2/\n    │           │   ├── description.md\n    │           │   ├── _hint/\n    │           │   │   └── App/\n    │           │   │       ├── composition.js\n    │           │   │       ├── options.js\n    │           │   │       └── template.html\n    │           │   └── App/\n    │           │       ├── composition.js\n    │           │       ├── options.js\n    │           │       └── template.html\n    │           ├── step-3/\n    │           │   ├── description.md\n    │           │   ├── _hint/\n    │           │   │   └── App/\n    │           │   │       └── template.html\n    │           │   └── App/\n    │           │       ├── composition.js\n    │           │       ├── options.js\n    │           │       ├── style.css\n    │           │       └── template.html\n    │           ├── step-4/\n    │           │   ├── description.md\n    │           │   ├── _hint/\n    │           │   │   └── App/\n    │           │   │       ├── composition.js\n    │           │   │       ├── options.js\n    │           │   │       └── template.html\n    │           │   └── App/\n    │           │       ├── composition.js\n    │           │       ├── options.js\n    │           │       └── template.html\n    │           ├── step-5/\n    │           │   ├── description.md\n    │           │   ├── _hint/\n    │           │   │   └── App/\n    │           │   │       ├── composition.js\n    │           │   │       ├── options.js\n    │           │   │       └── template.html\n    │           │   └── App/\n    │           │       ├── composition.js\n    │           │       ├── options.js\n    │           │       └── template.html\n    │           ├── step-6/\n    │           │   ├── description.md\n    │           │   ├── _hint/\n    │           │   │   └── App/\n    │           │   │       ├── composition.js\n    │           │   │       ├── options.js\n    │           │   │       └── template.html\n    │           │   └── App/\n    │           │       ├── composition.js\n    │           │       ├── options.js\n    │           │       └── template.html\n    │           ├── step-7/\n    │           │   ├── description.md\n    │           │   ├── _hint/\n    │           │   │   └── App/\n    │           │   │       ├── composition.js\n    │           │   │       └── options.js\n    │           │   └── App/\n    │           │       ├── composition.js\n    │           │       ├── options.js\n    │           │       └── template.html\n    │           ├── step-8/\n    │           │   ├── description.md\n    │           │   ├── _hint/\n    │           │   │   └── App/\n    │           │   │       ├── composition.js\n    │           │   │       ├── options.js\n    │           │   │       └── template.html\n    │           │   └── App/\n    │           │       ├── composition.js\n    │           │       ├── options.js\n    │           │       ├── style.css\n    │           │       └── template.html\n    │           └── step-9/\n    │               ├── description.md\n    │               ├── _hint/\n    │               │   └── App/\n    │               │       ├── composition.js\n    │               │       └── options.js\n    │               └── App/\n    │                   ├── composition.js\n    │                   ├── options.js\n    │                   └── template.html\n    ├── .github/\n    │   ├── dependabot.yml\n    │   ├── pull_request_template.md\n    │   ├── contributing/\n    │   │   └── writing-guide.md\n    │   ├── ISSUE_TEMPLATE/\n    │   │   └── bug_report.yaml\n    │   ├── scripts/\n    │   │   └── tag-alert-blocks.js\n    │   └── workflows/\n    │       ├── automerge.yml\n    │       ├── autosync.yml\n    │       └── ci.yml\n    └── .vitepress/\n        ├── config.ts\n        ├── env.d.ts\n        ├── headerMdPlugin.ts\n        ├── textAdMdPlugin.ts\n        ├── inlined-scripts/\n        │   ├── restorePreference.js\n        │   └── uwu.js\n        └── theme/\n            ├── index.ts\n            ├── components/\n            │   ├── Banner.vue\n            │   ├── CallToActionSection.vue\n            │   ├── CardList.vue\n            │   ├── Home.vue\n            │   ├── NewsLetter.vue\n            │   ├── PageHero.vue\n            │   ├── PageShowcaseListLayout.vue\n            │   ├── preferences.ts\n            │   ├── PreferenceSwitch.vue\n            │   ├── PreferenceTooltip.vue\n            │   ├── ReplLoading.vue\n            │   ├── ScrimbaLink.vue\n            │   ├── SecurityUpdateBtn.vue\n            │   ├── SiteMap.vue\n            │   ├── sponsors.ts\n            │   ├── SponsorsAside.vue\n            │   ├── SponsorsGroup.vue\n            │   ├── TextAd.vue\n            │   ├── VueJobs.vue\n            │   ├── VueMasteryModal.vue\n            │   ├── VueSchoolLink.vue\n            │   └── WwAds.vue\n            └── styles/\n                ├── badges.css\n                ├── index.css\n                ├── inline-demo.css\n                ├── options-boxes.css\n                ├── pages.css\n                ├── style-guide.css\n                ├── utilities.css\n                ├── vars.css\n                ├── vue-mastery.css\n                └── zh-cn.css\n\n================================================\nFILE: README.md\n================================================\n# Vuejs.org 新版中文文档\n\n这里是焕然一新的 [cn.vuejs.org](https://cn.vuejs.org)。\n\n你也可以预览对应的英文原文文档 [https://vuejs.org](https://vuejs.org) 及其代码仓库 [vuejs/docs](https://github.com/vuejs/docs)。\n\n## 如何参与贡献\n\n本仓库是[英文文档仓库](https://github.com/vuejs/docs)的镜像翻译仓库。我们仅对原文进行内容同步与翻译，**不包含**基于英文原版的扩展、删减或演绎等。如对原文有任何意见或建议，欢迎到[英文文档仓库](https://github.com/vuejs/docs)提出 issue 或发起 PR。\n\n有劳访问我们的 [wiki](https://github.com/vuejs-translations/docs-zh-cn/wiki) 了解相关注意事项。\n\n目前网站处于维护状态，我们会定期同步英文版的更新，包括文档内容和前端代码等。欢迎大家：\n\n- 同步英文站点最新的改动到这里\n- 修复错别字或错误的书写格式\n- 发 issue 讨论译法或书写格式\n- 发 issue 讨论部署或协作流程上的问题\n\n同时我们的文档中可能会偶尔存在暂时未翻译的段落，这些段落通常都以 `<!-- TODO: translation -->` 开头作为标记。所以也欢迎大家在源码中搜索这些段落并贡献翻译。你也可以通过[这个链接](https://github.com/vuejs-translations/docs-zh-cn/search?q=TODO%3A+translation)快速找到尚未翻译好的内容。\n\n## 如何在本地编辑和预览该网站\n\n建议使用 [pnpm](https://pnpm.io/) 作为本地开发的包管理器：\n\n```bash\npnpm i\npnpm run dev\n```\n\n该项目要求 Node.js 为 `v18` 或更高版本。并且建议启用 corepack：\n\n```bash\ncorepack enable\n```\n\n## 贡献者列表\n\n最新的文档/翻译贡献情况可以参阅 GitHub 提供的 [contributors](https://github.com/vuejs-translations/docs-zh-cn/graphs/contributors) 页面。\n\n以下是基于该仓库中 PR 和 commit 统计并按总数量排序的所有贡献者，[生成逻辑可在此查阅](https://github.com/ShenQingchuan/github-contributor-svg-generator)。\n\n<p align=\"center\">\n  <a href=\"https://cdn.jsdelivr.net/gh/ShenQingchuan/github-contributor-svg-generator@main/.github-contributors/vuejs-translations_docs-zh-cn.svg\">\n    <img src=\"https://cdn.jsdelivr.net/gh/ShenQingchuan/github-contributor-svg-generator@main/.github-contributors/vuejs-translations_docs-zh-cn.svg\" />\n  </a>\n</p>\n\n## 版权声明\n\n<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\"><img alt=\"知识共享许可协议\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png\" /></a><br />本作品采用<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc-sa/4.0/\">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议  (CC BY-NC-SA 4.0) </a>进行许可。\n\n\n\n================================================\nFILE: env.d.ts\n================================================\n/// <reference types=\"vitepress/client\" />\n\ndeclare module '@vue/theme/config' {\n  import { UserConfig } from 'vitepress'\n  const config: () => Promise<UserConfig>\n  export default config\n}\n\ndeclare module '@vue/theme/highlight' {\n  const createHighlighter: () => Promise<(input: string) => string>\n  export default createHighlighter\n}\n\n\n\n================================================\nFILE: LICENSE\n================================================\nCopyright (c) 2019-present, Yuxi (Evan) You and Vue documentation contributors\n\nThe contents of this repository, **except for all image files**, are licensed under [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/), detailed below. Images in this repository retain the copyright and licensing terms of their respective authors and owners.\n\n---\n\n# Creative Commons Attribution 4.0 International\n\nCreative Commons Corporation (“Creative Commons”) is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an “as-is” basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible.\n\n**Using Creative Commons Public Licenses**\n\nCreative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses.\n\n* __Considerations for licensors:__ Our public licenses are intended for use by those authorized to give the public permission to use material in ways otherwise restricted by copyright and certain other rights. Our licenses are irrevocable. Licensors should read and understand the terms and conditions of the license they choose before applying it. Licensors should also secure all rights necessary before applying our licenses so that the public can reuse the material as expected. Licensors should clearly mark any material not subject to the license. This includes other CC-licensed material, or material used under an exception or limitation to copyright. [More considerations for licensors](http://wiki.creativecommons.org/Considerations_for_licensors_and_licensees#Considerations_for_licensors).\n\n* __Considerations for the public:__ By using one of our public licenses, a licensor grants the public permission to use the licensed material under specified terms and conditions. If the licensor’s permission is not necessary for any reason–for example, because of any applicable exception or limitation to copyright–then that use is not regulated by the license. Our licenses grant only permissions under copyright and certain other rights that a licensor has authority to grant. Use of the licensed material may still be restricted for other reasons, including because others have copyright or other rights in the material. A licensor may make special requests, such as asking that all changes be marked or described. Although not required by our licenses, you are encouraged to respect those requests where reasonable. [More considerations for the public](http://wiki.creativecommons.org/Considerations_for_licensors_and_licensees#Considerations_for_licensees).\n\n## Creative Commons Attribution 4.0 International Public License\n\nBy exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution 4.0 International Public License (\"Public License\"). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.\n\n### Section 1 – Definitions.\n\na. __Adapted Material__ means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image.\n\nb. __Adapter's License__ means the license You apply to Your Copyright and Similar Rights in Your contributions to Adapted Material in accordance with the terms and conditions of this Public License.\n\nc. __Copyright and Similar Rights__ means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights.\n\nd. __Effective Technological Measures__ means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements.\n\ne. __Exceptions and Limitations__ means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material.\n\nf. __Licensed Material__ means the artistic or literary work, database, or other material to which the Licensor applied this Public License.\n\ng. __Licensed Rights__ means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license.\n\nh. __Licensor__ means the individual(s) or entity(ies) granting rights under this Public License.\n\ni. __Share__ means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them.\n\nj. __Sui Generis Database Rights__ means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world.\n\nk. __You__ means the individual or entity exercising the Licensed Rights under this Public License. __Your__ has a corresponding meaning.\n\n### Section 2 – Scope.\n\na. ___License grant.___\n\n   1. Subject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to:\n\n       A. reproduce and Share the Licensed Material, in whole or in part; and\n\n       B. produce, reproduce, and Share Adapted Material.\n\n   2. __Exceptions and Limitations.__ For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions.\n\n   3. __Term.__ The term of this Public License is specified in Section 6(a).\n\n   4. __Media and formats; technical modifications allowed.__ The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a)(4) never produces Adapted Material.\n\n   5. __Downstream recipients.__\n\n       A. __Offer from the Licensor – Licensed Material.__ Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License.\n\n       B. __No downstream restrictions.__ You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material.\n\n   6. __No endorsement.__ Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i).\n\nb. ___Other rights.___\n\n   1. Moral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise.\n\n   2. Patent and trademark rights are not licensed under this Public License.\n\n   3. To the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties.\n\n### Section 3 – License Conditions.\n\nYour exercise of the Licensed Rights is expressly made subject to the following conditions.\n\na. ___Attribution.___\n\n   1. If You Share the Licensed Material (including in modified form), You must:\n\n       A. retain the following if it is supplied by the Licensor with the Licensed Material:\n\n         i. identification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated);\n\n         ii. a copyright notice;\n\n         iii. a notice that refers to this Public License;\n\n         iv. a notice that refers to the disclaimer of warranties;\n\n         v. a URI or hyperlink to the Licensed Material to the extent reasonably practicable;\n\n       B. indicate if You modified the Licensed Material and retain an indication of any previous modifications; and\n\n       C. indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License.\n\n   2. You may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information.\n\n   3. If requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable.\n\n   4. If You Share Adapted Material You produce, the Adapter's License You apply must not prevent recipients of the Adapted Material from complying with this Public License.\n\n### Section 4 – Sui Generis Database Rights.\n\nWhere the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:\n\na. for the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database;\n\nb. if You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material; and\n\nc. You must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database.\n\nFor the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.\n\n### Section 5 – Disclaimer of Warranties and Limitation of Liability.\n\na. __Unless otherwise separately undertaken by the Licensor, to the extent possible, the Licensor offers the Licensed Material as-is and as-available, and makes no representations or warranties of any kind concerning the Licensed Material, whether express, implied, statutory, or other. This includes, without limitation, warranties of title, merchantability, fitness for a particular purpose, non-infringement, absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not known or discoverable. Where disclaimers of warranties are not allowed in full or in part, this disclaimer may not apply to You.__\n\nb. __To the extent possible, in no event will the Licensor be liable to You on any legal theory (including, without limitation, negligence) or otherwise for any direct, special, indirect, incidental, consequential, punitive, exemplary, or other losses, costs, expenses, or damages arising out of this Public License or use of the Licensed Material, even if the Licensor has been advised of the possibility of such losses, costs, expenses, or damages. Where a limitation of liability is not allowed in full or in part, this limitation may not apply to You.__\n\nc. The disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.\n\n### Section 6 – Term and Termination.\n\na. This Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically.\n\nb. Where Your right to use the Licensed Material has terminated under Section 6(a), it reinstates:\n\n   1. automatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or\n\n   2. upon express reinstatement by the Licensor.\n\n   For the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License.\n\nc. For the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License.\n\nd. Sections 1, 5, 6, 7, and 8 survive termination of this Public License.\n\n### Section 7 – Other Terms and Conditions.\n\na. The Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed.\n\nb. Any arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.\n\n### Section 8 – Interpretation.\n\na. For the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License.\n\nb. To the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions.\n\nc. No term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor.\n\nd. Nothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority.\n\n> Creative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the “Licensor.” Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at [creativecommons.org/policies](http://creativecommons.org/policies), Creative Commons does not authorize the use of the trademark “Creative Commons” or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses.\n>\n> Creative Commons may be contacted at creativecommons.org\n\n\n\n================================================\nFILE: netlify.toml\n================================================\n[build.environment]\n  NODE_VERSION = \"22\"\n\n[build]\n  publish = \".vitepress/dist\"\n  command = \"pnpm run build\"\n\n\n\n================================================\nFILE: package.json\n================================================\n{\n  \"license\": \"CC BY-NC-SA 4.0\",\n  \"engines\": {\n    \"node\": \">=18.0.0\",\n    \"pnpm\": \">=7.4.0\"\n  },\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vitepress\",\n    \"build\": \"vitepress build\",\n    \"preview\": \"vitepress preview\",\n    \"lint\": \"zhlint \\\"src/{api,about,guide,sponsor,translations,tutorial}/**/*.md\\\"\",\n    \"clean\": \"rm -rf .vitepress/dist\",\n    \"sync\": \"node scripts/sync.js\",\n    \"preinstall\": \"npx only-allow pnpm\",\n    \"type\": \"vue-tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"@vue/repl\": \"^4.4.2\",\n    \"@vue/theme\": \"^2.3.0\",\n    \"dynamics.js\": \"^1.1.5\",\n    \"gsap\": \"^3.12.5\",\n    \"vitepress\": \"^1.6.4\",\n    \"vue\": \"^3.5.12\"\n  },\n  \"devDependencies\": {\n    \"@types/body-scroll-lock\": \"^3.1.2\",\n    \"@types/markdown-it\": \"^14.1.2\",\n    \"@types/node\": \"^22.7.5\",\n    \"chalk\": \"^4.1.2\",\n    \"commander\": \"^9.4.0\",\n    \"gray-matter\": \"^4.0.3\",\n    \"lodash\": \"^4.17.21\",\n    \"open\": \"^8.4.0\",\n    \"simple-git\": \"^2.48.0\",\n    \"typescript\": \"^5.6.3\",\n    \"vitepress-plugin-group-icons\": \"^1.5.4\",\n    \"vitepress-plugin-llms\": \"^0.0.8\",\n    \"vue-tsc\": \"^2.1.6\",\n    \"zhlint\": \"^0.8.1\"\n  },\n  \"packageManager\": \"pnpm@9.12.1\"\n}\n\n\n\n================================================\nFILE: tsconfig.json\n================================================\n{\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"target\": \"esnext\",\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \"allowJs\": true,\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"skipLibCheck\": true,\n    \"jsx\": \"preserve\",\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@theme/*\": [\".vitepress/theme/*\"]\n    }\n  },\n  \"include\": [\"env.d.ts\", \"src/**/*\", \".vitepress/**/*\"]\n}\n\n\n\n================================================\nFILE: vercel.json\n================================================\n{\n  \"$schema\": \"https://openapi.vercel.sh/vercel.json\",\n  \"headers\": [\n    {\n      \"source\": \"/assets/(.*)\",\n      \"headers\": [\n        {\n          \"key\": \"Cache-Control\",\n          \"value\": \"max-age=31536000, immutable\"\n        }\n      ]\n    },\n    {\n      \"source\": \"/(.*).png\",\n      \"headers\": [\n        {\n          \"key\": \"Cache-Control\",\n          \"value\": \"max-age=604800, immutable\"\n        }\n      ]\n    }\n  ],\n  \"rewrites\": [\n    {\n      \"source\": \"/:path*\",\n      \"destination\": \"/:path*.html\"\n    }\n  ],\n  \"redirects\": [\n    {\n      \"source\": \"/v2/:path*\",\n      \"destination\": \"https://v2.cn.vuejs.org/v2/:path*\"\n    },\n    {\n      \"source\": \"/v2/:path*/\",\n      \"destination\": \"https://v2.cn.vuejs.org/v2/:path*/\"\n    }\n  ]\n}\n\n\n\n================================================\nFILE: .editorconfig\n================================================\n[*]\ncharset = utf-8\nindent_style = space\nindent_size = 2\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n[*.md]\ntrim_trailing_whitespace = false\n\n\n\n================================================\nFILE: .npmrc\n================================================\npackage-manager-strict=false\n\n\n\n================================================\nFILE: .prettierignore\n================================================\n*.vue\n\n\n\n================================================\nFILE: .prettierrc\n================================================\n{\n  \"semi\": false,\n  \"singleQuote\": true,\n  \"trailingComma\": \"none\",\n  \"printWidth\": 75\n}\n\n\n\n================================================\nFILE: .zhlintcaseignore\n================================================\n> {#\n？ {#\n！ {#\n<span class=\"options-api\">\n<span class=\"composition-api\">\n</span>\n) [[源码]\n\n\n================================================\nFILE: .zhlintrc\n================================================\n{\n  \"preset\": \"default\",\n  \"rules\": {\n    \"adjustedFullwidthPunctuation\": \"‘’\"\n  }\n}\n\n\n\n================================================\nFILE: assets/FileExplorer.vue\n================================================\n<!-- original link: https://gist.github.com/yyx990803/8854f8f6a97631576c14b63c8acd8f2e -->\n\n<script setup>\nimport { useQuery, mutate } from 'vue-apollo'\nimport { ref, reactive, watch, nextTick } from 'vue'\nimport { onBeforeRouteLeave } from 'vue-router'\n\n// Reusable functions not specific to this component\nimport { useNetworkState } from '@/functions/network'\nimport { usePathUtils } from '@/functions/path'\nimport { resetCwdOnLeave, useCwdUtils } from '@/functions/cwd'\n\n// GraphQL\nimport FOLDER_CURRENT from '@/graphql/folder/folderCurrent.gql'\nimport FOLDERS_FAVORITE from '@/graphql/folder/favoriteFolders.gql'\nimport FOLDER_OPEN from '@/graphql/folder/folderOpen.gql'\nimport FOLDER_OPEN_PARENT from '@/graphql/folder/folderOpenParent.gql'\nimport FOLDER_SET_FAVORITE from '@/graphql/folder/folderSetFavorite.gql'\nimport PROJECT_CWD_RESET from '@/graphql/project/projectCwdReset.gql'\nimport FOLDER_CREATE from '@/graphql/folder/folderCreate.gql'\n\n// Misc\nimport { isValidMultiName } from '@/util/folders'\nconst SHOW_HIDDEN = 'vue-ui.show-hidden-folders'\n\n// Network\nconst { networkState } = useNetworkState()\n\n// Folder\nconst { folders, currentFolderData } = useCurrentFolderData(networkState)\nconst folderNavigation = useFolderNavigation({ networkState, currentFolderData })\nconst { favoriteFolders, toggleFavorite } = useFavoriteFolders(currentFolderData)\nconst { showHiddenFolders } = useHiddenFolders()\nconst createFolder = useCreateFolder(folderNavigation.openFolder)\n\n// Current working directory\nresetCwdOnLeave()\nconst { updateOnCwdChanged } = useCwdUtils()\n\n// Utils\nconst { slicePath } = usePathUtils()\n\n// Reusable functions specific to this component\nfunction useCurrentFolderData (networkState) {\n  const folders = ref(null)\n\n  const currentFolderData = useQuery({\n    query: FOLDER_CURRENT,\n    fetchPolicy: 'networkState-only',\n    networkState,\n    async result () {\n      await nextTick()\n      folders.scrollTop = 0\n    }\n  }, {})\n  return {\n    folders,\n    currentFolderData\n  }\n}\n\nfunction useFolderNavigation ({ networkState, currentFolderData }) {\n  // Path editing\n  const pathEditing = reactive({\n    editingPath: false,\n    editedPath: '',\n  })\n\n  // DOM ref\n  const pathInput = ref(null)\n\n  async function openPathEdit () {\n    pathEditing.editedPath = currentFolderData.path\n    pathEditing.editingPath = true\n    await nextTick()\n    pathInput.focus()\n  }\n\n  function submitPathEdit () {\n    openFolder(pathEditing.editedPath)\n  }\n\n  // Folder opening\n  const openFolder = async (path) => {\n    pathEditing.editingPath = false\n    networkState.error = null\n    networkState.loading++\n    try {\n      await mutate({\n        mutation: FOLDER_OPEN,\n        variables: {\n          path\n        },\n        update: (store, { data: { folderOpen } }) => {\n          store.writeQuery({ query: FOLDER_CURRENT, data: { currentFolderData: folderOpen } })\n        }\n      })\n    } catch (e) {\n      networkState.error = e\n    }\n    networkState.loading--\n  }\n\n  async function openParentFolder () {\n    pathEditing.editingPath = false\n    networkState.error = null\n    networkState.loading++\n    try {\n      await mutate({\n        mutation: FOLDER_OPEN_PARENT,\n        update: (store, { data: { folderOpenParent } }) => {\n          store.writeQuery({ query: FOLDER_CURRENT, data: { currentFolderData: folderOpenParent } })\n        }\n      })\n    } catch (e) {\n      networkState.error = e\n    }\n    networkState.loading--\n  }\n\n  // Refresh\n  function refreshFolder () {\n    openFolder(currentFolderData.path)\n  }\n\n  return {\n    pathInput,\n    pathEditing,\n    openPathEdit,\n    submitPathEdit,\n    openFolder,\n    openParentFolder,\n    refreshFolder\n  }\n}\n\nfunction useFavoriteFolders (currentFolderData) {\n  const favoriteFolders = useQuery(FOLDERS_FAVORITE, [])\n\n  async function toggleFavorite () {\n    await mutate({\n      mutation: FOLDER_SET_FAVORITE,\n      variables: {\n        path: currentFolderData.path,\n        favorite: !currentFolderData.favorite\n      },\n      update: (store, { data: { folderSetFavorite } }) => {\n        store.writeQuery({ query: FOLDER_CURRENT, data: { currentFolderData: folderSetFavorite } })\n        let data = store.readQuery({ query: FOLDERS_FAVORITE })\n        // TODO this is a workaround\n        // See: https://github.com/apollographql/apollo-client/issues/4031#issuecomment-433668473\n        data = {\n          favoriteFolders: data.favoriteFolders.slice()\n        }\n        if (folderSetFavorite.favorite) {\n          data.favoriteFolders.push(folderSetFavorite)\n        } else {\n          const index = data.favoriteFolders.findIndex(\n            f => f.path === folderSetFavorite.path\n          )\n          index !== -1 && data.favoriteFolders.splice(index, 1)\n        }\n        store.writeQuery({ query: FOLDERS_FAVORITE, data })\n      }\n    })\n  }\n\n  return {\n    favoriteFolders,\n    toggleFavorite\n  }\n}\n\nfunction useHiddenFolders () {\n  const showHiddenFolders = ref(localStorage.getItem(SHOW_HIDDEN) === 'true')\n  watch(showHiddenFolders, value => {\n    if (value) {\n      localStorage.setItem(SHOW_HIDDEN, 'true')\n    } else {\n      localStorage.removeItem(SHOW_HIDDEN)\n    }\n  }, { lazy: true })\n\n  return {\n    showHiddenFolders\n  }\n}\n\nfunction useCreateFolder (openFolder) {\n  const showNewFolder = ref(false)\n  const newFolderName = ref('')\n  const newFolderValid = computed(() => isValidMultiName(newFolderName.value))\n\n  async function createFolder () {\n    if (!newFolderValid.value) return\n    const result = await mutate({\n      mutation: FOLDER_CREATE,\n      variables: {\n        name: newFolderName.value\n      }\n    })\n    openFolder(result.data.folderCreate.path)\n    newFolderName.value = ''\n    showNewFolder.value = false\n  }\n\n  return {\n    showNewFolder,\n    newFolderName,\n    newFolderValid,\n    createFolder\n  }\n}\n</script>\n\n<template>\n  ...omitted\n</template>\n\n\n\n================================================\nFILE: scripts/sync.js\n================================================\nimport { Command } from 'commander';\nimport SimpleGit from 'simple-git';\nimport open from 'open';\n\nconst program = new Command();\n\nasync function getLatestSyncHash () {\n  const git = SimpleGit();\n  const history = await git.log(['origin/main']);\n  const latestSync = history.all.find(v => /^sync #\\w{7}\\w?\\s?$/i.test(v.body))?.body?.trim();\n  // console.log(history.all[0])\n  if (!latestSync) {\n    throw new Error('No hash found. Are there any commit with `sync #hash` message in git history?');\n  }\n  // console.log(latestSync)\n  return latestSync.match(/#(\\w{7}\\w?)/)[1];\n}\n\nasync function getLatestUpstreamHash () {\n  const git = SimpleGit();\n  const latestUpstreamHash = await git.show(['-s', '--format=\"%h\"', 'origin/upstream']);\n  return latestUpstreamHash.trim().replace(/\"/g, '');\n}\n\nprogram\n  .name('sync')\n  .description('The sync helper CLI');\n\nprogram.command('compare')\n  .description('Open the github website to compare diffs to sync.')\n  .action(async () => {\n    open(`https://github.com/vuejs/docs/compare/${await getLatestSyncHash()}...${await getLatestUpstreamHash()}`);\n  });\n\nprogram.command('pr')\n  .description('Generate sync PR\\'s title and content.')\n  .option('-o, --open', 'directly open link to create pr (sync branch->main branch)')\n  .action(async (options) => {\n    const latestUpstreamHash = await getLatestUpstreamHash();\n    const latestSyncHash = await getLatestSyncHash();\n\n    const title = `Sync #${latestUpstreamHash}`;\n    const body = `## Description of Problem\n\nhttps://github.com/vuejs/docs/compare/${latestSyncHash}...${latestUpstreamHash}\n`;\n\n    console.log(`\n--- PR Title ---:\n${title}\n\n--- PR Content ---:\n${body}`);\n\n    if (options.open) {\n      open(`https://github.com/vuejs-translations/docs-zh-cn/compare/main...sync?quick_pull=1&title=${encodeURIComponent(title)}&body=${encodeURIComponent(body)}&labels=${encodeURIComponent('从英文版同步,请使用 merge commit 合并')}`);\n    }\n  });\n\nprogram.parse();\n\n\n\n================================================\nFILE: src/index.md\n================================================\n---\npage: true\ntitle: Vue.js - 渐进式 JavaScript 框架\n---\n\n<script setup>\nimport Home from '@theme/components/Home.vue'\n</script>\n\n<Home />\n\n\n\n================================================\nFILE: src/about/coc.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/about/community-guide.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/about/faq.md\n================================================\n# 常见问题 {#frequently-asked-questions}\n\n## 谁在维护 Vue？ {#who-maintains-vue}\n\nVue 是一个独立的社区驱动的项目。它是由[尤雨溪](https://twitter.com/yuxiyou)在 2014 年作为其个人项目创建的。今天，Vue 由[来自世界各地的全职成员和志愿者组成的团队](/about/team)积极活跃地维护着，并由尤雨溪担任项目负责人。你可以在[这部纪录片](https://www.youtube.com/watch?v=OrxmtDw4pVI)中了解更多关于 Vue 的故事。\n\n自 2016 年以来，Vue 的发展主要是通过赞助来保障的，我们在财务上是可维续的。如果你或你的企业从 Vue 中受益，请考虑[赞助](/sponsor/)我们，以支持 Vue 的发展！\n\n## Vue 2 和 Vue 3 之间的区别是什么？ {#what-s-the-difference-between-vue-2-and-vue-3}\n\nVue 3 是 Vue 当前的最新主版本。它包含了一些 Vue 2 中没有的新特性 (比如 Teleport、Suspense，以及多根元素模板)。同时它也包含了一些与 Vue 2 非兼容性的变更。细节文档请参考 [Vue 3 迁移指南](https://v3-migration.vuejs.org/zh/)。\n\n尽管存在差异，但大多数 Vue API 在两个大版本之间是共享的，所以你的大部分 Vue 2 知识将继续在 Vue 3 中发挥作用。需要注意的是，组合式 API 原本是一个 Vue 3 独有的特性，但目前已兼容至 Vue 2 且在 [Vue 2.7](https://github.com/vuejs/vue/blob/main/CHANGELOG.md#270-2022-07-01) 中可用。\n\n总的来说，Vue 3 提供了更小的包体积、更好的性能、更好的可扩展性和更好的 TypeScript/IDE 支持。如果你现在要开始一个新项目，我们推荐你选择 Vue 3。但也仍然存在一些考虑使用 Vue 2 的理由：\n\n- 你需要支持 IE11。Vue 3 用到了一些 IE11 不支持的现代 JavaScript 特性。\n\n如果你打算将现有的 Vue 2 应用迁移到 Vue 3，请查阅[迁移指南](https://v3-migration.vuejs.org/zh/)。\n\n## Vue 2 仍在维护吗？ {#is-vue-2-still-supported}\n\nVue 2 在 2022 年 6 月发布了最后一个小版本 (2.7)。目前 Vue 2 已经进入维护模式：它将不再提供新特性，但从 2.7 的发布日期开始的 18 个月内，它将继续针对重大错误修复和安全更新进行发布。这意味着 **Vue 2 已在 2023 年 12 月 31 日到达它的截止维护日期**。\n\n我们相信这将为大多数的生态系统提供了足够长的时间来迁移到 Vue 3。然而，我们也理解可能会有无法在此时间轴上升级的团队或项目仍需满足其安全及合规需求。我们正在与业内专家合作为有这种需求的团队提供 Vue 2 的扩展支持——如果您的团队预期在 2023 年底之后仍然需要使用 Vue 2，请确保提前计划，详见 [Vue 2 延长 LTS](https://v2.vuejs.org/lts/)。\n\n## Vue 使用什么开源协议？ {#what-license-does-vue-use}\n\nVue 是完全免费的开源项目，且基于 [MIT License](https://opensource.org/licenses/MIT) 发布。\n\n## Vue 支持哪些浏览器？ {#what-browsers-does-vue-support}\n\n最新版本的 Vue (3.x) 只支持[原生支持 ES2016 的浏览器](https://caniuse.com/es2016)。这并不包括 IE11。Vue 3.x 使用的 ES2016 功能无法在旧版本的浏览器中进行兼容，如果你需要支持旧版本的浏览器，请使用 Vue 2.x 替代。\n\n## Vue 可靠吗？ {#is-vue-reliable}\n\nVue 是一个成熟的、经历了无数实战考验的框架。它是目前生产环境中使用最广泛的 JavaScript 框架之一，在全球拥有超过 150 万用户，并且在 npm 上的月下载量超过 1000 万次。\n\nVue 被世界各地知名且多元的组织在生产环境中使用，包括 Wikimedia 基金会、美国宇航局、苹果、谷歌、微软、GitLab、Zoom、腾讯、微博、哔哩哔哩、快手等等。\n\n## Vue 速度快吗？ {#is-vue-fast}\n\nVue 3 是性能最强的主流前端框架之一，可以轻松处理大多数 web 应用的场景，并且几乎不需要手动优化。\n\n跑分方面，Vue 在 [js-framework-benchmark](https://krausest.github.io/js-framework-benchmark/current.html) 中的表现比 React 和 Angular 要好得多。在该基准测试中，它还与一些生产环境下最快级别的非虚拟 DOM 框架并驾齐驱。\n\n请注意，像上面这样的跑分的侧重点在于原始渲染性能在特定情况下的优化，因此不能完全代表真实世界的性能结果。如果你更关心页面加载性能，欢迎用 [WebPageTest](https://www.webpagetest.org/lighthouse) 或是 [PageSpeed Insights](https://pagespeed.web.dev/) 来测试本站。本文档站是一个完全由 Vue 本身构建，通过静态生成预渲染，并在客户端进行 hydration 的单页应用。它在模拟 4 倍 CPU 降速的 Moto G4 + 低速 4G 网络的情况下依然能获得 100 分的性能得分。\n\n你可以在[渲染机制](/guide/extras/rendering-mechanism)章节了解更多关于 Vue 如何自动优化运行时性能的信息，也可以在[性能优化指南](/guide/best-practices/performance)中了解如何在特别苛刻的情况下优化 Vue 应用。\n\n## Vue 体积小吗？ {#is-vue-lightweight}\n\n当你通过构建工具使用时，Vue 的许多 API 都是可以[“tree-shake”](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking)的。例如，如果你不使用内置的 `<Transition>` 组件，它就不会被包含在最终的生产环境包里。\n\n对于一个 Vue 的最少 API 使用的 hello world 应用来说，配合最小化和 brotli 压缩，其基线大小只有 **16kb** 左右。但实际的应用大小取决于你使用了多少框架的可选特性。在极端情况下，如果一个应用使用了 Vue 提供的每一个特性，那么总的运行时大小大约为 **27kb**。\n\n如果不通过构建工具使用 Vue，我们不仅失去了 tree-shaking，而且还必须将模板编译器加载到浏览器。这就使包体积增大到了 **41kb** 左右。因此，如果你为了渐进式增强在没有构建步骤的情况下使用 Vue，则可以考虑使用 [petite-vue](https://github.com/vuejs/petite-vue) (仅 **6kb**) 来代替。\n\n一些诸如 Svelte 的框架使用了一种为单个组件产生极轻量级输出的编译策略。然而，[我们的研究](https://github.com/yyx990803/vue-svelte-size-analysis)表明，包大小的差异在很大程度上取决于应用中的组件数量。虽然 Vue 的基线大小更重，但它生成的每个组件的代码更少。在现实的场景中，Vue 应用很可能最终会更轻。\n\n## Vue 能胜任大规模场景吗？ {#does-vue-scale}\n\n是的。尽管有一种误解是 Vue 只适用于简单的场景，但其实 Vue 完全有能力处理大规模的应用：\n\n- [单文件组件](/guide/scaling-up/sfc)提供了一个模块化的开发模型，让应用的不同部分能够被隔离开发。\n\n- [组合式 API](/guide/reusability/composables) 提供一流的 TypeScript 集成，并为组织、提取和重用复杂逻辑提供了简洁的模式。\n\n- [全面的工具链支持](/guide/scaling-up/tooling)使得开发体验在应用增长的过程中依然可以保持平滑。\n\n- 较低的入门门槛和优秀的文档能够显著降低新手开发者的入职和培训成本。\n\n## 我可以为 Vue 做贡献吗？ {#how-do-i-contribute-to-vue}\n\n非常欢迎！请阅读我们的[社区指南](/about/community-guide)。\n\n## 我应该使用选项式 API 还是组合式 API？ {#should-i-use-options-api-or-composition-api}\n\n如果你是 Vue 的新手，我们在[这里](/guide/introduction#which-to-choose)提供了一个两者之间宏观的比较。\n\n如果你过去使用过选项式 API 且正在评估组合式 API，可以查阅[组合式 API 常见问题](/guide/extras/composition-api-faq)。\n\n## 用 Vue 的时候应该选 JS 还是 TS？ {#should-i-use-javascript-or-typescript-with-vue}\n\n虽然 Vue 本身是用 TypeScript 实现的，并提供一流的 TypeScript 支持，但它并不强制要求用户使用 TypeScript。\n\n在向 Vue 添加新特性时，对 TypeScript 的支持是一个重要的考虑因素。即使你自己不使用 TypeScript，考虑了 TypeScript 支持的 API 设计也通常更容易被 IDE 和静态分析工具分析，因此这对大家都有好处。Vue 的 API 设计也尽可能在 JavaScript 和 TypeScript 中以相同的方式工作。\n\n选用 TypeScript 会涉及在上手复杂性和长期可维护性收益之间作出权衡。这种权衡是否合理取决于你的团队背景和项目规模，但 Vue 并不会真正成为影响这一决定的因素。\n\n## Vue 相比于 Web Components 究竟如何？ {#how-does-vue-compare-to-web-components}\n\nVue 是在 Web Components 出现之前被创建的，Vue 在某些方面的设计 (例如插槽) 受到了 Web Components 模型的启发。\n\nWeb Components 规范相对底层一些，因为它们是以自定义元素为中心的。作为一个框架，Vue 解决了更多上层的问题，如高效的 DOM 渲染、响应式状态管理、工具链、客户端路由和服务器端渲染等。\n\nVue 完全支持在 Vue 组件中使用原生自定义元素，也支持将 Vue 组件导出为原生自定义元素——请参阅 [Vue 和 Web Components 指南](/guide/extras/web-components)以了解更多细节。\n\n<!-- ## TODO How does Vue compare to React? -->\n\n<!-- ## TODO How does Vue compare to Angular? -->\n\n\n\n================================================\nFILE: src/about/privacy.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/about/releases.md\n================================================\n---\noutline: deep\n---\n\n<script setup>\nimport { ref, onMounted } from 'vue'\n\nconst version = ref()\n\nonMounted(async () => {\n  const res = await fetch('https://api.github.com/repos/vuejs/core/releases/latest')\n  version.value = (await res.json()).name\n})\n</script>\n\n# 版本发布 {#releases}\n\n<p v-if=\"version\">\n当前 Vue 的最新稳定版本是 <strong>{{ version }}</strong>。\n</p>\n<p v-else>\n正在检测最新版本……\n</p>\n\n完整的过往发布记录可以在 [GitHub](https://github.com/vuejs/core/blob/main/CHANGELOG.md) 查阅。\n\n## 发布周期 {#release-cycle}\n\nVue 并没有固定的发布周期。\n\n- 补丁版本 (patch releases) 发布会及时按需进行。\n\n- 小版本 (minor releases) 发布总是会包含一些新特性，发布周期通常会在 3~6 个月之间，并会经历 beta 预发布阶段。\n\n- 大版本 (major releases) 发布会提前知会，且经历早期讨论和 alpha、beta 等预发布阶段。\n\n## 语义化版本控制的特殊情况 {#semantic-versioning-edge-cases}\n\nVue 的发布会遵循[语义化版本控制](https://semver.org/)，同时伴随一些特殊情况。\n\n### TypeScript 类型声明 {#typescript-definitions}\n\n我们可能会在**小版本**发布之间包含 TypeScript 类型声明的不兼容变更，因为：\n\n1. 有的时候 TypeScript 自身会在其小版本之间发布不兼容变更，我们不得不为了支持更新版本的 TypeScript 而调整自身的类型定义。\n\n2. 我们也会偶尔需要使用最新版本的 TypeScript 中才可用的特性，并提升 TypeScript 的最低版本要求。\n\n如果你正在使用 TypeScript，则可以使用一个语义化版本的范围来锁住当前的小版本，并在 Vue 新的小版本发布时进行手动升级。\n\n### 编译后的代码和旧版运行时之间的兼容性 {#compiled-code-compatibility-with-older-runtime}\n\n较新**小版本**的 Vue 编译器可能会生成与较旧小版本的 Vue 运行时不兼容的代码。例如，由 Vue 3.2 编译器生成的代码可能不完全兼容 Vue 3.1 的运行时。\n\n只有库的作者需要考虑这个问题，因为编译器版本和运行时版本在应用中总是相同的。只有当你把预编译的 Vue 组件代码发布为一个包，而用户在一个使用旧版本 Vue 的项目中使用它时，才会发生版本不匹配。因此，你的包可能需要明确声明 Vue 的最低小版本要求。\n\n## 预发布版本 {#pre-releases}\n\n小版本发布通常会经历不定量的 beta 版。而大版本发布则会经历 alpha 和 beta 阶段。\n\n此外，我们每周都会从 GitHub 上的 `main` 和 `minor` 分支发布金丝雀版本。它们将作为不同的软件包发布以避免稳定通道的 npm 元数据变得臃肿。你可以分别通过 `npx install-vue@canary` 或 `npx install-vue@canary-minor` 安装它们。\n\n预发布版本 (pre releases) 是为了进行集成/稳定性测试，并让早期用户为不稳定的功能提供反馈。请不要在生产中使用预发布版本。所有的预发布版本都被认为是不稳定的，并且可能会在两者之间产生不兼容变更，所以在使用预发布版本时，一定要精确锁定版本号。\n\n## 废弃的特性 {#deprecations}\n\n我们可能会定期废弃那些在新的小版本中拥有更新更好的替代品的功能。被废弃的功能仍将继续工作，但会在进入废弃状态后的下一个大版本中被删除。\n\n## RFC {#rfcs}\n\n具有可观表层 API 的新特性和 Vue 的重大变更都将经历**意见征集** (RFC) 流程。RFC 流程的目的是为新功能进入该框架提供一个一致且可控的路径，并给用户一个机会参与设计过程并提供反馈。\n\n该 RFC 流程会在 GitHub 上的 [vuejs/rfcs](https://github.com/vuejs/rfcs) 仓库进行。\n\n## 试验性特性 {#experimental-features}\n\n有些特性在 Vue 的稳定版本中已经发布并被记录了，但被标记为试验性的。试验性特性通常与某些 RFC 讨论相关联，这些讨论中的大部分设计问题已经在理论上得到了解决，但仍缺乏来自真实实践的反馈。\n\n试验性特性的目的是允许用户通过在生产环境中测试它们来提供反馈，而不必使用不稳定的 Vue 版本。试验性特性本身是被认为不稳定的，只能以某种受控的方式使用，且该特性可预期地会在任何发布类型中发生变化。\n\n\n\n================================================\nFILE: src/about/team.md\n================================================\n---\npage: true\ntitle: Vue 工作团队\n---\n\n<script setup>\nimport TeamPage from './team/TeamPage.vue'\n</script>\n\n<TeamPage />\n\n\n\n================================================\nFILE: src/about/translation.md\n================================================\n---\naside: deep\n---\n\n# 翻译说明\n\n该中文文档翻译由 [@ShenQingchuan](https://github.com/ShenQingchuan) 个人发起，随后作为 Vue 官方认可的中文翻译仓库，以团队的形式进行官方维护。最新的代码仓库链接是：https://github.com/vuejs-translations/docs-zh-cn\n\n## 翻译须知\n\n请移步至官方仓库的 [wiki 页面](https://github.com/vuejs-translations/docs-zh-cn/wiki/%E7%BF%BB%E8%AF%91%E9%A1%BB%E7%9F%A5)查阅。\n\n## 协作指南\n\n请移步至官方仓库的 [wiki 页面](https://github.com/vuejs-translations/docs-zh-cn/wiki/%E5%8D%8F%E4%BD%9C%E6%8C%87%E5%8D%97)查阅。\n\n> 编写文档是一种换位思考的练习。我们并不是在描述客观现实，那是源代码已经做到了的。我们的工作是帮助塑造用户与 Vue 生态系统之间的关系。\n\n<details>\n<summary>原版翻译说明，仅供备忘和归档</summary>\n\n## 基本原则\n\n翻译工作追求的无外乎 “信、达、雅” 三个字，因此我们总结了以下原则：\n\n1. **忠实原文，通俗易懂**，保证正确是最基本的要求。此外，还应该尽可能将一些特定概念降维，使得入门级读者也能够流畅阅读。\n\n2. **中文词汇优先，特殊概念次之**：要尽可能地将文档中的英语单词译作读者好理解的词汇。\n\n   同时用词应尽可能地从前端开发领域已有的词汇中衍生。我们认为作为 Vue 文档的译者应承担这样一种职责：避免创建一套独立于标准 JavaScript 环境之外、Vue 专属的语境。\n\n   但也有例外的情况，某些英文单词我们倾向于选择不翻译、用原词。开发者常常与一部分英语单词打交道，许多英语单词甚至作为了开发框架或操作系统的专有名词，直接抛出这个单词也的确能够帮助用户更好的理解、锁定所讲的是什么概念。\n\n3. **更符合中文的表述方式**：我们必须正视英语和中文本身的差异与不同，由于表达方式和语法结构的区别，常常一个结构复杂的多重定语从句很难逐字逐词地直译成中文，翻译出的句子应符合母语者的叙述习惯，即尽可能避免英语式的倒装(哪怕讲述方式与作者原文有较大区别)，表述尽可能口语化。最好的方式应该是将视线从单个句子中移出来，结合上下文先进行理解再用中文的习惯性表达将其重新复述出来。\n\n## 格式规范\n\n### 提交规范\n\n可以参考 [这个网站](https://www.conventionalcommits.org/) 了解提交信息的既定书写格式：\n\n```text\n<type>(<scope>): <subject>\n^-------------^  ^-------^\n|                |\n|                +-> 主题。总结 commit 内容，用现在时书写。\n|\n+-------> 目的: chore, docs, feat, fix, refactor, style, 或 test。<scope> 为可选项。\n\n// 以下是 body 部分，这部分是可选的：\n  hash: (对应到官方英文文档的某次更新 commit hash)\n  time: (由 `new Date().toLocaleString()` 生成的时间戳)\n```\n\n- 如果你贡献提交的目的并不是与官方英文文档同步内容相关，为 `chore` 或其他类型，body 部分可以省略。\n- body 部分的信息只是为了在特定情况下方便溯源。\n\n#### 释义\n\n- feat: (新功能，面向用户)\n- fix: (bug 修复，面向用户)\n- docs: (编辑文档)\n- style: (格式，如全角半角；对生产环境没有影响)\n- refactor: (比如重命名变量)\n- test: (加入缺少的测试，对生产环境没有影响)\n- chore: (更新依赖等，对生产环境没有影响)\n\n### 文档格式规范\n\n#### 译注写法\n\n1. 在原文需要加译者注的位置添加角标：\n\n```html\n... <sup>[[1]](#footnote-1)</sup> ... <sup>[[2]](#footnote-2)</sup> ...\n```\n\n2. 在文章最末尾加入译者注的内容，格式如下：\n\n```html\n<small>\n  __译者注__\n  <a id=\"footnote-1\"></a>[1] ... <a id=\"footnote-2\"></a>[2] ...\n  <a id=\"footnote-3\"></a>[3] ...\n</small>\n```\n\n#### 标点符号\n\n- 逗号、句号、分号、冒号、叹号、问号，统一使用全角字符：，。；：！？\n- 破折号使用：——\n- 引号统一使用 “ ” 和 ‘ ’\n- 括号统一使用半角括号 ()\n- 非注释部分的代码除外，保留英文标点符号。\n\n#### 内联代码或代码关键字\n\n- 务必用反引号(即英文输入法下，按键盘上 Tab 键上方的那个键)将内容括起来。\n- 包括代码注释中出现代码或代码关键字时，也要括起来。\n\n#### 空格的使用\n\n- 英文单词和英文单词之间要有一个空格\n  `something in English`\n\n- 中文和英文单词之间要有一个空格\n  `中文当中有 something 是英文`\n\n- 英文单词和标点符号之间没有空格\n  `这里是一句中文，something 又是英文`\n\n#### 链接、斜体、粗体与行内代码等\n\n对于 Markdown 中上述的行内简单样式，为了保证 Vitepress 中良好的渲染效果，我们提倡在文档中使用如下的格式：\n\n```markdown\n<!-- 链接 -->\n\n这是一个 [链接](https://github.com/vitejs/vite) 指向 Vite 官方仓库\n\n<!-- 加粗 -->\n\n这是一个 **加粗** 的文字\n\n<!-- 斜体 -->\n\n这是一个 _斜体_ 的文字 <!-- Good -->\n这是一个 _斜体_ 的文字 <!-- 不推荐，尽在下划线效果不可用时作为替代使用 -->\n\n<!-- 行内代码 -->\n\n这是一个 `code` 行内代码\n假如后面就是标点符号 `code`：\n```\n\n你可能已经注意到，默认情况下，在两端我们都加上了空格。\n\n**此处的某些规则可能暂时和旧有的 [Vue.js 中文文档的风格](https://github.com/vuejs/cn.vuejs.org/wiki) 不太一致**，如果你曾参与过 Vue 中文文档相关工作，可能与你的习惯有一定区别。\n\n这是为了保证文档视图中不会出现字符靠太近而黏合的问题。\n\n关于文档中的链接，针对以下两种 Markdown 书写：\n\n```markdown\n<!-- 链接前后带空格  -->\n\nVite 支持了一套 [通用插件 API](./api-plugin) 扩展了 Rollup 的插件接口\n\n<!-- 链接前后不带空格 -->\n\nVite 支持了一套[通用插件 API](./api-plugin)扩展了 Rollup 的插件接口\n```\n\nVitepress 和 Vuepress 中对以上两种写法的渲染视觉效果为：\n\n**链接前后带空格**\n\n![链接前后带空格](/images/link-with-around-spaces.png)\n\n**链接前后不带空格**\n\n![链接前后不带空格](/images/link-without-around-spaces.png)\n\n不带空格的形式 与 带空格相比，没有那么突出。\n\n同样这类情况还包括 Markdown 中的斜体字：\n\n```markdown\n这是一个_斜体_尝试 <!-- Vitepress 和 Vuepress 中无效！  -->\n\n这是一个*斜体*尝试 <!-- 前后无空格 -->\n\n这是一个 *斜体* 尝试 <!-- 前后有空格 -->\n```\n\n下面是效果，不带空格的情况看上去中文字体的笔画之间会接在一起，变得很拥挤，观感较差。\n\n![斜体尝试](/images/italic-demo.png)\n\n#### 关于加粗和斜体格式的约定\n\n根据 [GitHub Flavored Markdown Spec](https://github.github.com/gfm/#emphasis-and-strong-emphasis)，用成对的星号或下划线都可以用来代表加粗或斜体，但是使用下划线的时候存在更多的特殊条件限制，例如：\n\n> `5*6*78` → `<p>5<em>6</em>78</p>` https://github.github.com/gfm/#example-346\n>\n> `5_6_78` → `<p>5_6_78</p>` https://github.github.com/gfm/#example-351\n\n经过讨论，考虑到 GFM 的规范以及中文的特殊情况，决定：\n\n- 中文翻译统一使用星号来标注加粗和斜体，而不是使用下划线，同时尊重英文版自身的用法。\n- 仍然不能正确渲染的地方，允许适当调整包含或不包含加粗或斜体部分两侧的标点符号。参见 [这个例子](https://github.com/vuejs/composition-api-rfc/pull/30/files)。\n- 仍然不能正确渲染的地方，手动使用 `<strong>` 或 `<em>` 标记。\n\n## 术语翻译参考\n\n| 英文 | 建议翻译 | 备注 |\n| --- | --- | --- |\n| property | 属性 | 组件的属性（数据、计算属性等） |\n| attribute | _不翻译_ | 特指 HTML 元素上的属性 |\n| getter | _一般不翻译_ | 计算属性中作计算函数 |\n| setter | _一般不翻译_ | 计算属性中作设置函数 |\n| prop | _不翻译_ | |\n| ref | _不翻译_ | |\n| feature/functionality | 功能 | |\n| directive | 指令 | |\n| mixin | 混入 | |\n| listen/listener | 监听/监听器 | |\n| observe/observer | 侦听/侦听器 | |\n| watch/watcher | 侦听/侦听器 | |\n| normalize (HTML code, ...) | 规范化 | |\n| standardize | 标准化 | |\n| fire/trigger (事件) | 触发 | |\n| emit (某个值或事件) | 抛出 | |\n| queue (v.) | 把……加入队列 | |\n| workaround (n.) | 变通办法 | |\n| workaround (v.) | 绕过 | |\n| convention | 约定 | |\n| parse | 解析 | |\n| stringify | 字符串化 | |\n| side effect | 副作用 | |\n| declarative | 声明式 | |\n| imperative | 命令式 | |\n| handler | 处理函数 | |\n| you | 你 (而不用 “您”) | |\n| computed | 计算属性 | |\n| computed property | 计算属性 | |\n| guard | 守卫 | |\n| hook | 钩子 | |\n| selector | 选择器 | |\n| truthy | 真值 | 需加 MDN 的解释作为译注 |\n| falsy | 假值 | 需加 MDN 的解释作为译注 |\n| mutate/mutation | 变更 | |\n| immutable | 不可变 | |\n| mutable | 可变 | |\n\n- MDN - `truthy` → https://developer.mozilla.org/en-US/docs/Glossary/Truthy\n- MDN - `falsy` → https://developer.mozilla.org/en-US/docs/Glossary/Falsy\n\n## 工作流\n\n### 更新内容同步策略\n\n此中文文档由 [印记中文](https://docschina.org/) 团队进行翻译，它们也是 Vite 官方中文文档背后的翻译维护团队。\n\n[QC-L](https://github.com/QC-L) 曾在 Vue 文档的讨论区提出过这套 [中英文档同步工作流](https://github.com/vuejs/docs-next-zh-cn/discussions/522#discussioncomment-779521)，这也是 Vite 官方中文文档正在使用的一套工作流。\n\n- 保留英文文档的原始 commit 记录，以保证可以对后续的更新进行再翻译、合并\n- 由于 Vue 文档以 Markdown 书写，每一行成一个自然段。因此在 Markdown 文档中原则上应该保证中英文行号一一对应，以保证后续更新时位置不发生错乱\n- 由机器人每日定时从英文文档仓库同步新的提交，并生成 Pull Request 交由翻译团队 Review、翻译并最终合入中文文档\n\n### 锚点链接的统一化\n\n:::tip 插件支持\n我们提供了一个包含此项功能的 [Vue 官方文档翻译助手插件](https://marketplace.visualstudio.com/items?itemName=shenqingchuan.vue-docs-tr-helper)，你可以在 VSCode 中安装，并遵照 README 的指引来使用。\n:::\n\n在 Markdown 文档中 `[title](link)` 形式的链接非常常用，而 Vue 文档中大量使用了这一语法，用来作章节的跳转。\n\n链接中有时还会带有锚点(以 `#` 作前缀)用来定位到页面的对应位置，例如 `[props 大小写格式](/guide/components/props.html#prop-name-casing)`。\n\n但是在 VitePress 中，由于锚点是对应 Markdown 内容中的 “标题行” 的，因此若改动了英文内容的标题行，别处引用此处的锚点就是失效了：\n\n```markdown\n<!-- 英文文档中该标题行为 -->\n\n## Props name casing\n\n<!-- 中文文档将标题翻译为 -->\n\n## Props 大小写格式\n\n<!-- 此时这个链接在页面上无法正常跳转 -->\n\n[props 大小写格式](/guide/components/props.html#prop-name-casing)\n```\n\n若将链接中的锚点也改为中文内容的确可以暂时解决问题，但若后续该标题有改动，又需要修改所有引用了该锚点的地方，可维护性较差。\n\n因此我们提供了一种特殊的锚点标记：\n\n```markdown\n<!-- 标记的内容就是原来的锚点 -->\n\n## Props 大小写格式 {#props-name-casing}\n```\n\n我们会为 VitePress 提供处理这个标记的逻辑，保证它不会在页面上显示出来。\n\n但也有需要注意的例外情况：若按上面的方式为一篇文章的所有标题行都生成了标记，但文章中出现了两个相同的标记，比如 “类和 CSS 样式” 章节中的 “绑定对象” 小节，可以为其加上数字标记，保证其在文章中的唯一性。\n\n此外，由于文章的总标题也被加上了锚点标记，导致在开发环境下，浏览器的标签页上会看到标记。但在构建发布时，我们运行了一个脚本，为文档的 frontmatter 中添加了不含标记的 `title`，因此读者将不会看到该标记。\n\n</details>\n\n<!-- zhlint disabled -->\n\n\n\n================================================\nFILE: src/about/team/Member.ts\n================================================\nexport interface Member {\n  name: string\n  avatarPic?: string\n  title: string\n  company?: string\n  companyLink?: string\n  projects: Link[]\n  location: string | string[]\n  languages: string[]\n  website?: Link\n  socials: Socials\n  sponsor?: boolean | string\n  reposPersonal?: string[]\n}\n\nexport interface Link {\n  label: string\n  url: string\n}\n\nexport interface Socials {\n  github: string\n  twitter?: string\n  linkedin?: string\n  codepen?: string\n}\n\n\n\n================================================\nFILE: src/about/team/members-core.json\n================================================\n[\n  {\n    \"name\": \"Evan You\",\n    \"title\": \"Creator\",\n    \"company\": \"Vue.js\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs/*\",\n        \"url\": \"https://www.github.com/vuejs\"\n      },\n      {\n        \"label\": \"vitejs/*\",\n        \"url\": \"https://www.github.com/vitejs\"\n      }\n    ],\n    \"location\": \"Singapore\",\n    \"languages\": [\"English\", \"Chinese\"],\n    \"website\": {\n      \"label\": \"evanyou.me\",\n      \"url\": \"https://evanyou.me\"\n    },\n    \"socials\": {\n      \"github\": \"yyx990803\",\n      \"twitter\": \"youyuxi\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Ben Hong\",\n    \"title\": \"Staff Developer Experience Engineer\",\n    \"company\": \"Netlify\",\n    \"companyLink\": \"https://www.netlify.com/\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs/docs\",\n        \"url\": \"https://www.github.com/vuejs/docs\"\n      }\n    ],\n    \"location\": \"Washington, DC, USA\",\n    \"languages\": [\"Chinese\", \"English\"],\n    \"website\": {\n      \"label\": \"bencodezen.io\",\n      \"url\": \"https://www.bencodezen.io\"\n    },\n    \"socials\": {\n      \"github\": \"bencodezen\",\n      \"twitter\": \"bencodezen\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Eduardo\",\n    \"title\": \"Developer & Consultant\",\n    \"company\": \"Freelance\",\n    \"location\": \"Paris, France\",\n    \"languages\": [\"Spanish\", \"French\", \"English\"],\n    \"socials\": {\n      \"github\": \"posva\",\n      \"twitter\": \"posva\"\n    },\n    \"projects\": [\n      {\n        \"label\": \"vue-router\",\n        \"url\": \"https://github.com/vuejs/router\"\n      },\n      {\n        \"label\": \"pinia\",\n        \"url\": \"https://github.com/vuejs/pinia\"\n      },\n      {\n        \"label\": \"vuefire\",\n        \"url\": \"https://github.com/vuejs/vuefire\"\n      }\n    ],\n    \"website\": {\n      \"label\": \"esm.dev\",\n      \"url\": \"https://esm.dev\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Haoqun Jiang\",\n    \"title\": \"Developer\",\n    \"company\": \"Vue.js\",\n    \"projects\": [\n      {\n        \"label\": \"create-vue\",\n        \"url\": \"https://github.com/vuejs/create-vue\"\n      },\n      {\n        \"label\": \"vite\",\n        \"url\": \"https://github.com/vitejs/vite\"\n      },\n      {\n        \"label\": \"vue-cli\",\n        \"url\": \"https://github.com/vuejs/vue-cli\"\n      },\n      {\n        \"label\": \"vue-loader\",\n        \"url\": \"https://github.com/vuejs/vue-loader\"\n      }\n    ],\n    \"location\": \"Hangzhou, China\",\n    \"languages\": [\"Chinese\", \"English\"],\n    \"socials\": {\n      \"github\": \"sodatea\",\n      \"twitter\": \"haoqunjiang\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Jinjiang\",\n    \"title\": \"Developer\",\n    \"company\": \"Bit\",\n    \"companyLink\": \"https://bit.dev\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs-translations\",\n        \"url\": \"https://github.com/vuejs-translations\"\n      },\n      {\n        \"label\": \"cn.vuejs.org\",\n        \"url\": \"https://cn.vuejs.org\"\n      }\n    ],\n    \"location\": \"Singapore\",\n    \"languages\": [\"Chinese\", \"English\"],\n    \"website\": {\n      \"label\": \"jinjiang.me\",\n      \"url\": \"http://jinjiang.me\"\n    },\n    \"socials\": {\n      \"github\": \"jinjiang\",\n      \"twitter\": \"zhaojinjiang\"\n    }\n  },\n  {\n    \"name\": \"Kazupon\",\n    \"title\": \"Engineer & Part-time Open Sourceror\",\n    \"company\": \"PLAID, Inc.\",\n    \"companyLink\": \"https://plaid.co.jp\",\n    \"projects\": [\n      {\n        \"label\": \"vue-i18n\",\n        \"url\": \"https://github.com/kazupon/vue-i18n\"\n      },\n      {\n        \"label\": \"Intlify\",\n        \"url\": \"https://intlify.dev/\"\n      },\n      {\n        \"label\": \"Vue.js Japan User Group\",\n        \"url\": \"https://vuejs-jp.org/en\"\n      },\n      {\n        \"label\": \"jp.vuejs.org\",\n        \"url\": \"https://jp.vuejs.org\"\n      }\n    ],\n    \"location\": \"Tokyo, Japan\",\n    \"languages\": [\"Japanese\", \"English\"],\n    \"website\": {\n      \"label\": \"patreon.com/kazupon\",\n      \"url\": \"https://www.patreon.com/kazupon\"\n    },\n    \"socials\": {\n      \"github\": \"kazupon\",\n      \"twitter\": \"kazu_pon\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Linusborg\",\n    \"title\": \"Hive-Mind Community Wrangler (Probably a Bot)\",\n    \"location\": \"Mannheim, Germany\",\n    \"languages\": [\"German\", \"English\"],\n    \"projects\": [\n      {\n        \"label\": \"vuejs/*\",\n        \"url\": \"https://github.com/vuejs\"\n      },\n      {\n        \"label\": \"portal-vue*\",\n        \"url\": \"https://github.com/LinusBorg/portal-vue\"\n      }\n    ],\n    \"reposPersonal\": [\"portal-vue\"],\n    \"website\": {\n      \"label\": \"https://forum.vuejs.org/\",\n      \"url\": \"https://forum.vuejs.org/\"\n    },\n    \"socials\": {\n      \"github\": \"LinusBorg\",\n      \"twitter\": \"Linus_Borg\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Guillaume Chau\",\n    \"title\": \"Frontend Developer\",\n    \"company\": \"Livestorm\",\n    \"companyLink\": \"https://livestorm.co/\",\n    \"projects\": [\n      {\n        \"label\": \"vue-devtools\",\n        \"url\": \"https://github.com/vuejs/devtools\"\n      },\n      {\n        \"label\": \"vue-cli\",\n        \"url\": \"https://github.com/vuejs/vue-cli\"\n      },\n      {\n        \"label\": \"vue-curated\",\n        \"url\": \"https://github.com/vuejs/awesome-vue\"\n      },\n      {\n        \"label\": \"vue-apollo\",\n        \"url\": \"https://github.com/Akyrum/vue-apollo\"\n      },\n      {\n        \"label\": \"vue-meteor\",\n        \"url\": \"https://github.com/Akyrum/vue-meteor\"\n      },\n      {\n        \"label\": \"vue-virtual-scroller\",\n        \"url\": \"https://github.com/Akyrum/vue-virtual-scroller\"\n      },\n      {\n        \"label\": \"v-tooltip\",\n        \"url\": \"https://github.com/Akyrum/v-tooltip\"\n      }\n    ],\n    \"location\": \"Bordeaux, France\",\n    \"languages\": [\"French\", \"English\"],\n    \"website\": {\n      \"label\": \"guillaume-chau.info\",\n      \"url\": \"https://guillaume-chau.info/\"\n    },\n    \"socials\": {\n      \"github\": \"Akryum\",\n      \"twitter\": \"Akryum\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"GU Yiling\",\n    \"title\": \"Staff Software Engineer\",\n    \"company\": \"Kong Inc.\",\n    \"companyLink\": \"https://konghq.com/\",\n    \"projects\": [\n      {\n        \"label\": \"vue\",\n        \"url\": \"https://www.github.com/vuejs/vue\"\n      },\n      {\n        \"label\": \"cn.vuejs.org\",\n        \"url\": \"https://cn.vuejs.org\"\n      },\n      {\n        \"label\": \"vue-echarts\",\n        \"url\": \"https://github.com/ecomfe/vue-echarts\"\n      },\n      {\n        \"label\": \"veui\",\n        \"url\": \"https://github.com/ecomfe/veui\"\n      }\n    ],\n    \"location\": \"Shanghai, China\",\n    \"languages\": [\"Chinese\", \"English\"],\n    \"socials\": {\n      \"github\": \"Justineo\",\n      \"twitter\": \"_justineo\"\n    }\n  },\n  {\n    \"name\": \"Phan An\",\n    \"title\": \"Engineering Team Lead\",\n    \"company\": \"InterNations\",\n    \"companyLink\": \"https://www.internations.org/\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs.org\",\n        \"url\": \"https://www.vuejs.org\"\n      },\n      {\n        \"label\": \"vuequery\",\n        \"url\": \"https://github.com/phanan/vuequery\"\n      },\n      {\n        \"label\": \"vue-google-signin-button\",\n        \"url\": \"https://github.com/vue-google-signin-button\"\n      }\n    ],\n    \"location\": \"Munich, Germany\",\n    \"languages\": [\"Vietnamese\", \"English\"],\n    \"socials\": { \"github\": \"phanan\", \"twitter\": \"notphanan\" },\n    \"website\": {\n      \"label\": \"https://phanan.net/\",\n      \"url\": \"https://phanan.net/\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Natalia Tepluhina\",\n    \"title\": \"Principal Engineer\",\n    \"company\": \"GitLab\",\n    \"companyLink\": \"https://gitlab.com/\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs/docs\",\n        \"url\": \"https://github.com/vuejs/docs\"\n      },\n      { \"label\": \"vue-cli\", \"url\": \"https://github.com/vuejs/vue-cli\" }\n    ],\n    \"location\": \"Amsterdam, Netherlands\",\n    \"languages\": [\"Ukrainian\", \"Russian\", \"English\"],\n    \"socials\": {\n      \"github\": \"NataliaTepluhina\",\n      \"twitter\": \"N_Tepluhina\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Yosuke Ota\",\n    \"title\": \"Lead Web Engineer\",\n    \"company\": \"Future Corporation\",\n    \"companyLink\": \"https://www.future.co.jp/\",\n    \"projects\": [\n      {\n        \"label\": \"eslint-plugin-vue\",\n        \"url\": \"https://github.com/vuejs/eslint-plugin-vue\"\n      },\n      {\n        \"label\": \"@intlify/eslint-plugin-vue-i18n\",\n        \"url\": \"https://github.com/intlify/eslint-plugin-vue-i18n\"\n      },\n      {\n        \"label\": \"eslint-plugin-vue-scoped-css\",\n        \"url\": \"https://github.com/future-architect/eslint-plugin-vue-scoped-css\"\n      }\n    ],\n    \"location\": \"Kanagawa, Japan\",\n    \"languages\": [\"Japanese\"],\n    \"socials\": {\n      \"github\": \"ota-meshi\",\n      \"twitter\": \"omoteota\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Kia King Ishii\",\n    \"title\": \"Director\",\n    \"company\": \"Global Brain\",\n    \"companyLink\": \"https://globalbrains.com/\",\n    \"projects\": [\n      {\n        \"label\": \"vuex\",\n        \"url\": \"https://github.com/vuejs/vuex\"\n      },\n      {\n        \"label\": \"vuex-orm\",\n        \"url\": \"https://github.com/vuex-orm\"\n      }\n    ],\n    \"location\": \"Kanagawa, Japan\",\n    \"languages\": [\"English\", \"Japanese\"],\n    \"socials\": {\n      \"github\": \"kiaking\",\n      \"twitter\": \"KiaKing85\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Anthony Fu\",\n    \"title\": \"Open Sourceror\",\n    \"company\": \"NuxtLabs\",\n    \"companyLink\": \"https://nuxtlabs.com/\",\n    \"projects\": [\n      {\n        \"label\": \"VueUse\",\n        \"url\": \"https://github.com/vueuse/vueuse\"\n      },\n      {\n        \"label\": \"Vitesse\",\n        \"url\": \"https://github.com/antfu/vitesse\"\n      },\n      {\n        \"label\": \"vue-demi\",\n        \"url\": \"https://github.com/vueuse/vue-demi\"\n      }\n    ],\n    \"location\": \"Paris, France\",\n    \"languages\": [\"Chinese\", \"English\"],\n    \"socials\": {\n      \"github\": \"antfu\",\n      \"twitter\": \"antfu7\"\n    },\n    \"website\": {\n      \"label\": \"https://antfu.me/\",\n      \"url\": \"https://antfu.me/\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Johnson Chu\",\n    \"title\": \"Developer\",\n    \"projects\": [\n      {\n        \"label\": \"@vue/language-tools\",\n        \"url\": \"https://github.com/vuejs/language-tools\"\n      },\n      {\n        \"label\": \"Volar.js\",\n        \"url\": \"https://github.com/volarjs\"\n      }\n    ],\n    \"location\": \"Hong Kong, China\",\n    \"languages\": [\"Chinese\", \"English\"],\n    \"socials\": {\n      \"github\": \"johnsoncodehk\",\n      \"twitter\": \"johnsoncodehk\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Carlos Rodrigues\",\n    \"title\": \"Developer & Consultant\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs/core\",\n        \"url\": \"https://github.com/vuejs/core\"\n      }\n    ],\n    \"location\": \"London, United Kingdom\",\n    \"languages\": [\"English\", \"Portuguese\"],\n    \"socials\": {\n      \"github\": \"pikax\",\n      \"twitter\": \"pikax_dev\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Divyansh Singh\",\n    \"title\": \"Developer\",\n    \"projects\": [\n      {\n        \"label\": \"vitepress\",\n        \"url\": \"https://github.com/vuejs/vitepress\"\n      }\n    ],\n    \"location\": \"India\",\n    \"languages\": [\"English\", \"Hindi\"],\n    \"socials\": {\n      \"github\": \"brc-dd\",\n      \"twitter\": \"_brc_dd\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"Kevin Deng 三咲智子\",\n    \"title\": \"Open Sourceror\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs/core\",\n        \"url\": \"https://github.com/vuejs/core\"\n      },\n      {\n        \"label\": \"vuejs/core-vapor\",\n        \"url\": \"https://github.com/vuejs/core-vapor\"\n      },\n      {\n        \"label\": \"Vue Macros\",\n        \"url\": \"https://github.com/vue-macros/vue-macros\"\n      },\n      {\n        \"label\": \"VueUse\",\n        \"url\": \"https://github.com/vueuse/vueuse\"\n      }\n    ],\n    \"location\": [\"Hangzhou\", \"Singapore\"],\n    \"languages\": [\"English\", \"Chinese\"],\n    \"socials\": {\n      \"github\": \"sxzz\",\n      \"twitter\": \"sanxiaozhizi\"\n    },\n    \"sponsor\": true\n  }\n]\n\n\n\n================================================\nFILE: src/about/team/members-emeriti.json\n================================================\n[\n  {\n    \"name\": \"Sarah Drasner\",\n    \"title\": \"Director of Engineering, Core Developer Web\",\n    \"company\": \"Google\",\n    \"companyLink\": \"https://google.com\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs.org\",\n        \"url\": \"https://github.com/vuejs/vuejs.org\"\n      },\n      {\n        \"label\": \"vue-vscode-snippets\",\n        \"url\": \"https://github.com/sdras/vue-vscode-snippets\"\n      },\n      {\n        \"label\": \"intro-to-vue\",\n        \"url\": \"https://github.com/sdras/intro-to-vue\"\n      },\n      {\n        \"label\": \"vue-vscode-extensionpack\",\n        \"url\": \"https://github.com/sdras/vue-vscode-extensionpack\"\n      },\n      {\n        \"label\": \"ecommerce-netlify\",\n        \"url\": \"https://github.com/sdras/ecommerce-netlify\"\n      }\n    ],\n    \"location\": \"Denver, CO, USA\",\n    \"languages\": [\"English\"],\n    \"website\": {\n      \"label\": \"sarah.dev\",\n      \"url\": \"https://sarah.dev/\"\n    },\n    \"socials\": {\n      \"github\": \"sdras\",\n      \"twitter\": \"sarah_edo\",\n      \"codepen\": \"sdras\"\n    }\n  },\n  {\n    \"name\": \"Chris Fritz\",\n    \"title\": \"Educator & Consultant\",\n    \"location\": \"Durham, NC, USA\",\n    \"languages\": [\"English\", \"German\"],\n    \"socials\": {\n      \"github\": \"chrisvfritz\",\n      \"twitter\": \"chrisvfritz\"\n    },\n    \"reposPersonal\": [\"vue-enterprise-boilerplate\"]\n  },\n  {\n    \"name\": \"Blake Newman\",\n    \"title\": \"Performance Specializer & Code Deleter\",\n    \"location\": \"London, UK\",\n    \"languages\": [\"English\"],\n    \"socials\": {\n      \"github\": \"blake-newman\",\n      \"twitter\": \"blakenewman\"\n    }\n  },\n  {\n    \"name\": \"kingwl\",\n    \"title\": \"Software Development Engineer\",\n    \"company\": \"Chaitin\",\n    \"companyLink\": \"https://chaitin.cn/\",\n    \"projects\": [\n      {\n        \"label\": \"vue\",\n        \"url\": \"https://github.com/vuejs/vue\"\n      }\n    ],\n    \"location\": \"Beijing, China\",\n    \"languages\": [\"Chinese\"],\n    \"socials\": {\n      \"github\": \"kingwl\"\n    }\n  },\n  {\n    \"name\": \"Alan Song\",\n    \"title\": \"Cofounder\",\n    \"company\": \"Futurenda\",\n    \"companyLink\": \"https://www.futurenda.com/\",\n    \"projects\": [\n      {\n        \"label\": \"vue-router\",\n        \"url\": \"https://github.com/vuejs/vue-router\"\n      }\n    ],\n    \"location\": \"Hangzhou, China\",\n    \"languages\": [\"Chinese\", \"English\"],\n    \"socials\": {\n      \"github\": \"fnlctrl\"\n    }\n  },\n  {\n    \"name\": \"defcc\",\n    \"title\": \"Details Deity & Bug Surgeon\",\n    \"company\": \"Indie Developer\",\n    \"companyLink\": \"https://indiefollow.top/\",\n    \"location\": \"Chongqing, China\",\n    \"languages\": [\"Chinese\", \"English\"],\n    \"socials\": {\n      \"github\": \"defcc\"\n    }\n  },\n  {\n    \"name\": \"gebilaoxiong\",\n    \"title\": \"Issue Annihilator\",\n    \"company\": \"zbj.com\",\n    \"companyLink\": \"http://www.zbj.com/\",\n    \"location\": \"Chongqing, China\",\n    \"languages\": [\"Chinese\", \"English\"],\n    \"socials\": {\n      \"github\": \"gebilaoxiong\"\n    }\n  },\n  {\n    \"name\": \"Denis Karabaza\",\n    \"title\": \"Software Engineer\",\n    \"company\": \"Neolant\",\n    \"companyLink\": \"http://neolant.ru/\",\n    \"location\": \"Dubna, Russia\",\n    \"languages\": [\"Russian\", \"English\"],\n    \"socials\": {\n      \"github\": \"simplesmiler\",\n      \"twitter\": \"simplesmiler\"\n    }\n  },\n  {\n    \"name\": \"Edd Yerburgh\",\n    \"title\": \"Full Stack Developer\",\n    \"projects\": [\n      {\n        \"label\": \"vue-test-utils\",\n        \"url\": \"https://github.com/vuejs/vue-test-utils\"\n      },\n      {\n        \"label\": \"avoriaz\",\n        \"url\": \"https://github.com/avoriaz\"\n      }\n    ],\n    \"location\": \"London, UK\",\n    \"languages\": [\"English\"],\n    \"socials\": {\n      \"github\": \"eddyerburgh\",\n      \"twitter\": \"EddYerburgh\"\n    },\n    \"website\": {\n      \"label\": \"www.eddyerburgh.me\",\n      \"url\": \"https://www.eddyerburgh.me\"\n    }\n  },\n  {\n    \"name\": \"Pine Wu\",\n    \"title\": \"Nomad\",\n    \"projects\": [\n      {\n        \"label\": \"vetur\",\n        \"url\": \"https://github.com/vuejs/vetur\"\n      }\n    ],\n    \"location\": \"Shanghai, China\",\n    \"languages\": [\"Chinese\", \"English\", \"Japanese\"],\n    \"socials\": {\n      \"github\": \"octref\",\n      \"twitter\": \"octref\"\n    }\n  },\n  {\n    \"name\": \"ULIVZ\",\n    \"title\": \"Senior Frontend Developer\",\n    \"company\": \"AntFinancial\",\n    \"companyLink\": \"https://www.antfin.com\",\n    \"projects\": [\n      {\n        \"label\": \"vuepress\",\n        \"url\": \"https://www.github.com/vuejs/vuepress\"\n      }\n    ],\n    \"location\": \"Hangzhou, China\",\n    \"languages\": [\"Chinese\", \"English\"],\n    \"socials\": { \"github\": \"ulivz\", \"twitter\": \"_ulivz\" }\n  },\n  {\n    \"name\": \"Katashin\",\n    \"title\": \"Software Engineer\",\n    \"company\": \"ClassDo\",\n    \"companyLink\": \"https://classdo.com\",\n    \"projects\": [\n      {\n        \"label\": \"vuex\",\n        \"url\": \"https://github.com/vuejs/vuex\"\n      },\n      {\n        \"label\": \"vue-class-component\",\n        \"url\": \"https://github.com/vuejs/vue-class-component\"\n      },\n      {\n        \"label\": \"vue-designer\",\n        \"url\": \"https://github.com/ktsn/vue-designer\"\n      }\n    ],\n    \"location\": \"Singapore\",\n    \"languages\": [\"Japanese\", \"English\"],\n    \"socials\": {\n      \"github\": \"ktsn\",\n      \"twitter\": \"ktsn\"\n    }\n  },\n  {\n    \"name\": \"Michał Sajnóg\",\n    \"title\": \"Senior Frontend Developer / Team Leader\",\n    \"company\": \"Netguru\",\n    \"companyLink\": \"https://netguru.co/\",\n    \"location\": \"Poznań, Poland\",\n    \"languages\": [\"Polish\", \"English\"],\n    \"projects\": [\n      {\n        \"label\": \"eslint-plugin-vue\",\n        \"url\": \"https://github.com/vuejs/eslint-plugin-vue\"\n      },\n      {\n        \"label\": \"vue-devtools\",\n        \"url\": \"https://github.com/vuejs/devtools\"\n      },\n      {\n        \"label\": \"vue-computed-helpers\",\n        \"url\": \"https://github.com/michalsnik/vue-computed-helpers\"\n      },\n      {\n        \"label\": \"vue-content-placeholders\",\n        \"url\": \"https://github.com/michalsnik/vue-content-placeholders\"\n      }\n    ],\n    \"socials\": {\n      \"github\": \"michalsnik\",\n      \"twitter\": \"michalsnik\"\n    }\n  },\n  {\n    \"name\": \"Damian Dulisz\",\n    \"title\": \"Consultant\",\n    \"projects\": [\n      {\n        \"label\": \"news.vuejs.org\",\n        \"url\": \"https://news.vuejs.org\"\n      },\n      {\n        \"label\": \"vue-multiselect\",\n        \"url\": \"https://vue-multiselect.js.org/\"\n      }\n    ],\n    \"location\": \"Wrocław, Poland\",\n    \"languages\": [\"Polish\", \"English\"],\n    \"socials\": {\n      \"github\": \"shentao\",\n      \"twitter\": \"DamianDulisz\"\n    },\n    \"sponsor\": true\n  },\n  {\n    \"name\": \"HcySunYang\",\n    \"title\": \"Developer\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs/core\",\n        \"url\": \"https://github.com/vuejs/core\"\n      }\n    ],\n    \"location\": \"Beijing, China\",\n    \"languages\": [\"Chinese\", \"English\"],\n    \"socials\": {\n      \"github\": \"HcySunYang\",\n      \"twitter\": \"HcySunYang\"\n    }\n  },\n  {\n    \"name\": \"Rahul Kadyan\",\n    \"title\": \"Software Engineer\",\n    \"company\": \"Grammarly\",\n    \"companyLink\": \"https://grammarly.com/\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs/core\",\n        \"url\": \"https://github.com/vuejs/core\"\n      },\n      { \"label\": \"VueDX\", \"url\": \"https://github.com/vuedx\" },\n      {\n        \"label\": \"rollup-plugin-vue\",\n        \"url\": \"https://github.com/vuejs/rollup-plugin-vue\"\n      }\n    ],\n    \"location\": \"Bangalore, India\",\n    \"languages\": [\"Hindi\", \"English\"],\n    \"socials\": {\n      \"github\": \"znck\",\n      \"twitter\": \"znck0\"\n    },\n    \"website\": {\n      \"label\": \"https://znck.me\",\n      \"url\": \"https://znck.me\"\n    },\n    \"sponsor\": true\n  }\n]\n\n\n\n================================================\nFILE: src/about/team/members-partner.json\n================================================\n[\n  {\n    \"name\": \"Maria Lamardo\",\n    \"title\": \"Front End Engineer\",\n    \"company\": \"Pendo\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs/events\",\n        \"url\": \"https://github.com/vuejs/events\"\n      }\n    ],\n    \"location\": \"Raleigh, NC, USA\",\n    \"languages\": [\"English\", \"Spanish\"],\n    \"socials\": {\n      \"github\": \"mlama007\",\n      \"twitter\": \"MariaLamardo\"\n    }\n  },\n  {\n    \"name\": \"Daniel Roe\",\n    \"title\": \"Framework Architect\",\n    \"company\": \"Nuxt\",\n    \"projects\": [\n      {\n        \"label\": \"nuxt\",\n        \"url\": \"https://github.com/nuxt\"\n      },\n      {\n        \"label\": \"typed-vuex\",\n        \"url\": \"https://github.com/danielroe/typed-vuex\"\n      }\n    ],\n    \"location\": \"United Kingdom\",\n    \"languages\": [\"English\"],\n    \"socials\": {\n      \"github\": \"danielroe\",\n      \"twitter\": \"danielcroe\",\n      \"linkedin\": \"daniel-roe\"\n    }\n  },\n  {\n    \"name\": \"Pratik Patel\",\n    \"avatarPic\": \"https://pbs.twimg.com/profile_images/1541624512/profile-pic-09-11-2011_400x400.png\",\n    \"title\": \"Organizer\",\n    \"company\": \"VueConf US\",\n    \"projects\": [\n      {\n        \"label\": \"us.vuejs.org\",\n        \"url\": \"https://us.vuejs.org/\"\n      }\n    ],\n    \"location\": \"Atlanta, GA, USA\",\n    \"languages\": [\"English\"],\n    \"socials\": {\n      \"twitter\": \"prpatel\"\n    }\n  },\n  {\n    \"name\": \"Vincent Mayers\",\n    \"avatarPic\": \"https://pbs.twimg.com/profile_images/1618755757184253954/YvKB816o_400x400.jpg\",\n    \"title\": \"Organizer\",\n    \"company\": \"VueConf US\",\n    \"projects\": [\n      {\n        \"label\": \"us.vuejs.org\",\n        \"url\": \"https://us.vuejs.org/\"\n      }\n    ],\n    \"location\": \"Atlanta, GA, USA\",\n    \"languages\": [\"English\"],\n    \"socials\": {\n      \"twitter\": \"vincentmayers\"\n    }\n  },\n  {\n    \"name\": \"Luke Thomas\",\n    \"avatarPic\": \"https://pbs.twimg.com/profile_images/1123492769299877888/aviXE_M5_400x400.jpg\",\n    \"title\": \"Creator\",\n    \"company\": \"Vue.js Amsterdam\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs.amsterdam\",\n        \"url\": \"https://vuejs.amsterdam\"\n      }\n    ],\n    \"location\": \"Amsterdam, Netherlands\",\n    \"languages\": [\"Dutch\", \"English\", \"German\"],\n    \"socials\": {\n      \"twitter\": \"lukevscostas\",\n      \"linkedin\": \"luke-kenneth-thomas-578b3916a\"\n    }\n  },\n  {\n    \"name\": \"Jos Gerards\",\n    \"avatarPic\": \"https://pbs.twimg.com/profile_images/1668258954831446031/RTVopxrO_400x400.jpg\",\n    \"title\": \"Event Manager\",\n    \"company\": \"Vue.js Amsterdam\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs.amsterdam\",\n        \"url\": \"https://vuejs.amsterdam\"\n      }\n    ],\n    \"location\": \"Amsterdam, Netherlands\",\n    \"languages\": [\"Dutch\", \"English\", \"German\"],\n    \"socials\": {\n      \"twitter\": \"josgerards88\",\n      \"linkedin\": \"josgerards\"\n    }\n  },\n  {\n    \"name\": \"Jen Looper\",\n    \"title\": \"CEO\",\n    \"company\": \"Vue Vixens\",\n    \"projects\": [\n      {\n        \"label\": \"vuevixens.org\",\n        \"url\": \"https://vuevixens.org/\"\n      },\n      {\n        \"label\": \"nativescript-vue.org\",\n        \"url\": \"https://nativescript-vue.org/\"\n      }\n    ],\n    \"location\": \"Boston, MA, USA\",\n    \"languages\": [\"English\", \"French\"],\n    \"socials\": {\n      \"github\": \"jlooper\",\n      \"twitter\": \"jenlooper\"\n    }\n  },\n  {\n    \"name\": \"Alex Jover\",\n    \"title\": \"Web, PWA and Performance Consultant\",\n    \"company\": \"Freelance\",\n    \"projects\": [\n      {\n        \"label\": \"v-runtime-template\",\n        \"url\": \"https://github.com/alexjoverm/v-runtime-template\"\n      },\n      {\n        \"label\": \"v-lazy-image\",\n        \"url\": \"https://github.com/alexjoverm/v-lazy-image\"\n      },\n      {\n        \"label\": \"vue-testing-series\",\n        \"url\": \"https://github.com/alexjoverm/vue-testing-series\"\n      }\n    ],\n    \"location\": \"Alicante, Spain\",\n    \"languages\": [\"Spanish\", \"English\"],\n    \"website\": {\n      \"label\": \"alexjover.com\",\n      \"url\": \"https://alexjover.com\"\n    },\n    \"socials\": {\n      \"github\": \"alexjoverm\",\n      \"twitter\": \"alexjoverm\"\n    }\n  },\n  {\n    \"name\": \"Sebastien Chopin\",\n    \"title\": \"#1 Nuxt Brother\",\n    \"company\": \"NuxtLabs\",\n    \"companyLink\": \"https://nuxtlabs.com\",\n    \"location\": \"Bordeaux, France\",\n    \"languages\": [\"French\", \"English\"],\n    \"projects\": [\n      {\n        \"label\": \"nuxt/*\",\n        \"url\": \"https://github.com/nuxt\"\n      },\n      {\n        \"label\": \"nuxt-modules/*\",\n        \"url\": \"https://github.com/nuxt-modules\"\n      },\n      {\n        \"label\": \"nuxt-themes/*\",\n        \"url\": \"https://github.com/nuxt-themes\"\n      }\n    ],\n    \"socials\": {\n      \"github\": \"Atinux\",\n      \"twitter\": \"Atinux\"\n    }\n  },\n  {\n    \"name\": \"Alexandre Chopin\",\n    \"title\": \"#1 Nuxt Brother\",\n    \"company\": \"NuxtLabs\",\n    \"companyLink\": \"https://nuxtlabs.com\",\n    \"location\": \"Bordeaux, France\",\n    \"languages\": [\"French\", \"English\"],\n    \"projects\": [\n      {\n        \"label\": \"nuxt/*\",\n        \"url\": \"https://github.com/nuxt\"\n      },\n      {\n        \"label\": \"nuxt-modules/*\",\n        \"url\": \"https://github.com/nuxt-modules\"\n      }\n    ],\n    \"socials\": {\n      \"github\": \"alexchopin\",\n      \"twitter\": \"iamnuxt\"\n    }\n  },\n  {\n    \"name\": \"Khary Sharpe\",\n    \"title\": \"Viral Newscaster\",\n    \"location\": \"Kingston, Jamaica\",\n    \"languages\": [\"English\"],\n    \"projects\": [\n      {\n        \"label\": \"VueJsNews\",\n        \"url\": \"https://twitter.com/VueJsNews\"\n      }\n    ],\n    \"website\": {\n      \"label\": \"www.kharysharpe.com\",\n      \"url\": \"http://www.kharysharpe.com/\"\n    },\n    \"socials\": {\n      \"github\": \"kharysharpe\",\n      \"twitter\": \"kharysharpe\"\n    }\n  },\n  {\n    \"name\": \"Pooya Parsa\",\n    \"title\": \"Technical Advisor\",\n    \"company\": \"Fandogh (AUT University)\",\n    \"companyLink\": \"https://fandogh.org\",\n    \"location\": \"Tehran, Iran\",\n    \"languages\": [\"Persian\", \"English\"],\n    \"projects\": [\n      {\n        \"label\": \"nuxt/*\",\n        \"url\": \"https://github.com/nuxt\"\n      },\n      {\n        \"label\": \"nuxt-community/*\",\n        \"url\": \"https://github.com/nuxt-community\"\n      },\n      {\n        \"label\": \"bootstrap-vue/*\",\n        \"url\": \"https://github.com/bootstrap-vue\"\n      }\n    ],\n    \"socials\": {\n      \"github\": \"pi0\",\n      \"twitter\": \"_pi0_\"\n    }\n  },\n  {\n    \"name\": \"Xin Du\",\n    \"title\": \"Nuxpert\",\n    \"location\": \"Dublin, Ireland\",\n    \"languages\": [\"Chinese\", \"English\"],\n    \"projects\": [\n      {\n        \"label\": \"nuxt/*\",\n        \"url\": \"https://github.com/nuxt\"\n      },\n      {\n        \"label\": \"nuxt-community/*\",\n        \"url\": \"https://github.com/nuxt-community\"\n      }\n    ],\n    \"socials\": {\n      \"github\": \"clarkdo\",\n      \"twitter\": \"ClarkDu_\"\n    }\n  },\n  {\n    \"name\": \"Yi Yang\",\n    \"title\": \"Interface Elementologist\",\n    \"company\": \"ele.me\",\n    \"companyLink\": \"https://www.ele.me\",\n    \"location\": \"Shanghai, China\",\n    \"languages\": [\"Chinese\", \"English\"],\n    \"projects\": [\n      {\n        \"label\": \"elemefe/element\",\n        \"url\": \"https://github.com/elemefe/element\"\n      },\n      {\n        \"label\": \"elemefe/mint-ui\",\n        \"url\": \"https://github.com/elemefe/mint-ui\"\n      }\n    ],\n    \"socials\": {\n      \"github\": \"Leopoldthecoder\"\n    }\n  },\n  {\n    \"name\": \"Bruno Lesieur\",\n    \"title\": \"Cofounder\",\n    \"company\": \"Orchard ID\",\n    \"companyLink\": \"https://www.orchard-id.com/\",\n    \"projects\": [\n      {\n        \"label\": \"vuejs-fr/*\",\n        \"url\": \"https://vuejs-fr\"\n      },\n      {\n        \"label\": \"vuejs-fr/*\",\n        \"url\": \"https://Haeresis/node-atlas-hello-vue\"\n      },\n      {\n        \"label\": \"https://node-atlas.js.org/\",\n        \"url\": \"https://node-atlas.js.org/\"\n      }\n    ],\n    \"location\": \"Annecy, France\",\n    \"languages\": [\"French\", \"English\"],\n    \"website\": {\n      \"label\": \"blog.lesieur.name/\",\n      \"url\": \"https://blog.lesieur.name/\"\n    },\n    \"socials\": {\n      \"github\": \"Haeresis\",\n      \"twitter\": \"ZetesEthique\"\n    }\n  },\n  {\n    \"name\": \"ChangJoo Park\",\n    \"title\": \"Vuenthusiastic Korean Community Organizer\",\n    \"location\": \"Seoul, South Korea\",\n    \"languages\": [\"Korean\", \"English\"],\n    \"projects\": [\n      {\n        \"label\": \"vuejs-kr/kr.vuejs.org\",\n        \"url\": \"https://github.com/vuejs-kr/kr.vuejs.org\"\n      },\n      {\n        \"label\": \"ChangJoo-Park/vue-component-generator\",\n        \"url\": \"https://github.com/ChangJoo-Park/vue-component-generator\"\n      },\n      {\n        \"label\": \"vuejs-kr.github.io\",\n        \"url\": \"https://vuejs-kr.github.io\"\n      }\n    ],\n    \"socials\": {\n      \"github\": \"changjoo-park\",\n      \"twitter\": \"pcjpcj2\"\n    }\n  },\n  {\n    \"name\": \"Erick Petrucelli\",\n    \"title\": \"Lead Software Engineer, UI/UX Specialist, Manager, Teacher, Speaker, Writer\",\n    \"company\": \"LawnStarter\",\n    \"companyLink\": \"https://www.lawnstarter.com/\",\n    \"location\": \"Campinas, Brazil\",\n    \"languages\": [\"Portuguese\", \"English\"],\n    \"projects\": [\n      {\n        \"label\": \"vuejs-br\",\n        \"url\": \"https://github.com/vuejs-br\"\n      }\n    ],\n    \"socials\": {\n      \"github\": \"ErickPetru\",\n      \"linkedin\": \"erick-petrucelli\",\n      \"twitter\": \"erickpetru\"\n    }\n  },\n  {\n    \"name\": \"Razvan Stoenescu\",\n    \"title\": \"Deep Space Quasar Creator\",\n    \"company\": \"Quasar Framework\",\n    \"companyLink\": \"https://quasar.dev/\",\n    \"location\": \"Bucharest, Romania\",\n    \"languages\": [\"Romanian\", \"English\"],\n    \"projects\": [\n      {\n        \"label\": \"quasarframework/quasar\",\n        \"url\": \"https://github.com/quasarframework/quasar\"\n      },\n      {\n        \"label\": \"quasarframework\",\n        \"url\": \"https://github.com/quasarframework\"\n      }\n    ],\n    \"socials\": {\n      \"github\": \"rstoenescu\",\n      \"twitter\": \"quasarframework\"\n    }\n  },\n  {\n    \"name\": \"Jilson Thomas\",\n    \"title\": \"Senior Frontend Developer\",\n    \"company\": \"Nominator\",\n    \"companyLink\": \"https://nominator.com/\",\n    \"projects\": [\n      {\n        \"label\": \"vuejobs.com\",\n        \"url\": \"https://vuejobs.com\"\n      }\n    ],\n    \"location\": \"Toronto, Canada\",\n    \"languages\": [\"English\"],\n    \"socials\": {\n      \"github\": \"JillzTom\",\n      \"twitter\": \"jilsonthomas\"\n    }\n  },\n  {\n    \"name\": \"Israel Ortuño\",\n    \"title\": \"Full Stack Web Developer\",\n    \"company\": \"Freelance\",\n    \"projects\": [\n      {\n        \"label\": \"vuejobs.com\",\n        \"url\": \"https://vuejobs.com\"\n      }\n    ],\n    \"location\": \"Alicante, Spain\",\n    \"languages\": [\"Spanish\", \"English\"],\n    \"socials\": {\n      \"github\": \"IsraelOrtuno\",\n      \"twitter\": \"IsraelOrtuno\"\n    }\n  },\n  {\n    \"name\": \"John Leider\",\n    \"title\": \"CEO\",\n    \"company\": \"Vuetify LLC\",\n    \"companyLink\": \"https://vuetifyjs.com\",\n    \"location\": \"Fort Worth, TX, USA\",\n    \"languages\": [\"English\"],\n    \"projects\": [\n      {\n        \"label\": \"vuetifyjs/vuetify\",\n        \"url\": \"https://github.com/vuetifyjs/vuetify\"\n      }\n    ],\n    \"socials\": {\n      \"github\": \"vuetifyjs\",\n      \"twitter\": \"vuetifyjs\"\n    }\n  },\n  {\n    \"name\": \"Grigoriy Beziuk\",\n    \"title\": \"Full Stack Web Developer\",\n    \"company\": \"Self Employed\",\n    \"companyLink\": \"http://gbezyuk.ru\",\n    \"location\": \"Moscow, Russia\",\n    \"languages\": [\"Russian\", \"German\", \"English\"],\n    \"projects\": [\n      {\n        \"label\": \"translation-gang/ru.vuejs.org\",\n        \"url\": \"https://github.com/translation-gang/ru.vuejs.org\"\n      }\n    ],\n    \"socials\": {\n      \"github\": \"gbezyuk\"\n    }\n  },\n  {\n    \"name\": \"Alexander Sokolov\",\n    \"title\": \"Russian Translation Sharp Eye\",\n    \"location\": \"Krasnodar, Russia\",\n    \"languages\": [\"Russian\", \"English\"],\n    \"projects\": [\n      {\n        \"label\": \"translation-gang/ru.vuejs.org\",\n        \"url\": \"https://github.com/translation-gang/ru.vuejs.org\"\n      }\n    ],\n    \"socials\": { \"github\": \"Alex-Sokolov\" }\n  },\n  {\n    \"name\": \"Anthony Gore\",\n    \"title\": \"Author\",\n    \"company\": \"Vue.js Developers\",\n    \"companyLink\": \"https://vuejsdevelopers.com/\",\n    \"location\": \"Sydney, Australia\",\n    \"languages\": [\"English\"],\n    \"website\": {\n      \"label\": \"vuejsdevelopers.com\",\n      \"url\": \"https://vuejsdevelopers.com\"\n    },\n    \"socials\": { \"github\": \"anthonygore\", \"twitter\": \"anthonygore\" }\n  },\n  {\n    \"name\": \"EGOIST\",\n    \"title\": \"Build Tool Simplificator\",\n    \"location\": \"Chengdu, China\",\n    \"projects\": [\n      {\n        \"label\": \"poi\",\n        \"url\": \"https://github.com/egoist/poi\"\n      },\n      {\n        \"label\": \"ream\",\n        \"url\": \"https://github.com/egoist/ream\"\n      },\n      {\n        \"label\": \"vue-play\",\n        \"url\": \"https://github.com/egoist/vue-play\"\n      }\n    ],\n    \"languages\": [\"Chinese\", \"English\"],\n    \"socials\": { \"github\": \"egoist\", \"twitter\": \"_egoistlily\" }\n  },\n  {\n    \"name\": \"Alex Kyriakidis\",\n    \"title\": \"Consultant / Author\",\n    \"location\": \"Thessaloniki, Greece\",\n    \"languages\": [\"el\", \"English\"],\n    \"socials\": { \"github\": \"hootlex\", \"twitter\": \"hootlex\" },\n    \"projects\": [\n      {\n        \"label\": \"vuejs-paginator\",\n        \"url\": \"https://github.com/hootlex/vuejs-paginator\"\n      },\n      {\n        \"label\": \"vuedo/vuedo\",\n        \"url\": \"https://github.com/vuedo/vuedo\"\n      },\n      {\n        \"label\": \"the-majesty-of-vuejs-2\",\n        \"url\": \"https://github.com/hootlex/the-majesty-of-vuejs-2\"\n      },\n      {\n        \"label\": \"vuejsfeed.com\",\n        \"url\": \"https://vuejsfeed.com/\"\n      },\n      {\n        \"label\": \"vueschool.io\",\n        \"url\": \"https://vueschool.io/\"\n      }\n    ]\n  },\n  {\n    \"name\": \"Rolf Haug\",\n    \"title\": \"Educator & Consultant\",\n    \"company\": \"Vue School\",\n    \"companyLink\": \"https://vueschool.io/\",\n    \"location\": \"Oslo, Norway\",\n    \"languages\": [\"English\"],\n    \"projects\": [\n      {\n        \"label\": \"vueschool.io\",\n        \"url\": \"https://vueschool.io/\"\n      }\n    ],\n    \"website\": {\n      \"label\": \"rah.no\",\n      \"url\": \"https://rah.no\"\n    },\n    \"socials\": { \"github\": \"rahaug\", \"twitter\": \"rahaug\" }\n  },\n  {\n    \"name\": \"Andrew Tomaka\",\n    \"title\": \"The Server Server\",\n    \"company\": \"Michigan State University\",\n    \"companyLink\": \"https://msu.edu/\",\n    \"location\": \"East Lansing, MI, USA\",\n    \"languages\": [\"English\"],\n    \"projects\": [\n      {\n        \"label\": \"vuejs/*\",\n        \"url\": \"https://www.github.com/vuejs\"\n      }\n    ],\n    \"socials\": { \"github\": \"atomaka\", \"twitter\": \"atomaka\" },\n    \"website\": {\n      \"label\": \"atomaka.com\",\n      \"url\": \"https://atomaka.com/\"\n    }\n  },\n  {\n    \"name\": \"Blake Newman\",\n    \"title\": \"Software Engineer\",\n    \"company\": \"Attest\",\n    \"companyLink\": \"https://www.askattest.com/\",\n    \"location\": \"London, UK\",\n    \"languages\": [\"English\"],\n    \"projects\": [\n      {\n        \"label\": \"vuejs.london\",\n        \"url\": \"https://vuejs.london\"\n      }\n    ],\n    \"socials\": { \"github\": \"blake-newman\", \"twitter\": \"blakenewman\" }\n  },\n  {\n    \"name\": \"Filip Rakowski\",\n    \"title\": \"Co-founder of Vue Storefront\",\n    \"company\": \"Divante\",\n    \"companyLink\": \"https://divante.co/\",\n    \"location\": \"Wrocław, Poland\",\n    \"languages\": [\"Polish\", \"English\"],\n    \"projects\": [\n      {\n        \"label\": \"DivanteLtd/vue-storefront\",\n        \"url\": \"https://vuestorefront.io\"\n      },\n      {\n        \"label\": \"DivanteLtd/storefront-ui\",\n        \"url\": \"https://storefrontui.io\"\n      }\n    ],\n    \"socials\": { \"github\": \"filrak\", \"twitter\": \"filrakowski\" }\n  },\n  {\n    \"name\": \"Gregg Pollack\",\n    \"title\": \"Vue Instructor\",\n    \"company\": \"Vue Mastery\",\n    \"companyLink\": \"https://www.vuemastery.com/\",\n    \"location\": \"Orlando, FL, USA\",\n    \"languages\": [\"English\"],\n    \"projects\": [\n      {\n        \"label\": \"www.vuemastery.com\",\n        \"url\": \"https://www.vuemastery.com\"\n      },\n      {\n        \"label\": \"news.vuejs.org/\",\n        \"url\": \"https://news.vuejs.org/\"\n      }\n    ],\n    \"socials\": { \"github\": \"gregg\", \"twitter\": \"greggpollack\" }\n  },\n  {\n    \"name\": \"Adam Jahr\",\n    \"title\": \"Vue Instructor\",\n    \"company\": \"Vue Mastery\",\n    \"companyLink\": \"https://www.vuemastery.com/\",\n    \"location\": \"Orlando, FL, USA\",\n    \"languages\": [\"English\"],\n    \"projects\": [\n      {\n        \"label\": \"www.vuemastery.com\",\n        \"url\": \"https://www.vuemastery.com\"\n      },\n      {\n        \"label\": \"news.vuejs.org/\",\n        \"url\": \"https://news.vuejs.org/\"\n      }\n    ],\n    \"socials\": { \"github\": \"atomjar\", \"twitter\": \"adamjahr\" }\n  }\n]\n\n\n\n================================================\nFILE: src/about/team/TeamHero.vue\n================================================\n<template>\n  <div class=\"TeamHero\">\n    <div class=\"container\">\n      <h1 class=\"title\">\n        <slot name=\"title\" />\n      </h1>\n      <p class=\"lead\">\n        <slot name=\"lead\" />\n      </p>\n      <p class=\"action\">\n        <slot name=\"action\" />\n      </p>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.TeamHero {\n  padding: 48px 24px;\n}\n\n@media (min-width: 768px) {\n  .TeamHero {\n    padding: 64px 32px 48px;\n  }\n}\n\n.container {\n  margin: 0 auto;\n  max-width: 960px;\n}\n\n.title,\n.lead {\n  transition: color 0.25s;\n}\n\n.title {\n  line-height: 32px;\n  font-size: 32px;\n  font-weight: 500;\n}\n\n@media (min-width: 768px) {\n  .title {\n    line-height: 40px;\n    font-size: 40px;\n  }\n}\n\n.lead {\n  padding-top: 8px;\n  font-size: 16px;\n  font-weight: 500;\n  max-width: 512px;\n  color: var(--vt-c-text-2);\n}\n\n.action {\n  padding-top: 4px;\n}\n\n.action :deep(a) {\n  display: inline-block;\n  line-height: 20px;\n  font-size: 14px;\n  font-weight: 500;\n  color: var(--vt-c-brand);\n  transition: color 0.25s;\n}\n\n.action :deep(a:hover) {\n  color: var(--vt-c-brand-dark);\n}\n</style>\n\n\n\n================================================\nFILE: src/about/team/TeamList.vue\n================================================\n<script setup lang=\"ts\">\nimport type { Member } from './Member'\nimport TeamMember from './TeamMember.vue'\n\ndefineProps<{\n  members: Member[]\n}>()\n</script>\n\n<template>\n  <section class=\"TeamList\">\n    <div class=\"container\">\n      <div class=\"info\">\n        <h2 class=\"title\">\n          <slot name=\"title\" />\n        </h2>\n        <p class=\"lead\">\n          <slot name=\"lead\" />\n        </p>\n      </div>\n\n      <div class=\"members\">\n        <!-- to skip SSG since the members are shuffled -->\n        <ClientOnly>\n          <div v-for=\"member in members\" :key=\"member.name\" class=\"member\">\n            <TeamMember :member=\"member\" />\n          </div>\n        </ClientOnly>\n      </div>\n    </div>\n  </section>\n</template>\n\n<style scoped>\n@media (min-width: 768px) {\n  .TeamList {\n    padding: 0 32px;\n  }\n}\n\n.container {\n  border-top: 1px solid var(--vt-c-divider-light);\n  padding-top: 24px;\n}\n\n@media (min-width: 768px) {\n  .container {\n    margin: 0 auto;\n    display: flex;\n    align-items: flex-start;\n    max-width: 960px;\n  }\n}\n\n.info {\n  flex-shrink: 0;\n  padding: 0 24px;\n  max-width: 512px;\n}\n\n@media (min-width: 768px) {\n  .info {\n    position: sticky;\n    top: calc(var(--vt-banner-height, 0px) + 32px);\n    left: 0;\n    padding: 0 24px 0 0;\n    width: 256px;\n  }\n\n  html.banner-dismissed .info {\n    top: 32px;\n  }\n}\n\n@media (min-width: 960px) {\n  .info {\n    top: calc(var(--vt-banner-height, 0px) + 88px);\n    padding: 0 64px 0 0;\n    width: 384px;\n  }\n\n  html.banner-dismissed .info {\n    top: 88px;\n  }\n}\n\n.title {\n  font-size: 20px;\n  font-weight: 500;\n}\n\n.lead {\n  padding-top: 8px;\n  line-height: 24px;\n  font-size: 14px;\n  font-weight: 500;\n  color: var(--vt-c-text-2);\n}\n\n.members {\n  padding-top: 24px;\n}\n\n@media (min-width: 768px) {\n  .members {\n    flex-grow: 1;\n    padding-top: 0;\n  }\n}\n\n.member + .member {\n  padding-top: 16px;\n}\n\n@media (min-width: 640px) {\n  .member {\n    margin: 0 auto;\n    max-width: 592px;\n  }\n}\n\n@media (min-width: 768px) {\n  .member {\n    margin: 0;\n    max-width: 100%;\n  }\n}\n</style>\n\n\n\n================================================\nFILE: src/about/team/TeamMember.vue\n================================================\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport {\n  VTIconCode,\n  VTIconCodePen,\n  VTIconGitHub,\n  VTIconGlobe,\n  VTIconHeart,\n  VTIconLink,\n  VTIconLinkedIn,\n  VTIconMapPin,\n  VTIconX,\n  VTLink\n} from '@vue/theme'\nimport type { Member } from './Member'\n\nconst props = defineProps<{\n  member: Member\n}>()\n\nconst avatarUrl = computed(() => {\n  return (\n    props.member.avatarPic ??\n    `https://www.github.com/${props.member.socials.github}.png`\n  )\n})\n\nfunction arrayify(value: string | string[]): string[] {\n  return Array.isArray(value) ? value : [value]\n}\n</script>\n\n<template>\n  <article class=\"TeamMember\">\n    <VTLink\n      v-if=\"member.sponsor\"\n      class=\"sponsor\"\n      :href=\"`https://github.com/sponsors/${member.socials.github}`\"\n      no-icon\n    >\n      <VTIconHeart class=\"sponsor-icon\" /> 赞助\n    </VTLink>\n\n    <figure class=\"avatar\">\n      <img\n        class=\"avatar-img\"\n        :src=\"avatarUrl\"\n        :alt=\"`${member.name}'s Profile Picture`\"\n      />\n    </figure>\n\n    <div class=\"data\">\n      <h1 class=\"name\">{{ member.name }}</h1>\n      <p class=\"org\">\n        {{ member.title }}\n        <span v-if=\"member.company\" class=\"nowrap\">\n          @\n          <VTLink\n            v-if=\"member.companyLink\"\n            class=\"company link\"\n            :href=\"member.companyLink\"\n            :no-icon=\"true\"\n          >\n            {{ member.company }}\n          </VTLink>\n          <span v-else class=\"company\">\n            {{ member.company }}\n          </span>\n        </span>\n      </p>\n\n      <div class=\"profiles\">\n        <section v-if=\"member.projects\" class=\"desc\">\n          <div class=\"desc-title\">\n            <h2 class=\"sr-only\">Projects</h2>\n            <VTIconCode class=\"desc-icon code\" />\n          </div>\n          <ul class=\"desc-list\">\n            <li\n              v-for=\"project in member.projects\"\n              :key=\"project.label\"\n              class=\"desc-item\"\n            >\n              <VTLink\n                class=\"desc-link\"\n                :href=\"project.url\"\n                :no-icon=\"true\"\n              >\n                {{ project.label }}\n              </VTLink>\n            </li>\n          </ul>\n        </section>\n\n        <section class=\"desc\">\n          <div class=\"desc-title\">\n            <h2 class=\"sr-only\">Location</h2>\n            <VTIconMapPin class=\"desc-icon\" />\n          </div>\n          <ul class=\"desc-list\">\n            <li\n              v-for=\"location in arrayify(member.location)\"\n              :key=\"location\"\n              class=\"desc-item\"\n            >\n              {{ location }}\n            </li>\n          </ul>\n        </section>\n\n        <section class=\"desc\">\n          <div class=\"desc-title\">\n            <h2 class=\"sr-only\">Languages</h2>\n            <VTIconGlobe class=\"desc-icon\" />\n          </div>\n          <ul class=\"desc-list\">\n            <li\n              v-for=\"language in member.languages\"\n              :key=\"language\"\n              class=\"desc-item\"\n            >\n              {{ language }}\n            </li>\n          </ul>\n        </section>\n\n        <section v-if=\"member.website\" class=\"desc\">\n          <div class=\"desc-title\">\n            <h2 class=\"sr-only\">Website</h2>\n            <VTIconLink class=\"desc-icon\" />\n          </div>\n          <p class=\"desc-text\">\n            <VTLink\n              class=\"desc-link\"\n              :href=\"member.website.url\"\n              :no-icon=\"true\"\n            >\n              {{ member.website.label }}\n            </VTLink>\n          </p>\n        </section>\n\n        <ul class=\"social-list\">\n          <li v-if=\"member.socials.github\" class=\"social-item\">\n            <VTLink\n              class=\"social-link\"\n              :href=\"`https://github.com/${member.socials.github}`\"\n              :no-icon=\"true\"\n            >\n              <VTIconGitHub class=\"social-icon\" />\n            </VTLink>\n          </li>\n          <li v-if=\"member.socials.twitter\" class=\"social-item\">\n            <VTLink\n              class=\"social-link\"\n              :href=\"`https://twitter.com/${member.socials.twitter}`\"\n              :no-icon=\"true\"\n            >\n              <VTIconX class=\"social-icon\" />\n            </VTLink>\n          </li>\n          <li v-if=\"member.socials.linkedin\" class=\"social-item\">\n            <VTLink\n              class=\"social-link\"\n              :href=\"`https://www.linkedin.com/in/${member.socials.linkedin}`\"\n              :no-icon=\"true\"\n            >\n              <VTIconLinkedIn class=\"social-icon\" />\n            </VTLink>\n          </li>\n          <li v-if=\"member.socials.codepen\" class=\"social-item\">\n            <VTLink\n              class=\"social-link\"\n              :href=\"`https://codepen.io/${member.socials.codepen}`\"\n              :no-icon=\"true\"\n            >\n              <VTIconCodePen class=\"social-icon\" />\n            </VTLink>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </article>\n</template>\n\n<style scoped>\n.TeamMember {\n  position: relative;\n  background-color: var(--vt-c-bg-soft);\n  transition: background-color 0.5s;\n}\n\n@media (min-width: 512px) {\n  .TeamMember {\n    display: flex;\n  }\n}\n\n@media (min-width: 640px) {\n  .TeamMember {\n    border-radius: 8px;\n  }\n}\n\n.sponsor {\n  position: absolute;\n  top: 16px;\n  right: 16px;\n  display: flex;\n  align-items: center;\n  border: 1px solid #fd1d7c;\n  border-radius: 4px;\n  padding: 4px 8px;\n  font-size: 12px;\n  font-weight: 500;\n  color: #fd1d7c;\n  transition: color 0.25s, background-color 0.25s;\n}\n\n.sponsor:hover {\n  color: var(--vt-c-white);\n  background-color: #fd1d7c;\n}\n\n.sponsor-icon {\n  margin-right: 6px;\n  width: 14px;\n  height: 14px;\n  fill: currentColor;\n}\n\n.avatar {\n  flex-shrink: 0;\n  padding: 32px 32px 0;\n}\n\n@media (min-width: 512px) {\n  .avatar {\n    padding: 32px 0 0 32px;\n  }\n}\n\n.avatar-img {\n  border-radius: 50%;\n  width: 96px;\n  height: 96px;\n  transform: translateX(-8px);\n}\n\n@media (min-width: 512px) {\n  .avatar-img {\n    width: 80px;\n    height: 80px;\n    transform: translateX(0);\n  }\n}\n\n.data {\n  padding: 20px 32px 32px;\n}\n\n@media (min-width: 512px) {\n  .data {\n    padding: 40px 32px 32px 32px;\n  }\n}\n\n.name {\n  font-size: 20px;\n  font-weight: 500;\n}\n\n.org {\n  padding-top: 4px;\n  line-height: 20px;\n  max-width: 320px;\n  font-size: 14px;\n  font-weight: 500;\n  color: var(--vt-c-text-2);\n  transition: color 0.5s;\n}\n\n.company {\n  color: var(--vt-c-text-1);\n  transition: color 0.25s;\n}\n\n.company.link:hover {\n  color: var(--vt-c-brand);\n  transition: color 0.5s;\n}\n\n.profiles {\n  padding-top: 16px;\n}\n\n.desc {\n  display: flex;\n}\n\n.desc + .desc {\n  padding-top: 12px;\n}\n\n.desc-title {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-shrink: 0;\n  padding-right: 12px;\n  height: 20px;\n}\n\n.desc-icon {\n  width: 16px;\n  height: 16px;\n  fill: var(--vt-c-text-2);\n  transition: fill 0.25s;\n}\n\n.desc-icon.code {\n  transform: translateY(1px);\n}\n\n.desc-list {\n  display: flex;\n  flex-wrap: wrap;\n  margin: 0 -4px;\n}\n\n.desc-item {\n  padding: 0 4px;\n  line-height: 20px;\n  font-size: 14px;\n  font-weight: 500;\n  color: var(--vt-c-text-1);\n  transition: color 0.5s;\n}\n\n.desc-item::after {\n  margin-left: 8px;\n  content: '•';\n  color: var(--vt-c-text-3);\n  transition: color 0.25s;\n}\n\n.desc-item:last-child::after {\n  display: none;\n}\n\n.desc-text {\n  line-height: 20px;\n  font-size: 14px;\n  font-weight: 500;\n  color: var(--vt-c-text-1);\n  transition: color 0.25s;\n}\n\n.desc-link {\n  line-height: 20px;\n  font-size: 14px;\n  font-weight: 500;\n  color: var(--vt-c-brand);\n  transition: color 0.25s;\n}\n\n.desc-link:hover {\n  color: var(--vt-c-brand-dark);\n}\n\n.social-list {\n  display: flex;\n  flex-wrap: wrap;\n  margin-left: -6px;\n  padding-top: 16px;\n}\n\n.social-item + .social-item {\n  padding-left: 8px;\n}\n\n.social-link {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 32px;\n  height: 32px;\n  color: var(--vt-c-text-2);\n  transition: color 0.25s;\n}\n\n.social-link:hover {\n  color: var(--vt-c-text-1);\n}\n\n.social-icon {\n  width: 20px;\n  height: 20px;\n  fill: currentColor;\n}\n</style>\n\n\n\n================================================\nFILE: src/about/team/TeamPage.vue\n================================================\n<script lang=\"ts\">\nconst shuffleMembers = (\n  members: Member[],\n  pinTheFirstMember = false\n): void => {\n  let offset = pinTheFirstMember ? 1 : 0\n  // `i` is between `1` and `length - offset`\n  // `j` is between `0` and `length - offset - 1`\n  // `offset + i - 1` is between `offset` and `length - 1`\n  // `offset + j` is between `offset` and `length - 1`\n  let i = members.length - offset\n  while (i > 0) {\n    const j = Math.floor(Math.random() * i)\n    ;[members[offset + i - 1], members[offset + j]] = [\n      members[offset + j],\n      members[offset + i - 1]\n    ]\n    i--\n  }\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { VTLink } from '@vue/theme'\nimport membersCoreData from './members-core.json'\nimport membersEmeritiData from './members-emeriti.json'\nimport membersPartnerData from './members-partner.json'\nimport TeamHero from './TeamHero.vue'\nimport TeamList from './TeamList.vue'\nimport type { Member } from './Member'\nshuffleMembers(membersCoreData as Member[], true)\nshuffleMembers(membersEmeritiData as Member[])\nshuffleMembers(membersPartnerData as Member[])\n</script>\n\n<template>\n  <div class=\"TeamPage\">\n    <TeamHero>\n      <template #title>认识团队</template>\n      <template #lead>Vue 及其生态系统发展的背后是一个国际化的团队，以下是部分团员的个人信息。</template>\n\n      <template #action>\n        <VTLink href=\"https://github.com/vuejs/governance/blob/master/Team-Charter.md\">了解更多团队信息</VTLink>\n      </template>\n    </TeamHero>\n\n    <TeamList :members=\"(membersCoreData as Member[])\">\n      <template #title>核心团队成员</template>\n      <template #lead>核心团队成员是那些积极参与维护一个或多个核心项目的人。他们对 Vue 的生态系统做出了重大贡献，并对项目及其用户的成功做出了长期的承诺。</template>\n    </TeamList>\n\n    <TeamList :members=\"(membersEmeritiData as Member[])\">\n      <template #title>名誉核心团队</template>\n      <template #lead>我们在此致敬过去曾做出过突出贡献的不再活跃的团队成员。</template>\n    </TeamList>\n\n    <TeamList :members=\"(membersPartnerData as Member[])\">\n      <template #title>社区伙伴</template>\n      <template #lead>一些 Vue 的社区成员让这里变得更加丰富多彩，有必要在此特别提及。我们与这些主要合作伙伴建立了更加亲密的关系，经常与他们就即将到来的功能和新闻展开协作。</template>\n    </TeamList>\n  </div>\n</template>\n\n<style scoped>\n.TeamPage {\n  padding-bottom: 16px;\n}\n\n@media (min-width: 768px) {\n  .TeamPage {\n    padding-bottom: 96px;\n  }\n}\n\n.TeamList + .TeamList {\n  padding-top: 64px;\n}\n</style>\n\n\n\n================================================\nFILE: src/api/api.data.ts\n================================================\n// api.data.ts\nimport fs from 'fs'\nimport path from 'path'\nimport type { MultiSidebarConfig } from '@vue/theme/src/vitepress/config.ts'\nimport { sidebar } from '../../.vitepress/config'\n\n// Interface defining the structure of a single header in the API\ninterface APIHeader {\n  anchor: string\n  text: string\n}\n\n// Interface defining the structure of an API group with text, anchor, and items\nexport interface APIGroup {\n  text: string\n  anchor: string\n  items: {\n    text: string\n    link: string\n    headers: APIHeader[]\n  }[]\n}\n\n// Declare the resolved data type for API groups\nexport declare const data: APIGroup[]\n\n// Utility function to generate a slug from a string (used for anchor links)\nfunction slugify(text: string): string {\n  return (\n    text\n      // Replace special characters and spaces with hyphens\n      .replace(/[\\s~`!@#$%^&*()\\-_+=[\\]{}|\\\\;:\"'<>,.?/]+/g, '-')\n      // Remove continuous separators\n      .replace(/-{2,}/g, '-')\n      // Remove leading/trailing hyphens\n      .replace(/^-+|-+$/g, '')\n      // Ensure it doesn't start with a number (e.g. #121)\n      .replace(/^(\\d)/, '_$1')\n      // Convert to lowercase\n      .toLowerCase()\n  )\n}\n\n// Utility function to parse headers from a markdown file at a given link\nfunction parsePageHeaders(link: string): APIHeader[] {\n  const fullPath = path.join(__dirname, '../', link) + '.md' // Resolve the full file path\n  const timestamp = fs.statSync(fullPath).mtimeMs // Get the last modified timestamp of the file\n\n  // Check if the file is cached and if its timestamp matches\n  const cached = headersCache.get(fullPath)\n  if (cached && timestamp === cached.timestamp) {\n    return cached.headers // Return cached headers if they're up-to-date\n  }\n\n  const src = fs.readFileSync(fullPath, 'utf-8') // Read the markdown file\n  const headers = extractHeadersFromMarkdown(src) // Extract headers from the file content\n\n  // Store the extracted headers along with the file's timestamp in the cache\n  headersCache.set(fullPath, {\n    timestamp,\n    headers\n  })\n\n  return headers\n}\n\n// Helper function to extract all headers (h2) from markdown content\nfunction extractHeadersFromMarkdown(src: string): APIHeader[] {\n  const h2s = src.match(/^## [^\\n]+/gm) // Match all h2 headers (## header)\n  const anchorRE = /\\{#([^}]+)\\}/ // Regular expression to match the anchor link in header (e.g. {#some-anchor})\n  let headers: APIHeader[] = []\n\n  if (h2s) {\n    // Process each h2 header and extract text and anchor\n    headers = h2s.map((h) => {\n      const text = cleanHeaderText(h, anchorRE) // Clean up header text\n      const anchor = extractAnchor(h, anchorRE, text) // Extract or generate anchor\n      return { text, anchor }\n    })\n  }\n\n  return headers\n}\n\n// Helper function to clean up header text (e.g., remove superscript, code formatting)\nfunction cleanHeaderText(h: string, anchorRE: RegExp): string {\n  return h\n    .slice(2) // Remove the \"##\" part of the header\n    .replace(/<sup class=.*/, '') // Remove superscript (e.g., <sup> tags)\n    .replace(/\\\\</g, '<') // Decode escaped characters like \\<\n    .replace(/`([^`]+)`/g, '$1') // Remove inline code formatting (e.g., `code`)\n    .replace(anchorRE, '') // Remove anchor tags (e.g., {#anchor})\n    .trim() // Trim leading/trailing whitespace\n}\n\n// Helper function to extract the anchor link from a header (or generate one if missing)\nfunction extractAnchor(h: string, anchorRE: RegExp, text: string): string {\n  const anchorMatch = h.match(anchorRE) // Match anchor if it exists\n  return anchorMatch?.[1] ?? slugify(text) // If no anchor, generate one using slugify\n}\n\n// Cache for storing headers and their associated timestamps to avoid re-reading files\nconst headersCache = new Map<\n  string,\n  {\n    headers: APIHeader[]\n    timestamp: number\n  }\n>()\n\n// Main export function for loading the API data\nexport default {\n  // Declare files that should trigger Hot Module Replacement (HMR)\n  watch: './*.md',\n  \n  // Load API data and process sidebar items\n  load(): APIGroup[] {\n    // Generate the API group data by processing the sidebar configuration\n    return (sidebar as MultiSidebarConfig)['/api/'].map((group) => ({\n      text: group.text, // Text of the group (e.g., 'API')\n      anchor: slugify(group.text), // Generate anchor for the group title\n      items: group.items.map((item) => ({\n        ...item, // Spread the original item properties\n        headers: parsePageHeaders(item.link), // Parse the headers from the item's markdown link\n      }))\n    }))\n  }\n}\n\n\n\n================================================\nFILE: src/api/ApiIndex.vue\n================================================\n<script setup lang=\"ts\">\n// in .vue components or .md pages:\n// named import \"data\" is the resolved static data\n// can also import types for type consistency\nimport { data as apiIndex, APIGroup } from './api.data'\nimport { ref, computed, onMounted } from 'vue'\nimport { withBase } from 'vitepress'\n\nconst search = ref()\nconst query = ref('')\nconst normalize = (s: string) => s.toLowerCase().replace(/-/g, ' ')\n\nonMounted(() => {\n  search.value?.focus()\n})\n\nconst filtered = computed(() => {\n  const q = normalize(query.value)\n  const matches = (text: string) => normalize(text).includes(q)\n\n  return apiIndex\n    .map((section) => {\n      // section title match\n      if (matches(section.text)) {\n        return section\n      }\n\n      // filter groups\n      const matchedGroups = section.items\n        .map((item) => {\n          // group title match\n          if (matches(item.text)) {\n            return item\n          }\n          // ssr special case\n          if (q.includes('ssr') && item.text.startsWith('Server')) {\n            return item\n          }\n          // filter headers\n          const matchedHeaders = item.headers.filter(\n            ({ text, anchor }) => matches(text) || matches(anchor)\n          )\n          return matchedHeaders.length\n            ? { text: item.text, link: item.link, headers: matchedHeaders }\n            : null\n        })\n        .filter((i) => i)\n\n      return matchedGroups.length\n        ? { text: section.text, items: matchedGroups }\n        : null\n    })\n    .filter((i) => i) as APIGroup[]\n})\n</script>\n\n<template>\n  <div id=\"api-index\">\n    <div class=\"header\">\n      <h1>API 参考</h1>\n      <div class=\"api-filter\">\n        <label for=\"api-filter\">过滤</label>\n        <input\n          ref=\"search\"\n          type=\"search\"\n          placeholder=\"Enter keyword\"\n          id=\"api-filter\"\n          v-model=\"query\"\n        />\n      </div>\n    </div>\n\n    <div\n      v-for=\"section of filtered\"\n      :key=\"section.text\"\n      class=\"api-section\"\n    >\n      <h2 :id=\"section.anchor\">{{ section.text }}</h2>\n      <div class=\"api-groups\">\n        <div\n          v-for=\"item of section.items\"\n          :key=\"item.text\"\n          class=\"api-group\"\n        >\n          <h3>{{ item.text }}</h3>\n          <ul>\n            <li v-for=\"h of item.headers\" :key=\"h.anchor\">\n              <a :href=\"withBase(item.link) + '.html#' + h.anchor\">{{ h.text }}</a>\n            </li>\n          </ul>\n        </div>\n      </div>\n    </div>\n\n    <div v-if=\"!filtered.length\" class=\"no-match\">\n      没有匹配到 API \"{{ query }}\"\n    </div>\n  </div>\n</template>\n\n<style scoped>\n#api-index {\n  max-width: 1024px;\n  margin: 0px auto;\n  padding: 64px 32px;\n}\n\nh1,\nh2,\nh3 {\n  font-weight: 600;\n  line-height: 1;\n}\n\nh1,\nh2 {\n  letter-spacing: -0.02em;\n}\n\nh1 {\n  font-size: 38px;\n}\n\nh2 {\n  font-size: 24px;\n  color: var(--vt-c-text-1);\n  margin: 36px 0;\n  transition: color 0.5s;\n  padding-top: 36px;\n  border-top: 1px solid var(--vt-c-divider-light);\n}\n\nh3 {\n  letter-spacing: -0.01em;\n  color: var(--vt-c-green);\n  font-size: 18px;\n  margin-bottom: 1em;\n  transition: color 0.5s;\n}\n\n.api-section {\n  margin-bottom: 64px;\n}\n\n.api-groups a {\n  font-size: 15px;\n  font-weight: 500;\n  line-height: 2;\n  color: var(--vt-c-text-code);\n  transition: color 0.5s;\n}\n\n.dark api-groups a {\n  font-weight: 400;\n}\n\n.api-groups a:hover {\n  color: var(--vt-c-green);\n  transition: none;\n}\n\n.api-group {\n  break-inside: avoid;\n  overflow: auto;\n  margin-bottom: 20px;\n  background-color: var(--vt-c-bg-soft);\n  border-radius: 8px;\n  padding: 24px 28px;\n  transition: background-color 0.5s;\n}\n\n.header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.api-filter {\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n  gap: 1rem;\n}\n\n#api-filter {\n  border: 1px solid var(--vt-c-divider);\n  border-radius: 8px;\n  padding: 6px 12px;\n  transition: box-shadow 0.25s ease;\n}\n\n#api-filter:focus {\n  box-shadow: 0 0 4pt #00d47499;\n}\n\n.api-filter:focus {\n  border-color: var(--vt-c-green-light);\n}\n\n.no-match {\n  font-size: 1.2em;\n  color: var(--vt-c-text-3);\n  text-align: center;\n  margin-top: 36px;\n  padding-top: 36px;\n  border-top: 1px solid var(--vt-c-divider-light);\n}\n\n@media (max-width: 768px) {\n  #api-index {\n    padding: 42px 24px;\n  }\n  h1 {\n    font-size: 32px;\n    margin-bottom: 24px;\n  }\n  h2 {\n    font-size: 22px;\n    margin: 42px 0 32px;\n    padding-top: 32px;\n  }\n  .api-groups a {\n    font-size: 14px;\n  }\n  .header {\n    display: block;\n  }\n}\n\n@media (min-width: 768px) {\n  .api-groups {\n    columns: 2;\n  }\n}\n\n@media (min-width: 1024px) {\n  .api-groups {\n    columns: 3;\n  }\n}\n</style>\n\n\n\n================================================\nFILE: src/api/application.md\n================================================\n# 应用实例 API {#application-api}\n\n## createApp() {#createapp}\n\n创建一个应用实例。\n\n- **类型**\n\n  ```ts\n  function createApp(rootComponent: Component, rootProps?: object): App\n  ```\n\n- **详细信息**\n\n  第一个参数是根组件。第二个参数可选，它是要传递给根组件的 props。\n\n- **示例**\n\n  可以直接内联根组件：\n\n  ```js\n  import { createApp } from 'vue'\n\n  const app = createApp({\n    /* 根组件选项 */\n  })\n  ```\n\n  也可以使用从别处导入的组件：\n\n  ```js\n  import { createApp } from 'vue'\n  import App from './App.vue'\n\n  const app = createApp(App)\n  ```\n\n- **参考**[指南 - 创建一个 Vue 应用实例](/guide/essentials/application)\n\n## createSSRApp() {#createssrapp}\n\n以 [SSR 激活](/guide/scaling-up/ssr#client-hydration)模式创建一个应用实例。用法与 `createApp()` 完全相同。\n\n## app.mount() {#app-mount}\n\n将应用实例挂载在一个容器元素中。\n\n- **类型**\n\n  ```ts\n  interface App {\n    mount(rootContainer: Element | string): ComponentPublicInstance\n  }\n  ```\n\n- **详细信息**\n\n  参数可以是一个实际的 DOM 元素或一个 CSS 选择器 (使用第一个匹配到的元素)。返回根组件的实例。\n\n  如果该组件有模板或定义了渲染函数，它将替换容器内所有现存的 DOM 节点。否则在运行时编译器可用的情况下，容器元素的 `innerHTML` 将被用作模板。\n\n  在 SSR 激活模式下，它将激活容器内现有的 DOM 节点。如果出现了[激活不匹配](/guide/scaling-up/ssr#hydration-mismatch)，那么现有的 DOM 节点将会被修改以匹配客户端的实际渲染结果。\n\n  对于每个应用实例，`mount()` 仅能调用一次。\n\n- **示例**\n\n  ```js\n  import { createApp } from 'vue'\n  const app = createApp(/* ... */)\n\n  app.mount('#app')\n  ```\n\n  也可以挂载到一个实际的 DOM 元素。\n\n  ```js\n  app.mount(document.body.firstChild)\n  ```\n\n## app.unmount() {#app-unmount}\n\n卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。\n\n- **类型**\n\n  ```ts\n  interface App {\n    unmount(): void\n  }\n  ```\n\n## app.onUnmount() <sup class=\"vt-badge\" data-text=\"3.5+\" /> {#app-onunmount}\n\n注册一个回调函数，在应用卸载时调用。\n\n- **类型**\n\n  ```ts\n  interface App {\n    onUnmount(callback: () => any): void\n  }\n  ```\n\n## app.component() {#app-component}\n\n如果同时传递一个组件名字符串及其定义，则注册一个全局组件；如果只传递一个名字，则会返回用该名字注册的组件 (如果存在的话)。\n\n- **类型**\n\n  ```ts\n  interface App {\n    component(name: string): Component | undefined\n    component(name: string, component: Component): this\n  }\n  ```\n\n- **示例**\n\n  ```js\n  import { createApp } from 'vue'\n\n  const app = createApp({})\n\n  // 注册一个选项对象\n  app.component('MyComponent', {\n    /* ... */\n  })\n\n  // 得到一个已注册的组件\n  const MyComponent = app.component('MyComponent')\n  ```\n\n- **参考**[组件注册](/guide/components/registration)\n\n## app.directive() {#app-directive}\n\n如果同时传递一个名字和一个指令定义，则注册一个全局指令；如果只传递一个名字，则会返回用该名字注册的指令 (如果存在的话)。\n\n- **类型**\n\n  ```ts\n  interface App {\n    directive(name: string): Directive | undefined\n    directive(name: string, directive: Directive): this\n  }\n  ```\n\n- **示例**\n\n  ```js\n  import { createApp } from 'vue'\n\n  const app = createApp({\n    /* ... */\n  })\n\n  // 注册(对象形式的指令)\n  app.directive('myDirective', {\n    /* 自定义指令钩子 */\n  })\n\n  // 注册(函数形式的指令)\n  app.directive('myDirective', () => {\n    /* ... */\n  })\n\n  // 得到一个已注册的指令\n  const myDirective = app.directive('myDirective')\n  ```\n\n- **参考**[自定义指令](/guide/reusability/custom-directives)\n\n## app.use() {#app-use}\n\n安装一个[插件](/guide/reusability/plugins)。\n\n- **类型**\n\n  ```ts\n  interface App {\n    use(plugin: Plugin, ...options: any[]): this\n  }\n  ```\n\n- **详细信息**\n\n  第一个参数应是插件本身，可选的第二个参数是要传递给插件的选项。\n\n  插件可以是一个带 `install()` 方法的对象，亦或直接是一个将被用作 `install()` 方法的函数。插件选项 (`app.use()` 的第二个参数) 将会传递给插件的 `install()` 方法。\n\n  若 `app.use()` 对同一个插件多次调用，该插件只会被安装一次。\n\n- **示例**\n\n  ```js\n  import { createApp } from 'vue'\n  import MyPlugin from './plugins/MyPlugin'\n\n  const app = createApp({\n    /* ... */\n  })\n\n  app.use(MyPlugin)\n  ```\n\n- **参考**[插件](/guide/reusability/plugins)\n\n## app.mixin() {#app-mixin}\n\n应用一个全局 mixin (适用于该应用的范围)。一个全局的 mixin 会作用于应用中的每个组件实例。\n\n:::warning 不推荐\nMixins 在 Vue 3 支持主要是为了向后兼容，因为生态中有许多库使用到。在新的应用中应尽量避免使用 mixin，特别是全局 mixin。\n\n若要进行逻辑复用，推荐用[组合式函数](/guide/reusability/composables)来替代。\n:::\n\n- **类型**\n\n  ```ts\n  interface App {\n    mixin(mixin: ComponentOptions): this\n  }\n  ```\n\n## app.provide() {#app-provide}\n\n提供一个值，可以在应用中的所有后代组件中注入使用。\n\n- **类型**\n\n  ```ts\n  interface App {\n    provide<T>(key: InjectionKey<T> | symbol | string, value: T): this\n  }\n  ```\n\n- **详细信息**\n\n  第一个参数应当是注入的 key，第二个参数则是提供的值。返回应用实例本身。\n\n- **示例**\n\n  ```js\n  import { createApp } from 'vue'\n\n  const app = createApp(/* ... */)\n\n  app.provide('message', 'hello')\n  ```\n\n  在应用的某个组件中：\n\n  <div class=\"composition-api\">\n\n  ```js\n  import { inject } from 'vue'\n\n  export default {\n    setup() {\n      console.log(inject('message')) // 'hello'\n    }\n  }\n  ```\n\n  </div>\n  <div class=\"options-api\">\n\n  ```js\n  export default {\n    inject: ['message'],\n    created() {\n      console.log(this.message) // 'hello'\n    }\n  }\n  ```\n\n  </div>\n\n- **参考**\n  - [依赖注入](/guide/components/provide-inject)\n  - [应用层 Provide](/guide/components/provide-inject#app-level-provide)\n  - [app.runWithContext()](#app-runwithcontext)\n\n## app.runWithContext() {#app-runwithcontext}\n\n- 仅在 3.3+ 中支持\n\n使用当前应用作为注入上下文执行回调函数。\n\n- **类型**\n\n  ```ts\n  interface App {\n    runWithContext<T>(fn: () => T): T\n  }\n  ```\n\n- **详情**\n\n  需要一个回调函数并立即运行该回调。在回调同步调用期间，即使没有当前活动的组件实例，`inject()` 调用也可以从当前应用提供的值中查找注入。回调的返回值也将被返回。\n\n- **示例**\n\n  ```js\n  import { inject } from 'vue'\n\n  app.provide('id', 1)\n\n  const injected = app.runWithContext(() => {\n    return inject('id')\n  })\n\n  console.log(injected) // 1\n  ```\n\n## app.version {#app-version}\n\n提供当前应用所使用的 Vue 版本号。这在[插件](/guide/reusability/plugins)中很有用，因为可能需要根据不同的 Vue 版本执行不同的逻辑。\n\n- **类型**\n\n  ```ts\n  interface App {\n    version: string\n  }\n  ```\n\n- **示例**\n\n  在一个插件中对版本作判断：\n\n  ```js\n  export default {\n    install(app) {\n      const version = Number(app.version.split('.')[0])\n      if (version < 3) {\n        console.warn('This plugin requires Vue 3')\n      }\n    }\n  }\n  ```\n\n- **参考**[全局 API - version](/api/general#version)\n\n## app.config {#app-config}\n\n每个应用实例都会暴露一个 `config` 对象，其中包含了对这个应用的配置设定。你可以在挂载应用前更改这些属性 (下面列举了每个属性的对应文档)。\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp(/* ... */)\n\nconsole.log(app.config)\n```\n\n## app.config.errorHandler {#app-config-errorhandler}\n\n用于为应用内抛出的未捕获错误指定一个全局处理函数。\n\n- **类型**\n\n  ```ts\n  interface AppConfig {\n    errorHandler?: (\n      err: unknown,\n      instance: ComponentPublicInstance | null,\n      // `info` 是一个 Vue 特定的错误信息\n      // 例如：错误是在哪个生命周期的钩子上抛出的\n      info: string\n    ) => void\n  }\n  ```\n\n- **详细信息**\n\n  错误处理器接收三个参数：错误对象、触发该错误的组件实例和一个指出错误来源类型信息的字符串。\n\n  它可以从下面这些来源中捕获错误：\n\n  - 组件渲染器\n  - 事件处理器\n  - 生命周期钩子\n  - `setup()` 函数\n  - 侦听器\n  - 自定义指令钩子\n  - 过渡 (Transition) 钩子\n\n  :::tip\n  在生产环境中，第三个参数 (`info`) 是一个缩短的代码，而不是含有完整信息的字符串。错误代码和字符串的映射可以参阅[生产环境错误代码参考](/error-reference/#runtime-errors)。\n  :::\n\n- **示例**\n\n  ```js\n  app.config.errorHandler = (err, instance, info) => {\n    // 处理错误，例如：报告给一个服务\n  }\n  ```\n\n## app.config.warnHandler {#app-config-warnhandler}\n\n用于为 Vue 的运行时警告指定一个自定义处理函数。\n\n- **类型**\n\n  ```ts\n  interface AppConfig {\n    warnHandler?: (\n      msg: string,\n      instance: ComponentPublicInstance | null,\n      trace: string\n    ) => void\n  }\n  ```\n\n- **详细信息**\n\n  警告处理器将接受警告信息作为其第一个参数，来源组件实例为第二个参数，以及组件追踪字符串作为第三个参数。\n\n  这可以用于过滤筛选特定的警告信息，降低控制台输出的冗余。所有的 Vue 警告都需要在开发阶段得到解决，因此仅建议在调试期间选取部分特定警告，并且应该在调试完成之后立刻移除。\n\n  :::tip\n  警告仅会在开发阶段显示，因此在生产环境中，这条配置将被忽略。\n  :::\n\n- **示例**\n\n  ```js\n  app.config.warnHandler = (msg, instance, trace) => {\n    // `trace` 是组件层级结构的追踪\n  }\n  ```\n\n## app.config.performance {#app-config-performance}\n\n设置此项为 `true` 可以在浏览器开发工具的“性能/时间线”页中启用对组件初始化、编译、渲染和修补的性能表现追踪。仅在开发模式和支持 [performance.mark](https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark) API 的浏览器中工作。\n\n- **类型**：`boolean`\n\n- **参考**[指南 - 性能](/guide/best-practices/performance)\n\n## app.config.compilerOptions {#app-config-compileroptions}\n\n配置运行时编译器的选项。设置在此对象上的值将会在浏览器内进行模板编译时使用，并会影响到所配置应用的所有组件。另外你也可以通过 [`compilerOptions` 选项](/api/options-rendering#compileroptions)在每个组件的基础上覆盖这些选项。\n\n::: warning 重要\n此配置项仅在完整构建版本，即可以在浏览器中编译模板的 `vue.js` 文件中可用。如果你用的是带构建的项目配置，且使用的是仅含运行时的 Vue 文件版本，那么编译器选项必须通过构建工具的相关配置传递给 `@vue/compiler-dom`。\n\n- `vue-loader`：[通过 `compilerOptions` loader 的选项传递](https://vue-loader.vuejs.org/zh/options.html#compileroptions)。并请阅读[如何在 `vue-cli` 中配置它](https://cli.vuejs.org/zh/guide/webpack.html#%E4%BF%AE%E6%94%B9-loader-%E9%80%89%E9%A1%B9)。\n\n- `vite`：[通过 `@vitejs/plugin-vue` 的选项传递](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#options)。\n:::\n\n### app.config.compilerOptions.isCustomElement {#app-config-compileroptions-iscustomelement}\n\n用于指定一个检查方法来识别原生自定义元素。\n\n- **类型** `(tag: string) => boolean`\n\n- **详细信息**\n\n  如果该标签需要当作原生自定义元素则应返回 `true`。对匹配到的标签，Vue 会将其渲染为原生元素而非将其视为一个 Vue 组件来解析。\n\n  原生 HTML 和 SVG 标签不需要在此函数中进行匹配，Vue 的解析器会自动识别它们。\n\n- **示例**\n\n  ```js\n  // 将所有标签前缀为 `ion-` 的标签视为自定义元素\n  app.config.compilerOptions.isCustomElement = (tag) => {\n    return tag.startsWith('ion-')\n  }\n  ```\n\n- **参考** [Vue 与 Web Components](/guide/extras/web-components)\n\n### app.config.compilerOptions.whitespace {#app-config-compileroptions-whitespace}\n\n用于调整模板中空格的处理行为。\n\n- **类型** `'condense' | 'preserve'`\n\n- **默认** `'condense'`\n\n- **详细信息**\n\n  Vue 移除/缩短了模板中的空格以求更高效的模板输出。默认的策略是“缩短”，表现行为如下：\n\n  1. 元素中开头和结尾的空格字符将被缩短为一个空格。\n  2. 包含换行的元素之间的空白字符会被删除。\n  3. 文本节点中连续的空白字符被缩短成一个空格。\n\n  设置该选项为 `'preserve'` 则会禁用 (2) 和 (3) 两项。\n\n- **示例**\n\n  ```js\n  app.config.compilerOptions.whitespace = 'preserve'\n  ```\n\n### app.config.compilerOptions.delimiters {#app-config-compileroptions-delimiters}\n\n用于调整模板内文本插值的分隔符。\n\n- **类型** `[string, string]`\n\n- **默认** `{{ \"['\\u007b\\u007b', '\\u007d\\u007d']\" }}`\n\n- **详细信息**\n\n  此项通常是为了避免与同样使用 mustache 语法的服务器端框架发生冲突。\n\n- **示例**\n\n  ```js\n  // 分隔符改为ES6模板字符串样式\n  app.config.compilerOptions.delimiters = ['${', '}']\n  ```\n\n### app.config.compilerOptions.comments {#app-config-compileroptions-comments}\n\n用于调整模板中 HTML 注释的处理方式。\n\n- **类型** `boolean`\n\n- **默认** `false`\n\n- **详细信息**\n\n  默认情况下，Vue 会在生产环境移除所有注释，设置该项为 `true` 会强制 Vue 在生产环境也保留注释。在开发过程中，注释是始终被保留的。这个选项通常在 Vue 与其他依赖 HTML 注释的库一起使用时使用。\n\n- **示例**\n\n  ```js\n  app.config.compilerOptions.comments = true\n  ```\n\n## app.config.globalProperties {#app-config-globalproperties}\n\n一个用于注册能够被应用内所有组件实例访问到的全局属性的对象。\n\n- **类型**\n\n  ```ts\n  interface AppConfig {\n    globalProperties: Record<string, any>\n  }\n  ```\n\n- **详细信息**\n\n  这是对 Vue 2 中 `Vue.prototype` 使用方式的一种替代，此写法在 Vue 3 已经不存在了。与任何全局的东西一样，应该谨慎使用。\n\n  如果全局属性与组件自己的属性冲突，组件自己的属性将具有更高的优先级。\n\n- **用法**\n\n  ```js\n  app.config.globalProperties.msg = 'hello'\n  ```\n\n  这使得 `msg` 在应用的任意组件模板上都可用，并且也可以通过任意组件实例的 `this` 访问到：\n\n  ```js\n  export default {\n    mounted() {\n      console.log(this.msg) // 'hello'\n    }\n  }\n  ```\n\n- **参考**[指南 - 扩展全局属性](/guide/typescript/options-api#augmenting-global-properties) <sup class=\"vt-badge ts\" />\n\n## app.config.optionMergeStrategies {#app-config-optionmergestrategies}\n\n一个用于定义自定义组件选项的合并策略的对象。\n\n- **类型**\n\n  ```ts\n  interface AppConfig {\n    optionMergeStrategies: Record<string, OptionMergeFunction>\n  }\n\n  type OptionMergeFunction = (to: unknown, from: unknown) => any\n  ```\n\n- **详细信息**\n\n  一些插件或库对自定义组件选项添加了支持 (通过注入全局 mixin)。这些选项在有多个不同来源时可能需要特殊的合并策略 (例如 mixin 或组件继承)。\n\n  可以在 `app.config.optionMergeStrategies` 对象上以选项的名称作为 key，可以为一个自定义选项注册分配一个合并策略函数。\n\n  合并策略函数分别接受在父实例和子实例上定义的该选项的值作为第一和第二个参数。\n\n- **示例**\n\n  ```js\n  const app = createApp({\n    // 自身的选项\n    msg: 'Vue',\n    // 来自 mixin 的选项\n    mixins: [\n      {\n        msg: 'Hello '\n      }\n    ],\n    mounted() {\n      // 在 this.$options 上暴露被合并的选项\n      console.log(this.$options.msg)\n    }\n  })\n\n  // 为 `msg` 定义一个合并策略函数\n  app.config.optionMergeStrategies.msg = (parent, child) => {\n    return (parent || '') + (child || '')\n  }\n\n  app.mount('#app')\n  // 打印 'Hello Vue'\n  ```\n\n- **参考**[组件实例 - `$options`](/api/component-instance#options)\n\n## app.config.idPrefix <sup class=\"vt-badge\" data-text=\"3.5+\" /> {#app-config-idprefix}\n\n配置此应用中通过 [useId()](/api/composition-api-helpers.html#useid) 生成的所有 ID 的前缀。\n\n- **类型** `string`\n\n- **默认值** `undefined`\n\n- **示例**\n\n  ```js\n  app.config.idPrefix = 'myApp'\n  ```\n\n  ```js\n  // 在组件中：\n  const id1 = useId() // 'myApp:0'\n  const id2 = useId() // 'myApp:1'\n  ```\n\n## app.config.throwUnhandledErrorInProduction <sup class=\"vt-badge\" data-text=\"3.5+\" /> {#app-config-throwunhandlederrorinproduction}\n\n强制在生产模式下抛出未处理的错误。\n\n- **类型** `boolean`\n\n- **默认值** `false`\n\n- **详情**\n\n  默认情况下，在 Vue 应用中抛出但未显式处理的错误在开发和生产模式下有不同的行为：\n\n  - 在开发模式下，错误会被抛出并可能导致应用崩溃。这是为了使错误更加突出，以便在开发过程中被注意到并修复。\n\n  - 在生产模式下，错误只会被记录到控制台以尽量减少对最终用户的影响。然而，这可能会导致只在生产中发生的错误无法被错误监控服务捕获。\n\n  通过将 `app.config.throwUnhandledErrorInProduction` 设置为 `true`，即使在生产模式下也会抛出未处理的错误。\n\n\n\n================================================\nFILE: src/api/built-in-components.md\n================================================\n---\npageClass: api\n---\n\n# 内置组件 {#built-in-components}\n\n:::info 组件注册和使用\n内置组件无需注册便可以直接在模板中使用。它们也支持 tree-shake：仅在使用时才会包含在构建中。\n\n在[渲染函数](/guide/extras/render-function)中使用它们时，需要显式导入。例如：\n\n```js\nimport { h, Transition } from 'vue'\n\nh(Transition, {\n  /* props */\n})\n```\n\n:::\n\n## `<Transition>` {#transition}\n\n为**单个**元素或组件提供动画过渡效果。\n\n- **Props**\n\n  ```ts\n  interface TransitionProps {\n    /**\n     * 用于自动生成过渡 CSS class 名。\n     * 例如 `name: 'fade'` 将自动扩展为 `.fade-enter`、\n     * `.fade-enter-active` 等。\n     */\n    name?: string\n    /**\n     * 是否应用 CSS 过渡 class。\n     * 默认：true\n     */\n    css?: boolean\n    /**\n     * 指定要等待的过渡事件类型\n     * 来确定过渡结束的时间。\n     * 默认情况下会自动检测\n     * 持续时间较长的类型。\n     */\n    type?: 'transition' | 'animation'\n    /**\n     * 显式指定过渡的持续时间。\n     * 默认情况下是等待过渡效果的根元素的第一个 `transitionend`\n     * 或`animationend`事件。\n     */\n    duration?: number | { enter: number; leave: number }\n    /**\n     * 控制离开/进入过渡的时序。\n     * 默认情况下是同时的。\n     */\n    mode?: 'in-out' | 'out-in' | 'default'\n    /**\n     * 是否对初始渲染使用过渡。\n     * 默认：false\n     */\n    appear?: boolean\n\n    /**\n     * 用于自定义过渡 class 的 prop。\n     * 在模板中使用短横线命名，例如：enter-from-class=\"xxx\"\n     */\n    enterFromClass?: string\n    enterActiveClass?: string\n    enterToClass?: string\n    appearFromClass?: string\n    appearActiveClass?: string\n    appearToClass?: string\n    leaveFromClass?: string\n    leaveActiveClass?: string\n    leaveToClass?: string\n  }\n  ```\n\n- **事件**\n\n  - `@before-enter`\n  - `@before-leave`\n  - `@enter`\n  - `@leave`\n  - `@appear`\n  - `@after-enter`\n  - `@after-leave`\n  - `@after-appear`\n  - `@enter-cancelled`\n  - `@leave-cancelled` (`v-show` only)\n  - `@appear-cancelled`\n\n- **示例**\n\n  简单元素：\n\n  ```vue-html\n  <Transition>\n    <div v-if=\"ok\">toggled content</div>\n  </Transition>\n  ```\n\n  通过改变 `key` 属性来强制过度执行：\n\n  ```vue-html\n  <Transition>\n    <div :key=\"text\">{{ text }}</div>\n  </Transition>\n  ```\n\n  动态组件，初始渲染时带有过渡模式 + 动画出现：\n\n  ```vue-html\n  <Transition name=\"fade\" mode=\"out-in\" appear>\n    <component :is=\"view\"></component>\n  </Transition>\n  ```\n\n  监听过渡事件：\n\n  ```vue-html\n  <Transition @after-enter=\"onTransitionComplete\">\n    <div v-show=\"ok\">toggled content</div>\n  </Transition>\n  ```\n\n- **参考**[指南 - `<Transition>`](/guide/built-ins/transition)\n\n## `<TransitionGroup>` {#transitiongroup}\n\n为列表中的**多个**元素或组件提供过渡效果。\n\n- **Props**\n\n  `<TransitionGroup>` 拥有与 `<Transition>` 除了 `mode` 以外所有的 props，并增加了两个额外的 props：\n\n  ```ts\n  interface TransitionGroupProps extends Omit<TransitionProps, 'mode'> {\n    /**\n     * 如果未定义，则渲染为片段 (fragment)。\n     */\n    tag?: string\n    /**\n     * 用于自定义过渡期间被应用的 CSS class。\n     * 在模板中使用 kebab-case，例如 move-class=\"xxx\"\n     */\n    moveClass?: string\n  }\n  ```\n\n- **事件**\n\n  `<TransitionGroup>` 抛出与 `<Transition>` 相同的事件。\n\n- **详细信息**\n\n  默认情况下，`<TransitionGroup>` 不会渲染一个容器 DOM 元素，但是可以通过 `tag` prop 启用。\n\n  注意，每个 `<transition-group>` 的子节点必须有[**独立的 key**](/guide/essentials/list#maintaining-state-with-key)，动画才能正常工作。\n\n  `<TransitionGroup>` 支持通过 CSS transform 控制移动效果。当一个子节点在屏幕上的位置在更新之后发生变化时，它会被添加一个使其位移的 CSS class (基于 `name` attribute 推导，或使用 `move-class` prop 显式配置)。如果使其位移的 class 被添加时 CSS 的 `transform` 属性是“可过渡的”，那么该元素会基于 [FLIP 技巧](https://aerotwist.com/blog/flip-your-animations/)平滑地到达动画终点。\n\n- **示例**\n\n  ```vue-html\n  <TransitionGroup tag=\"ul\" name=\"slide\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </TransitionGroup>\n  ```\n\n- **参考**[指南 - TransitionGroup](/guide/built-ins/transition-group)\n\n## `<KeepAlive>` {#keepalive}\n\n缓存包裹在其中的动态切换组件。\n\n- **Props**\n\n  ```ts\n  interface KeepAliveProps {\n    /**\n     * 如果指定，则只有与 `include` 名称\n     * 匹配的组件才会被缓存。\n     */\n    include?: MatchPattern\n    /**\n     * 任何名称与 `exclude`\n     * 匹配的组件都不会被缓存。\n     */\n    exclude?: MatchPattern\n    /**\n     * 最多可以缓存多少组件实例。\n     */\n    max?: number | string\n  }\n\n  type MatchPattern = string | RegExp | (string | RegExp)[]\n  ```\n\n- **详细信息**\n\n  `<KeepAlive>` 包裹动态组件时，会缓存不活跃的组件实例，而不是销毁它们。\n\n  任何时候都只能有一个活跃组件实例作为 `<KeepAlive>` 的直接子节点。\n\n  当一个组件在 `<KeepAlive>` 中被切换时，它的 `activated` 和 `deactivated` 生命周期钩子将被调用，用来替代 `mounted` 和 `unmounted`。这适用于 `<KeepAlive>` 的直接子节点及其所有子孙节点。\n\n- **示例**\n\n  基本用法：\n\n  ```vue-html\n  <KeepAlive>\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n\n  与 `v-if` / `v-else` 分支一起使用时，同一时间只能有一个组件被渲染：\n\n  ```vue-html\n  <KeepAlive>\n    <comp-a v-if=\"a > 1\"></comp-a>\n    <comp-b v-else></comp-b>\n  </KeepAlive>\n  ```\n\n  与 `<Transition>` 一起使用：\n\n  ```vue-html\n  <Transition>\n    <KeepAlive>\n      <component :is=\"view\"></component>\n    </KeepAlive>\n  </Transition>\n  ```\n\n  使用 `include` / `exclude`：\n\n  ```vue-html\n  <!-- 用逗号分隔的字符串 -->\n  <KeepAlive include=\"a,b\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n\n  <!-- 正则表达式 (使用 `v-bind`) -->\n  <KeepAlive :include=\"/a|b/\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n\n  <!-- 数组 (使用 `v-bind`) -->\n  <KeepAlive :include=\"['a', 'b']\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n\n  使用 `max`：\n\n  ```vue-html\n  <KeepAlive :max=\"10\">\n    <component :is=\"view\"></component>\n  </KeepAlive>\n  ```\n\n- **参考**[指南 - KeepAlive](/guide/built-ins/keep-alive)\n\n## `<Teleport>` {#teleport}\n\n将其插槽内容渲染到 DOM 中的另一个位置。\n\n- **Props**\n\n  ```ts\n  interface TeleportProps {\n    /**\n     * 必填项。指定目标容器。\n     * 可以是选择器或实际元素。\n     */\n    to: string | HTMLElement\n    /**\n     * 当值为 `true` 时，内容将保留在其原始位置\n     * 而不是移动到目标容器中。\n     * 可以动态更改。\n     */\n    disabled?: boolean\n    /**\n     * 当值为 `true` 时，Teleport 将推迟\n     * 直到应用的其他部分挂载后\n     * 再解析其目标。(3.5+)\n     */\n    defer?: boolean\n  }\n  ```\n\n- **示例**\n\n  指定目标容器：\n\n  ```vue-html\n  <Teleport to=\"#some-id\" />\n  <Teleport to=\".some-class\" />\n  <Teleport to=\"[data-teleport]\" />\n  ```\n\n  有条件地禁用：\n\n  ```vue-html\n  <Teleport to=\"#popup\" :disabled=\"displayVideoInline\">\n    <video src=\"./my-movie.mp4\">\n  </Teleport>\n  ```\n\n  延迟目标解析 <sup class=\"vt-badge\" data-text=\"3.5+\" />：\n\n  ```vue-html\n  <Teleport defer to=\"#late-div\">...</Teleport>\n\n  <!-- 稍后出现于模板中的某处 -->\n  <div id=\"late-div\"></div>\n  ```\n\n- **参考**[指南 - Teleport](/guide/built-ins/teleport)\n\n## `<Suspense>` <sup class=\"vt-badge experimental\" /> {#suspense}\n\n用于协调对组件树中嵌套的异步依赖的处理。\n\n- **Props**\n\n  ```ts\n  interface SuspenseProps {\n    timeout?: string | number\n    suspensible?: boolean\n  }\n  ```\n\n- **事件**\n\n  - `@resolve`\n  - `@pending`\n  - `@fallback`\n\n- **详细信息**\n\n  `<Suspense>` 接受两个插槽：`#default` 和 `#fallback`。它将在内存中渲染默认插槽的同时展示后备插槽内容。\n\n  如果在渲染时遇到异步依赖项 ([异步组件](/guide/components/async)和具有 [`async setup()`](/guide/built-ins/suspense#async-setup) 的组件)，它将等到所有异步依赖项解析完成时再显示默认插槽。\n\n  通过将 Suspense 设置为 `suspensible`，所有的异步依赖将由父级 Suspense 处理。请参阅[实现细节](https://github.com/vuejs/core/pull/6736)\n\n- **参考**[指南 - Suspense](/guide/built-ins/suspense)\n\n\n\n================================================\nFILE: src/api/built-in-directives.md\n================================================\n# 内置指令 {#built-in-directives}\n\n## v-text {#v-text}\n\n更新元素的文本内容。\n\n- **期望的绑定值类型：**`string`\n\n- **详细信息**\n\n  `v-text` 通过设置元素的 [textContent](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent) 属性来工作，因此它将覆盖元素中所有现有的内容。如果你需要更新 `textContent` 的部分，应该使用 [mustache interpolations](/guide/essentials/template-syntax#text-interpolation) 代替。\n\n- **示例**\n\n  ```vue-html\n  <span v-text=\"msg\"></span>\n  <!-- 等同于 -->\n  <span>{{msg}}</span>\n  ```\n\n- **参考**[模板语法 - 文本插值](/guide/essentials/template-syntax#text-interpolation)\n\n## v-html {#v-html}\n\n更新元素的 [innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)。\n\n- **期望的绑定值类型：**`string`\n\n- **详细信息**\n\n `v-html` 的内容直接作为普通 HTML 插入—— Vue 模板语法是不会被解析的。如果你发现自己正打算用 `v-html` 来编写模板，不如重新想想怎么使用组件来代替。\n\n ::: warning 安全说明\n 在你的站点上动态渲染任意的 HTML 是非常危险的，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**将用户提供的内容作为插值\n  :::\n\n 在[单文件组件](/guide/scaling-up/sfc)，`scoped` 样式将不会作用于 `v-html` 里的内容，因为 HTML 内容不会被 Vue 的模板编译器解析。如果你想让 `v-html` 的内容也支持 scoped CSS，你可以使用 [CSS modules](./sfc-css-features#css-modules) 或使用一个额外的全局 `<style>` 元素，手动设置类似 BEM 的作用域策略。\n\n- **示例**\n\n  ```vue-html\n  <div v-html=\"html\"></div>\n  ```\n\n- **参考**[模板语法 - 原始 HTML](/guide/essentials/template-syntax#raw-html)\n\n## v-show {#v-show}\n\n基于表达式值的真假性，来改变元素的可见性。\n\n- **期望的绑定值类型：**`any`\n\n- **详细信息**\n\n  `v-show` 通过设置内联样式的 `display` CSS 属性来工作，当元素可见时将使用初始 `display` 值。当条件改变时，也会触发过渡效果。\n\n- **参考**[条件渲染 - v-show](/guide/essentials/conditional#v-show)\n\n## v-if {#v-if}\n\n基于表达式值的真假性，来条件性地渲染元素或者模板片段。\n\n- **期望的绑定值类型：**`any`\n\n- **详细信息**\n\n  当 `v-if` 元素被触发，元素及其所包含的指令/组件都会销毁和重构。如果初始条件是假，那么其内部的内容根本都不会被渲染。\n\n  可用于 `<template>` 表示仅包含文本或多个元素的条件块。\n\n  当条件改变时会触发过渡效果。\n\n  当同时使用时，`v-if` 比 `v-for` 优先级更高。我们并不推荐在一元素上同时使用这两个指令 — 查看[列表渲染指南](/guide/essentials/list#v-for-with-v-if)详情。\n\n- **参考**[条件渲染 - v-if](/guide/essentials/conditional#v-if)\n\n## v-else {#v-else}\n\n表示 `v-if` 或 `v-if` / `v-else-if` 链式调用的“else 块”。\n\n- **无需传入表达式**\n\n- **详细信息**\n\n  - 限定：上一个兄弟元素必须有 `v-if` 或 `v-else-if`。\n\n  - 可用于 `<template>` 表示仅包含文本或多个元素的条件块。\n\n- **示例**\n\n  ```vue-html\n  <div v-if=\"Math.random() > 0.5\">\n    Now you see me\n  </div>\n  <div v-else>\n    Now you don't\n  </div>\n  ```\n\n- **参考**[条件渲染 - v-else](/guide/essentials/conditional#v-else)\n\n## v-else-if {#v-else-if}\n\n表示 `v-if` 的“else if 块”。可以进行链式调用。\n\n- **期望的绑定值类型：**`any`\n\n- **详细信息**\n\n  - 限定：上一个兄弟元素必须有 `v-if` 或 `v-else-if`。\n\n  - 可用于 `<template>` 表示仅包含文本或多个元素的条件块。\n\n- **示例**\n\n  ```vue-html\n  <div v-if=\"type === 'A'\">\n    A\n  </div>\n  <div v-else-if=\"type === 'B'\">\n    B\n  </div>\n  <div v-else-if=\"type === 'C'\">\n    C\n  </div>\n  <div v-else>\n    Not A/B/C\n  </div>\n  ```\n\n- **参考**[条件渲染 - v-else-if](/guide/essentials/conditional#v-else-if)\n\n## v-for {#v-for}\n\n基于原始数据多次渲染元素或模板块。\n\n- **期望的绑定值类型：**`Array | Object | number | string | Iterable`\n\n- **详细信息**\n\n  指令值必须使用特殊语法 `alias in expression` 为正在迭代的元素提供一个别名：\n\n  ```vue-html\n  <div v-for=\"item in items\">\n    {{ item.text }}\n  </div>\n  ```\n\n  或者，你也可以为索引指定别名 (如果用在对象，则是键值)：\n\n  ```vue-html\n  <div v-for=\"(item, index) in items\"></div>\n  <div v-for=\"(value, key) in object\"></div>\n  <div v-for=\"(value, name, index) in object\"></div>\n  ```\n\n  `v-for` 的默认方式是尝试就地更新元素而不移动它们。要强制其重新排序元素，你需要用特殊 attribute `key` 来提供一个排序提示：\n\n  ```vue-html\n  <div v-for=\"item in items\" :key=\"item.id\">\n    {{ item.text }}\n  </div>\n  ```\n\n  `v-for` 也可以用于 [Iterable Protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) 的实现，包括原生 `Map` 和 `Set`。\n\n- **参考**\n  - [列表渲染](/guide/essentials/list)\n\n## v-on {#v-on}\n\n给元素绑定事件监听器。\n\n- **缩写：**`@`\n\n- **期望的绑定值类型：**`Function | Inline Statement | Object (不带参数)`\n\n- **参数：**`event` (使用对象语法则为可选项)\n\n- **修饰符**\n\n  - `.stop` - 调用 `event.stopPropagation()`。\n  - `.prevent` - 调用 `event.preventDefault()`。\n  - `.capture` - 在捕获模式添加事件监听器。\n  - `.self` - 只有事件从元素本身发出才触发处理函数。\n  - `.{keyAlias}` - 只在某些按键下触发处理函数。\n  - `.once` - 最多触发一次处理函数。\n  - `.left` - 只在鼠标左键事件触发处理函数。\n  - `.right` - 只在鼠标右键事件触发处理函数。\n  - `.middle` - 只在鼠标中键事件触发处理函数。\n  - `.passive` - 通过 `{ passive: true }` 附加一个 DOM 事件。\n\n- **详细信息**\n\n  事件类型由参数来指定。表达式可以是一个方法名，一个内联声明，如果有修饰符则可省略。\n\n  当用于普通元素，只监听[**原生 DOM 事件**](https://developer.mozilla.org/en-US/docs/Web/Events)。当用于自定义元素组件，则监听子组件触发的**自定义事件**。\n\n  当监听原生 DOM 事件时，方法接收原生事件作为唯一参数。如果使用内联声明，声明可以访问一个特殊的 `$event` 变量：`v-on:click=\"handle('ok', $event)\"`。\n\n  `v-on` 还支持绑定不带参数的事件/监听器对的对象。请注意，当使用对象语法时，不支持任何修饰符。\n\n- **示例**\n\n  ```vue-html\n  <!-- 方法处理函数 -->\n  <button v-on:click=\"doThis\"></button>\n\n  <!-- 动态事件 -->\n  <button v-on:[event]=\"doThis\"></button>\n\n  <!-- 内联声明 -->\n  <button v-on:click=\"doThat('hello', $event)\"></button>\n\n  <!-- 缩写 -->\n  <button @click=\"doThis\"></button>\n\n  <!-- 使用缩写的动态事件 -->\n  <button @[event]=\"doThis\"></button>\n\n  <!-- 停止传播 -->\n  <button @click.stop=\"doThis\"></button>\n\n  <!-- 阻止默认事件 -->\n  <button @click.prevent=\"doThis\"></button>\n\n  <!-- 不带表达式地阻止默认事件 -->\n  <form @submit.prevent></form>\n\n  <!-- 链式调用修饰符 -->\n  <button @click.stop.prevent=\"doThis\"></button>\n\n  <!-- 按键用于 keyAlias 修饰符-->\n  <input @keyup.enter=\"onEnter\" />\n\n  <!-- 点击事件将最多触发一次 -->\n  <button v-on:click.once=\"doThis\"></button>\n\n  <!-- 对象语法 -->\n  <button v-on=\"{ mousedown: doThis, mouseup: doThat }\"></button>\n  ```\n\n  监听子组件的自定义事件 (当子组件的“my-event”事件被触发，处理函数将被调用)：\n\n  ```vue-html\n  <MyComponent @my-event=\"handleThis\" />\n\n  <!-- 内联声明 -->\n  <MyComponent @my-event=\"handleThis(123, $event)\" />\n  ```\n\n- **参考**\n  - [事件处理](/guide/essentials/event-handling)\n  - [组件 - 自定义事件](/guide/essentials/component-basics#listening-to-events)\n\n## v-bind {#v-bind}\n\n动态的绑定一个或多个 attribute，也可以是组件的 prop。\n\n- **缩写：**\n  - `:` 或者 `.` (当使用 `.prop` 修饰符)\n  - 值可以省略 (当 attribute 和绑定的值同名时，需要 3.4+ 版本)\n\n- **期望：**`any (带参数) | Object (不带参数)`\n\n- **参数：**`attrOrProp (可选的)`\n\n- **修饰符**\n\n  - `.camel` - 将短横线命名的 attribute 转变为驼峰式命名。\n  - `.prop` - 强制绑定为 DOM property (3.2+)。\n  - `.attr` - 强制绑定为 DOM attribute (3.2+)。\n\n- **用途**\n\n  当用于绑定 `class` 或 `style` attribute，`v-bind` 支持额外的值类型如数组或对象。详见下方的指南链接。\n\n  在处理绑定时，Vue 默认会利用 `in` 操作符来检查该元素上是否定义了和绑定的 key 同名的 DOM property。如果存在同名的 property，则 Vue 会将它作为 DOM property 赋值，而不是作为 attribute 设置。这个行为在大多数情况都符合期望的绑定值类型，但是你也可以显式用 `.prop` 和 `.attr` 修饰符来强制绑定方式。有时这是必要的，特别是在和[自定义元素](/guide/extras/web-components#passing-dom-properties)打交道时。\n\n  当用于组件 props 绑定时，所绑定的 props 必须在子组件中已被正确声明。\n\n  当不带参数使用时，可以用于绑定一个包含了多个 attribute 名称-绑定值对的对象。\n\n- **示例**\n\n  ```vue-html\n  <!-- 绑定 attribute -->\n  <img v-bind:src=\"imageSrc\" />\n\n  <!-- 动态 attribute 名 -->\n  <button v-bind:[key]=\"value\"></button>\n\n  <!-- 缩写 -->\n  <img :src=\"imageSrc\" />\n\n  <!-- 缩写形式的动态 attribute 名 (3.4+)，扩展为 :src=\"src\" -->\n  <img :src />\n\n  <!-- 动态 attribute 名的缩写 -->\n  <button :[key]=\"value\"></button>\n\n  <!-- 内联字符串拼接 -->\n  <img :src=\"'/path/to/images/' + fileName\" />\n\n  <!-- class 绑定 -->\n  <div :class=\"{ red: isRed }\"></div>\n  <div :class=\"[classA, classB]\"></div>\n  <div :class=\"[classA, { classB: isB, classC: isC }]\"></div>\n\n  <!-- style 绑定 -->\n  <div :style=\"{ fontSize: size + 'px' }\"></div>\n  <div :style=\"[styleObjectA, styleObjectB]\"></div>\n\n  <!-- 绑定对象形式的 attribute -->\n  <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n\n  <!-- prop 绑定。“prop” 必须在子组件中已声明。 -->\n  <MyComponent :prop=\"someThing\" />\n\n  <!-- 传递子父组件共有的 prop -->\n  <MyComponent v-bind=\"$props\" />\n\n  <!-- XLink -->\n  <svg><a :xlink:special=\"foo\"></a></svg>\n  ```\n\n  `.prop` 修饰符也有专门的缩写，`.`：\n\n  ```vue-html\n  <div :someProperty.prop=\"someObject\"></div>\n\n  <!-- 等同于 -->\n  <div .someProperty=\"someObject\"></div>\n  ```\n\n  当在 DOM 内模板使用 `.camel` 修饰符，可以驼峰化 `v-bind` attribute 的名称，例如 SVG `viewBox` attribute：\n\n  ```vue-html\n  <svg :view-box.camel=\"viewBox\"></svg>\n  ```\n\n  如果使用字符串模板或使用构建步骤预编译模板，则不需要 `.camel`。\n\n- **参考**\n  - [Class 与 Style 绑定](/guide/essentials/class-and-style)\n  - [组件 -  Prop 传递细节](/guide/components/props#prop-passing-details)\n\n## v-model {#v-model}\n\n在表单输入元素或组件上创建双向绑定。\n\n- **期望的绑定值类型**：根据表单输入元素或组件输出的值而变化\n\n- **仅限：**\n\n  - `<input>`\n  - `<select>`\n  - `<textarea>`\n  - components\n\n- **修饰符**\n\n  - [`.lazy`](/guide/essentials/forms#lazy) - 监听 `change` 事件而不是 `input`\n  - [`.number`](/guide/essentials/forms#number) - 将输入的合法字符串转为数字\n  - [`.trim`](/guide/essentials/forms#trim) - 移除输入内容两端空格\n\n- **参考**\n\n  - [表单输入绑定](/guide/essentials/forms)\n  - [组件事件 - 配合 `v-model` 使用](/guide/components/v-model)\n\n## v-slot {#v-slot}\n\n用于声明具名插槽或是期望接收 props 的作用域插槽。\n\n- **缩写：**`#`\n\n- **期望的绑定值类型**：能够合法在函数参数位置使用的 JavaScript 表达式。支持解构语法。绑定值是可选的——只有在给作用域插槽传递 props 才需要。\n\n- **参数**：插槽名 (可选，默认是 `default`)\n\n- **仅限：**\n\n  - `<template>`\n  - [components](/guide/components/slots#scoped-slots) (用于带有 prop 的单个默认插槽)\n\n- **示例**\n\n  ```vue-html\n  <!-- 具名插槽 -->\n  <BaseLayout>\n    <template v-slot:header>\n      Header content\n    </template>\n\n    <template v-slot:default>\n      Default slot content\n    </template>\n\n    <template v-slot:footer>\n      Footer content\n    </template>\n  </BaseLayout>\n\n  <!-- 接收 prop 的具名插槽 -->\n  <InfiniteScroll>\n    <template v-slot:item=\"slotProps\">\n      <div class=\"item\">\n        {{ slotProps.item.text }}\n      </div>\n    </template>\n  </InfiniteScroll>\n\n  <!-- 接收 prop 的默认插槽，并解构 -->\n  <Mouse v-slot=\"{ x, y }\">\n    Mouse position: {{ x }}, {{ y }}\n  </Mouse>\n  ```\n\n- **参考**\n  - [组件 - 插槽](/guide/components/slots)\n\n## v-pre {#v-pre}\n\n跳过该元素及其所有子元素的编译。\n\n- **无需传入**\n\n- **详细信息**\n\n  元素内具有 `v-pre`，所有 Vue 模板语法都会被保留并按原样渲染。最常见的用例就是显示原始双大括号标签及内容。\n\n- **示例**\n\n  ```vue-html\n  <span v-pre>{{ this will not be compiled }}</span>\n  ```\n\n## v-once {#v-once}\n\n仅渲染元素和组件一次，并跳过之后的更新。\n\n- **无需传入**\n\n- **详细信息**\n\n  在随后的重新渲染，元素/组件及其所有子项将被当作静态内容并跳过渲染。这可以用来优化更新时的性能。\n\n  ```vue-html\n  <!-- 单个元素 -->\n  <span v-once>This will never change: {{msg}}</span>\n  <!-- 带有子元素的元素 -->\n  <div v-once>\n    <h1>Comment</h1>\n    <p>{{msg}}</p>\n  </div>\n  <!-- 组件 -->\n  <MyComponent v-once :comment=\"msg\" />\n  <!-- `v-for` 指令 -->\n  <ul>\n    <li v-for=\"i in list\" v-once>{{i}}</li>\n  </ul>\n  ```\n\n  从 3.2 起，你也可以搭配 [`v-memo`](#v-memo) 的无效条件来缓存部分模板。\n\n- **参考**\n  - [数据绑定语法 - 插值](/guide/essentials/template-syntax#text-interpolation)\n  - [v-memo](#v-memo)\n\n## v-memo {#v-memo}\n\n- 仅在 3.2+ 中支持\n\n- **期望的绑定值类型：**`any[]`\n\n- **详细信息**\n\n  缓存一个模板的子树。在元素和组件上都可以使用。为了实现缓存，该指令需要传入一个固定长度的依赖值数组进行比较。如果数组里的每个值都与最后一次的渲染相同，那么整个子树的更新将被跳过。举例来说：\n\n  ```vue-html\n  <div v-memo=\"[valueA, valueB]\">\n    ...\n  </div>\n  ```\n\n  当组件重新渲染，如果 `valueA` 和 `valueB` 都保持不变，这个 `<div>` 及其子项的所有更新都将被跳过。实际上，甚至虚拟 DOM 的 vnode 创建也将被跳过，因为缓存的子树副本可以被重新使用。\n\n  正确指定缓存数组很重要，否则应该生效的更新可能被跳过。`v-memo` 传入空依赖数组 (`v-memo=\"[]\"`) 将与 `v-once` 效果相同。\n\n  **与 `v-for` 一起使用**\n\n  `v-memo` 仅用于性能至上场景中的微小优化，应该很少需要。最常见的情况可能是有助于渲染海量 `v-for` 列表 (长度超过 1000 的情况)：\n\n  ```vue-html\n  <div v-for=\"item in list\" :key=\"item.id\" v-memo=\"[item.id === selected]\">\n    <p>ID: {{ item.id }} - selected: {{ item.id === selected }}</p>\n    <p>...more child nodes</p>\n  </div>\n  ```\n\n  当组件的 `selected` 状态改变，默认会重新创建大量的 vnode，尽管绝大部分都跟之前是一模一样的。`v-memo` 用在这里本质上是在说“只有当该项的被选中状态改变时才需要更新”。这使得每个选中状态没有变的项能完全重用之前的 vnode 并跳过差异比较。注意这里 memo 依赖数组中并不需要包含 `item.id`，因为 Vue 也会根据 item 的 `:key` 进行判断。\n\n  :::warning 警告\n  当搭配 `v-for` 使用 `v-memo`，确保两者都绑定在同一个元素上。**`v-memo` 不能用在 `v-for` 内部。**\n  :::\n\n  `v-memo` 也能被用于在一些默认优化失败的边际情况下，手动避免子组件出现不需要的更新。但是一样的，开发者需要负责指定正确的依赖数组以免跳过必要的更新。\n\n- **参考**\n  - [v-once](#v-once)\n\n## v-cloak {#v-cloak}\n\n用于隐藏尚未完成编译的 DOM 模板。\n\n- **无需传入**\n\n- **详细信息**\n\n  **该指令只在没有构建步骤的环境下需要使用。**\n\n  当使用直接在 DOM 中书写的模板时，可能会出现一种叫做“未编译模板闪现”的情况：用户可能先看到的是还没编译完成的双大括号标签，直到挂载的组件将它们替换为实际渲染的内容。\n\n  `v-cloak` 会保留在所绑定的元素上，直到相关组件实例被挂载后才移除。配合像 `[v-cloak] { display: none }` 这样的 CSS 规则，它可以在组件编译完毕前隐藏原始模板。\n\n- **示例**\n\n  ```css\n  [v-cloak] {\n    display: none;\n  }\n  ```\n\n  ```vue-html\n  <div v-cloak>\n    {{ message }}\n  </div>\n  ```\n\n  直到编译完成前，`<div>` 将不可见。\n\n\n\n================================================\nFILE: src/api/built-in-special-attributes.md\n================================================\n# 内置的特殊 Attributes {#built-in-special-attributes}\n\n## key {#key}\n\n`key` 这个特殊的 attribute 主要作为 Vue 的虚拟 DOM 算法提示，在比较新旧节点列表时用于识别 vnode。\n\n- **预期**：`number | string | symbol`\n\n- **详细信息**\n\n  在没有 key 的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新/复用相同类型的元素。如果传了 key，则将根据 key 的变化顺序来重新排列元素，并且将始终移除/销毁 key 已经不存在的元素。\n\n  同一个父元素下的子元素必须具有**唯一的 key**。重复的 key 将会导致渲染异常。\n\n  最常见的用例是与 `v-for` 结合：\n\n  ```vue-html\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">...</li>\n  </ul>\n  ```\n\n  也可以用于强制替换一个元素/组件而不是复用它。当你想这么做时它可能会很有用：\n\n  - 在适当的时候触发组件的生命周期钩子\n  - 触发过渡\n\n  举例来说：\n\n  ```vue-html\n  <transition>\n    <span :key=\"text\">{{ text }}</span>\n  </transition>\n  ```\n\n  当 `text` 变化时，`<span>` 总是会被替换而不是更新，因此 transition 将会被触发。\n\n- **参考**[指南 - 列表渲染 - 通过 `key` 管理状态](/guide/essentials/list#maintaining-state-with-key)\n\n## ref {#ref}\n\n用于注册[模板引用](/guide/essentials/template-refs)。\n\n- **预期**：`string | Function`\n\n- **详细信息**\n\n  `ref` 用于注册元素或子组件的引用。\n\n  使用选项式 API，引用将被注册在组件的 `this.$refs` 对象里：\n\n  ```vue-html\n  <!-- 存储为 this.$refs.p -->\n  <p ref=\"p\">hello</p>\n  ```\n\n  使用组合式 API，引用将存储在与名字匹配的 ref 里：\n\n  ```vue\n  <script setup>\n  import { useTemplateRef } from 'vue'\n\n  const pRef = useTemplateRef('p')\n  </script>\n\n  <template>\n    <p ref=\"p\">hello</p>\n  </template>\n  ```\n\n  如果用于普通 DOM 元素，引用将是元素本身；如果用于子组件，引用将是子组件的实例。\n\n  或者 `ref` 可以接收一个函数值，用于对存储引用位置的完全控制：\n\n  ```vue-html\n  <ChildComponent :ref=\"(el) => child = el\" />\n  ```\n\n  关于 ref 注册时机的重要说明：因为 ref 本身是作为渲染函数的结果来创建的，必须等待组件挂载后才能对它进行访问。\n\n  `this.$refs` 也是非响应式的，因此你不应该尝试在模板中使用它来进行数据绑定。\n\n- **参考**\n  - [指南 - 模板引用](/guide/essentials/template-refs)\n  - [指南 - 为模板引用标注类型](/guide/typescript/composition-api#typing-template-refs) <sup class=\"vt-badge ts\" />\n  - [指南 - 为组件模板引用标注类型](/guide/typescript/composition-api#typing-component-template-refs) <sup class=\"vt-badge ts\" />\n\n## is {#is}\n\n用于绑定[动态组件](/guide/essentials/component-basics#dynamic-components)。\n\n- **预期**：`string | Component`\n\n- **用于原生元素**\n\n  - 仅在 3.1+ 中支持\n\n  当 `is` attribute 用于原生 HTML 元素时，它将被当作 [Customized built-in element](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example)，其为原生 web 平台的特性。\n\n  但是，在这种用例中，你可能需要 Vue 用其组件来替换原生元素，如 [DOM 内模板解析注意事项](/guide/essentials/component-basics#in-dom-template-parsing-caveats)所述。你可以在 `is` attribute 的值中加上 `vue:` 前缀，这样 Vue 就会把该元素渲染为 Vue 组件：\n\n  ```vue-html\n  <table>\n    <tr is=\"vue:my-row-component\"></tr>\n  </table>\n  ```\n\n- **参考**\n\n  - [内置特殊元素 - `<component>`](/api/built-in-special-elements#component)\n  - [动态组件](/guide/essentials/component-basics#dynamic-components)\n\n\n\n================================================\nFILE: src/api/built-in-special-elements.md\n================================================\n# 内置特殊元素 {#built-in-special-elements}\n\n:::info 不是组件\n`<component>`、`<slot>` 和 `<template>` 具有类似组件的特性，也是模板语法的一部分。但它们并非真正的组件，同时在模板编译期间会被编译掉。因此，它们通常在模板中用小写字母书写。\n:::\n\n## `<component>` {#component}\n\n一个用于渲染动态组件或元素的“元组件”。\n\n- **Props**\n\n  ```ts\n  interface DynamicComponentProps {\n    is: string | Component\n  }\n  ```\n\n- **详细信息**\n\n  要渲染的实际组件由 `is` prop 决定。\n\n  - 当 `is` 是字符串，它既可以是 HTML 标签名也可以是组件的注册名。\n\n  - 或者，`is` 也可以直接绑定到组件的定义。\n\n- **示例**\n\n  按注册名渲染组件 (选项式 API)：\n\n  ```vue\n  <script>\n  import Foo from './Foo.vue'\n  import Bar from './Bar.vue'\n\n  export default {\n    components: { Foo, Bar },\n    data() {\n      return {\n        view: 'Foo'\n      }\n    }\n  }\n  </script>\n\n  <template>\n    <component :is=\"view\" />\n  </template>\n  ```\n\n  按定义渲染组件 (`<script setup>` 组合式 API)：\n\n  ```vue\n  <script setup>\n  import Foo from './Foo.vue'\n  import Bar from './Bar.vue'\n  </script>\n\n  <template>\n    <component :is=\"Math.random() > 0.5 ? Foo : Bar\" />\n  </template>\n  ```\n\n  渲染 HTML 元素：\n\n  ```vue-html\n  <component :is=\"href ? 'a' : 'span'\"></component>\n  ```\n\n  [内置组件](./built-in-components)都可以传递给 `is`，但是如果想通过名称传递则必须先对其进行注册。举例来说：\n\n  ```vue\n  <script>\n  import { Transition, TransitionGroup } from 'vue'\n\n  export default {\n    components: {\n      Transition,\n      TransitionGroup\n    }\n  }\n  </script>\n\n  <template>\n    <component :is=\"isGroup ? 'TransitionGroup' : 'Transition'\">\n      ...\n    </component>\n  </template>\n  ```\n\n  如果将组件本身传递给 `is` 而不是其名称，则不需要注册，例如在 `<script setup>` 中。\n\n  如果在 `<component>` 标签上使用 `v-model`，模板编译器会将其扩展为 `modelValue` prop 和 `update:modelValue` 事件监听器，就像对任何其他组件一样。但是，这与原生 HTML 元素不兼容，例如 `<input>` 或 `<select>`。因此，在动态创建的原生元素上使用 `v-model` 将不起作用：\n\n  ```vue\n  <script setup>\n  import { ref } from 'vue'\n\n  const tag = ref('input')\n  const username = ref('')\n  </script>\n\n  <template>\n    <!-- 由于 'input' 是原生 HTML 元素，因此这个 v-model 不起作用 -->\n    <component :is=\"tag\" v-model=\"username\" />\n  </template>\n  ```\n\n  在实践中，这种极端情况并不常见，因为原生表单字段通常包裹在实际应用的组件中。如果确实需要直接使用原生元素，那么你可以手动将 `v-model` 拆分为 attribute 和事件。\n\n- **参考**[动态组件](/guide/essentials/component-basics#dynamic-components)\n\n## `<slot>` {#slot}\n\n表示模板中的插槽内容出口。\n\n- **Props**\n\n  ```ts\n  interface SlotProps {\n    /**\n     * 任何传递给 <slot> 的 prop 都可以作为作用域插槽\n     * 的参数传递\n     */\n    [key: string]: any\n    /**\n     * 保留，用于指定插槽名。\n     */\n    name?: string\n  }\n  ```\n\n- **详细信息**\n\n  `<slot>` 元素可以使用 `name` attribute 来指定插槽名。当没有指定 `name` 时，将会渲染默认插槽。传递给插槽元素的附加 attributes 将作为插槽 props，传递给父级中定义的作用域插槽。\n\n  元素本身将被其所匹配的插槽内容替换。\n\n  Vue 模板里的 `<slot>` 元素会被编译到 JavaScript，因此不要与[原生 `<slot>` 元素](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot)进行混淆。\n\n- **参考**[组件 - 插槽](/guide/components/slots)\n\n## `<template>` {#template}\n\n当我们想要使用内置指令而不在 DOM 中渲染元素时，`<template>` 标签可以作为占位符使用。\n\n- **详细信息**\n\n  对 `<template>` 的特殊处理只有在它与以下任一指令一起使用时才会被触发：\n\n  - `v-if`、`v-else-if` 或 `v-else`\n  - `v-for`\n  - `v-slot`\n\n  如果这些指令都不存在，那么它将被渲染成一个[原生的 `<template>` 元素](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template)。\n\n  带有 `v-for` 的 `<template>` 也可以有一个 [`key` 属性](/api/built-in-special-attributes#key)。所有其他的属性和指令都将被丢弃，因为没有相应的元素，它们就没有意义。\n\n  单文件组件使用[顶层的 `<template>` 标签](/api/sfc-spec#language-blocks)来包裹整个模板。这种用法与上面描述的 `<template>` 使用方式是有区别的。该顶层标签不是模板本身的一部分，不支持指令等模板语法。\n\n- **参考**\n  - [指南 - `<template>` 上的 `v-if`](/guide/essentials/conditional#v-if-on-template)\n  - [指南 - `<template>` 上的 `v-for`](/guide/essentials/list#v-for-on-template)\n  - [指南 - 具名插槽](/guide/components/slots#named-slots)\n\n\n\n================================================\nFILE: src/api/compile-time-flags.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/api/component-instance.md\n================================================\n# 组件实例 {#component-instance}\n\n:::info\n本页文档描述了组件公共实例 (即 `this`) 上暴露的内置属性和方法，\n\n本页罗列的所有属性，除了 `$data` 下的嵌套属性之外，都是只读的。\n:::\n\n## $data {#data}\n\n从 [`data`](./options-state#data) 选项函数中返回的对象，会被组件赋为响应式。组件实例将会代理对其数据对象的属性访问。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $data: object\n  }\n  ```\n\n## $props {#props}\n\n表示组件当前已解析的 props 对象。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $props: object\n  }\n  ```\n\n- **详细信息**\n\n  这里只包含通过 [`props`](./options-state#props) 选项声明的 props。组件实例将会代理对其 props 对象上属性的访问。\n\n## $el {#el}\n\n该组件实例管理的 DOM 根节点。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $el: any\n  }\n  ```\n\n- **详细信息**\n\n  `$el` 直到组件[挂载完成 (mounted)](./options-lifecycle#mounted) 之前都会是 `undefined`。\n\n  - 对于单一根元素的组件，`$el` 将会指向该根元素。\n  - 对于以文本节点为根的组件，`$el` 将会指向该文本节点。\n  - 对于以多个元素为根的组件，`$el` 将是一个仅作占位符的 DOM 节点，Vue 使用它来跟踪组件在 DOM 中的位置 (文本节点或 SSR 激活模式下的注释节点)。\n\n  :::tip\n  为保持一致性，我们推荐使用[模板引用](/guide/essentials/template-refs)来直接访问元素而不是依赖 `$el`。\n  :::\n\n## $options {#options}\n\n已解析的用于实例化当前组件的组件选项。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $options: ComponentOptions\n  }\n  ```\n\n- **详细信息**\n\n  这个 `$options` 对象暴露了当前组件的已解析选项，并且会是以下几种可能来源的合并结果：\n\n  - 全局 mixin\n  - 组件 `extends` 的基组件\n  - 组件级 mixin\n\n  它通常用于支持自定义组件选项：\n\n  ```js\n  const app = createApp({\n    customOption: 'foo',\n    created() {\n      console.log(this.$options.customOption) // => 'foo'\n    }\n  })\n  ```\n\n- **参考** [`app.config.optionMergeStrategies`](/api/application#app-config-optionmergestrategies)\n\n## $parent {#parent}\n\n当前组件可能存在的父组件实例，如果当前组件是顶层组件，则为 `null`。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $parent: ComponentPublicInstance | null\n  }\n  ```\n\n## $root {#root}\n\n当前组件树的根组件实例。如果当前实例没有父组件，那么这个值就是它自己。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $root: ComponentPublicInstance\n  }\n  ```\n\n## $slots {#slots}\n\n一个表示父组件所传入[插槽](/guide/components/slots)的对象。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $slots: { [name: string]: Slot }\n  }\n\n  type Slot = (...args: any[]) => VNode[]\n  ```\n\n- **详细信息**\n\n  通常用于手写[渲染函数](/guide/extras/render-function)，但也可用于检测是否存在插槽。\n\n  每一个插槽都在 `this.$slots` 上暴露为一个函数，返回一个 vnode 数组，同时 key 名对应着插槽名。默认插槽暴露为 `this.$slots.default`。\n\n  如果插槽是一个[作用域插槽](/guide/components/slots#scoped-slots)，传递给该插槽函数的参数可以作为插槽的 prop 提供给插槽。\n\n- **参考**[渲染函数 - 渲染插槽](/guide/extras/render-function#rendering-slots)\n\n## $refs {#refs}\n\n一个包含 DOM 元素和组件实例的对象，通过[模板引用](/guide/essentials/template-refs)注册。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $refs: { [name: string]: Element | ComponentPublicInstance | null }\n  }\n  ```\n\n- **参考**\n\n  - [模板引用](/guide/essentials/template-refs)\n  - [特殊 Attribute - ref](./built-in-special-attributes.md#ref)\n\n## $attrs {#attrs}\n\n一个包含了组件所有透传 attributes 的对象。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $attrs: object\n  }\n  ```\n\n- **详细信息**\n\n  [透传 Attributes](/guide/components/attrs) 是指由父组件传入，且没有被子组件声明为 props 或是组件自定义事件的 attributes 和事件处理函数。\n\n  默认情况下，若是单一根节点组件，`$attrs` 中的所有属性都是直接自动继承自组件的根元素。而多根节点组件则不会如此，同时你也可以通过配置 [`inheritAttrs`](./options-misc#inheritattrs) 选项来显式地关闭该行为。\n\n- **参考**\n\n  - [透传 Attribute](/guide/components/attrs)\n\n## $watch() {#watch}\n\n用于命令式地创建侦听器的 API。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $watch(\n      source: string | (() => any),\n      callback: WatchCallback,\n      options?: WatchOptions\n    ): StopHandle\n  }\n\n  type WatchCallback<T> = (\n    value: T,\n    oldValue: T,\n    onCleanup: (cleanupFn: () => void) => void\n  ) => void\n\n  interface WatchOptions {\n    immediate?: boolean // default: false\n    deep?: boolean // default: false\n    flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n    onTrack?: (event: DebuggerEvent) => void\n    onTrigger?: (event: DebuggerEvent) => void\n  }\n\n  type StopHandle = () => void\n  ```\n\n- **详细信息**\n\n  第一个参数是侦听来源。可以是一个组件的属性名的字符串，一个简单的由点分隔的路径字符串，或是一个 [getter 函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description)。\n\n  第二个参数是回调函数。它接收的参数分别是侦听来源的新值、旧值。\n\n  - **`immediate`**：指定在侦听器创建时是否立即触发回调。在第一次调用时旧值为 `undefined`。\n  - **`deep`**：指定在侦听来源是一个对象时，是否强制深度遍历，这样回调函数就会在深层级发生变更时被触发。详见[深层侦听器](/guide/essentials/watchers#deep-watchers)。\n  - **`flush`**：指定回调函数的刷新时机。详见[回调刷新时机](/guide/essentials/watchers#callback-flush-timing)及 [`watchEffect()`](/api/reactivity-core#watcheffect)。\n  - **`onTrack / onTrigger`**：调试侦听器的依赖，详见[侦听器调试](/guide/extras/reactivity-in-depth#watcher-debugging)。\n\n- **示例**\n\n  侦听一个属性名：\n\n  ```js\n  this.$watch('a', (newVal, oldVal) => {})\n  ```\n\n  侦听一个由 `.` 分隔的路径：\n\n  ```js\n  this.$watch('a.b', (newVal, oldVal) => {})\n  ```\n\n  对更复杂表达式使用 getter 函数：\n\n  ```js\n  this.$watch(\n    // 每一次这个 `this.a + this.b` 表达式生成一个\n    // 不同的结果，处理函数都会被调用\n    // 这就好像我们在侦听一个计算属性\n    // 而不定义计算属性本身。\n    () => this.a + this.b,\n    (newVal, oldVal) => {}\n  )\n  ```\n\n  停止该侦听器：\n\n  ```js\n  const unwatch = this.$watch('a', cb)\n\n  // 之后……\n  unwatch()\n  ```\n\n- **参考**\n  - [选项 - `watch`](/api/options-state#watch)\n  - [指南 - 侦听器](/guide/essentials/watchers)\n\n## $emit() {#emit}\n\n在当前组件触发一个自定义事件。任何额外的参数都会传递给事件监听器的回调函数。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $emit(event: string, ...args: any[]): void\n  }\n  ```\n\n- **示例**\n\n  ```js\n  export default {\n    created() {\n      // 仅触发事件\n      this.$emit('foo')\n      // 带有额外的参数\n      this.$emit('bar', 1, 2, 3)\n    }\n  }\n  ```\n\n- **参考**\n\n  - [组件 - 事件](/guide/components/events)\n  - [`emits` 选项](./options-state#emits)\n\n## $forceUpdate() {#forceupdate}\n\n强制该组件重新渲染。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $forceUpdate(): void\n  }\n  ```\n\n- **详细信息**\n\n  鉴于 Vue 的全自动响应性系统，这个功能应该很少会被用到。唯一可能需要它的情况是，你使用高阶响应式 API 显式创建了一个非响应式的组件状态。\n\n## $nextTick() {#nexttick}\n\n绑定在实例上的 [`nextTick()`](./general#nexttick) 函数。\n\n- **类型**\n\n  ```ts\n  interface ComponentPublicInstance {\n    $nextTick(callback?: (this: ComponentPublicInstance) => void): Promise<void>\n  }\n  ```\n\n- **详细信息**\n\n  和全局版本的 `nextTick()` 的唯一区别就是组件传递给 `this.$nextTick()` 的回调函数会带上 `this` 上下文，其绑定了当前组件实例。\n\n- **参考** [`nextTick()`](./general#nexttick)\n\n\n\n================================================\nFILE: src/api/composition-api-dependency-injection.md\n================================================\n# 组合式 API：依赖注入 {#composition-api-dependency-injection}\n\n## provide() {#provide}\n\n提供一个值，可以被后代组件注入。\n\n- **类型**\n\n  ```ts\n  function provide<T>(key: InjectionKey<T> | string, value: T): void\n  ```\n\n- **详细信息**\n\n  `provide()` 接受两个参数：第一个参数是要注入的 key，可以是一个字符串或者一个 symbol，第二个参数是要注入的值。\n\n  当使用 TypeScript 时，key 可以是一个被类型断言为 `InjectionKey` 的 symbol。`InjectionKey` 是一个 Vue 提供的工具类型，继承自 `Symbol`，可以用来同步 `provide()` 和 `inject()` 之间值的类型。\n\n  与注册生命周期钩子的 API 类似，`provide()` 必须在组件的 `setup()` 阶段同步调用。\n\n- **示例**\n\n  ```vue\n  <script setup>\n  import { ref, provide } from 'vue'\n  import { countSymbol } from './injectionSymbols'\n\n  // 提供静态值\n  provide('path', '/project/')\n\n  // 提供响应式的值\n  const count = ref(0)\n  provide('count', count)\n\n  // 提供时将 Symbol 作为 key\n  provide(countSymbol, count)\n  </script>\n  ```\n\n- **参考**\n  - [指南 - 依赖注入](/guide/components/provide-inject)\n  - [指南 - 为 provide/inject 标注类型](/guide/typescript/composition-api#typing-provide-inject) <sup class=\"vt-badge ts\" />\n\n## inject() {#inject}\n\n注入一个由祖先组件或整个应用 (通过 `app.provide()`) 提供的值。\n\n- **类型**\n\n  ```ts\n  // 没有默认值\n  function inject<T>(key: InjectionKey<T> | string): T | undefined\n\n  // 带有默认值\n  function inject<T>(key: InjectionKey<T> | string, defaultValue: T): T\n\n  // 使用工厂函数\n  function inject<T>(\n    key: InjectionKey<T> | string,\n    defaultValue: () => T,\n    treatDefaultAsFactory: true\n  ): T\n  ```\n\n- **详细信息**\n\n  第一个参数是注入的 key。Vue 会遍历父组件链，通过匹配 key 来确定所提供的值。如果父组件链上多个组件对同一个 key 提供了值，则会应用离得更近的组件所提供的值，链上更远的组件所提供的值将会被“覆盖”。如果没有能通过 key 匹配到值，`inject()` 将返回 `undefined`，除非提供了一个默认值。\n\n  第二个参数是可选的，即在没有匹配到 key 时使用的默认值。\n\n  第二个参数也可以是一个工厂函数，用来返回某些创建起来比较复杂的值。在这种情况下，你必须将 `true` 作为第三个参数传入，表明这个函数将作为工厂函数使用，而非值本身。\n\n  与注册生命周期钩子的 API 类似，`inject()` 必须在组件的 `setup()` 阶段同步调用。\n\n  当使用 TypeScript 时，key 可以是一个类型为 `InjectionKey` 的 symbol。`InjectionKey` 是一个 Vue 提供的工具类型，继承自 `Symbol`，可以用来同步 `provide()` 和 `inject()` 之间值的类型。\n\n- **示例**\n\n  假设有一个父组件已经提供了一些值，如前面 `provide()` 的例子中所示：\n\n  ```vue\n  <script setup>\n  import { inject } from 'vue'\n  import { countSymbol } from './injectionSymbols'\n\n  // 注入不含默认值的静态值\n  const path = inject('path')\n\n  // 注入响应式的值\n  const count = inject('count')\n\n  // 通过 Symbol 类型的 key 注入\n  const count2 = inject(countSymbol)\n\n  // 注入一个值，若为空则使用提供的默认值\n  const bar = inject('path', '/default-path')\n\n  // 注入一个值，若为空则使用提供的函数类型的默认值\n  const fn = inject('function', () => {})\n\n  // 注入一个值，若为空则使用提供的工厂函数\n  const baz = inject('factory', () => new ExpensiveObject(), true)\n  </script>\n  ```\n  \n- **参考**\n  - [指南 - 依赖注入](/guide/components/provide-inject)\n  - [指南 - 为 provide / inject 标注类型](/guide/typescript/composition-api#typing-provide-inject) <sup class=\"vt-badge ts\" />\n\n## hasInjectionContext() {#has-injection-context}\n\n- 仅在 3.3+ 中支持\n\n如果 [inject()](#inject) 可以在错误的地方 (例如 `setup()` 之外) 被调用而不触发警告，则返回 `true`。此方法适用于希望在内部使用 `inject()` 而不向用户发出警告的库。\n\n- **类型**\n\n  ```ts\n  function hasInjectionContext(): boolean\n  ```\n\n\n\n================================================\nFILE: src/api/composition-api-helpers.md\n================================================\n# 组合式 API：辅助 {#composition-api-helpers}\n\n## useAttrs() {#useattrs}\n\n从 [Setup 上下文](/api/composition-api-setup#setup-context)中返回 `attrs` 对象，其中包含当前组件的[透传 attributes](/guide/components/attrs#fallthrough-attributes)。这是用于 `<script setup>` 中的，因为在 `<script setup>` 中无法获取 setup 上下文对象。\n\n- **类型**\n\n  ```ts\n  function useAttrs(): Record<string, unknown>\n  ```\n\n## useSlots() {#useslots}\n\n从 [Setup 上下文](/api/composition-api-setup#setup-context)中返回 `slots` 对象，其中包含父组件传递的插槽。这些插槽为可调用的函数，返回虚拟 DOM 节点。这是用于 `<script setup>` 中的，因为在 `<script setup>` 中无法获取 setup 上下文对象。\n\n如果使用 TypeScript，建议优先使用 [`defineSlots()`](/api/sfc-script-setup#defineslots)。\n\n- **类型**\n\n  ```ts\n  function useSlots(): Record<string, (...args: any[]) => VNode[]>\n  ```\n\n## useModel() {#usemodel}\n\n这是驱动 [`defineModel()`](/api/sfc-script-setup#definemodel) 的底层辅助函数。如果使用 `<script setup>`，应当优先使用 `defineModel()`。\n\n- 仅在 3.4+ 版本中可用\n\n- **类型**\n\n  ```ts\n  function useModel(\n    props: Record<string, any>,\n    key: string,\n    options?: DefineModelOptions\n  ): ModelRef\n\n  type DefineModelOptions<T = any> = {\n    get?: (v: T) => any\n    set?: (v: T) => any\n  }\n\n  type ModelRef<T, M extends PropertyKey = string, G = T, S = T> = Ref<G, S> & [\n    ModelRef<T, M, G, S>,\n    Record<M, true | undefined>\n  ]\n  ```\n\n- **示例**\n\n  ```js\n  export default {\n    props: ['count'],\n    emits: ['update:count'],\n    setup(props) {\n      const msg = useModel(props, 'count')\n      msg.value = 1\n    }\n  }\n  ```\n\n- **详细信息**\n\n  `useModel()` 可以用于非单文件组件，例如在使用原始的 `setup()` 函数时。它预期的第一个参数是 `props` 对象，第二个参数是 model 名称。可选的第三个参数可以用于为生成的 model ref 声明自定义的 getter 和 setter。请注意，与 `defineModel()` 不同，你需要自己声明 props 和 emits。\n\n## useTemplateRef() <sup class=\"vt-badge\" data-text=\"3.5+\" /> {#usetemplateref}\n\n返回一个浅层 ref，其值将与模板中的具有匹配 ref attribute 的元素或组件同步。\n\n- **类型**\n\n  ```ts\n  function useTemplateRef<T>(key: string): Readonly<ShallowRef<T | null>>\n  ```\n\n- **示例**\n\n  ```vue\n  <script setup>\n  import { useTemplateRef, onMounted } from 'vue'\n\n  const inputRef = useTemplateRef('input')\n\n  onMounted(() => {\n    inputRef.value.focus()\n  })\n  </script>\n\n  <template>\n    <input ref=\"input\" />\n  </template>\n  ```\n\n- **参考**\n  - [指南 - 模板引用](/guide/essentials/template-refs)\n  - [指南 - 为模板引用标注类型](/guide/typescript/composition-api#typing-template-refs) <sup class=\"vt-badge ts\" />\n  - [指南 - 为组件模板引用标注类型](/guide/typescript/composition-api#typing-component-template-refs) <sup class=\"vt-badge ts\" />\n\n## useId() <sup class=\"vt-badge\" data-text=\"3.5+\" /> {#useid}\n\n用于为无障碍属性或表单元素生成每个应用内唯一的 ID。\n\n- **类型**\n\n  ```ts\n  function useId(): string\n  ```\n\n- **示例**\n\n  ```vue\n  <script setup>\n  import { useId } from 'vue'\n\n  const id = useId()\n  </script>\n\n  <template>\n    <form>\n      <label :for=\"id\">Name:</label>\n      <input :id=\"id\" type=\"text\" />\n    </form>\n  </template>\n  ```\n\n- **详细信息**\n\n  `useId()` 生成的每个 ID 在每个应用内都是唯一的。它可以用于为表单元素和无障碍属性生成 ID。在同一个组件中多次调用会生成不同的 ID；同一个组件的多个实例调用 `useId()` 也会生成不同的 ID。\n\n  `useId()` 生成的 ID 在服务器端和客户端渲染之间是稳定的，因此可以安全地在 SSR 应用中使用，不会导致激活不匹配。\n\n  如果同一页面上有多个 Vue 应用实例，可以通过 [`app.config.idPrefix`](/api/application#app-config-idprefix) 为每个应用提供一个 ID 前缀，以避免 ID 冲突。\n\n  :::warning Caution\n  `useId()` 不应在 `computed()` 属性内部调用，因为这可能导致实例冲突。相反，应在 `computed()` 外部声明 ID，并在计算函数内部引用它。\n  :::\n\n\n\n================================================\nFILE: src/api/composition-api-lifecycle.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/api/composition-api-setup.md\n================================================\n# 组合式 API：setup() {#composition-api-setup}\n\n## 基本使用 {#basic-usage}\n\n`setup()` 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：\n\n1. 需要在非单文件组件中使用组合式 API 时。\n2. 需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。\n\n:::info 注意\n对于结合单文件组件使用的组合式 API，推荐通过 [`<script setup>`](/api/sfc-script-setup) 以获得更加简洁及符合人体工程学的语法。\n:::\n\n我们可以使用[响应式 API](./reactivity-core) 来声明响应式的状态，在 `setup()` 函数中返回的对象会暴露给模板和组件实例。其他的选项也可以通过组件实例来获取 `setup()` 暴露的属性：\n\n```vue\n<script>\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    // 返回值会暴露给模板和其他的选项式 API 钩子\n    return {\n      count\n    }\n  },\n\n  mounted() {\n    console.log(this.count) // 0\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\">{{ count }}</button>\n</template>\n```\n\n在模板中访问从 `setup` 返回的 [ref](/api/reactivity-core#ref) 时，它会[自动浅层解包](/guide/essentials/reactivity-fundamentals#deep-reactivity)，因此你无须再在模板中为它写 `.value`。当通过 `this` 访问时也会同样如此解包。\n\n`setup()` 自身并不含对组件实例的访问权，即在 `setup()` 中访问 `this` 会是 `undefined`。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。\n\n`setup()` 应该*同步地*返回一个对象。唯一可以使用 `async setup()` 的情况是，该组件是 [Suspense](../guide/built-ins/suspense) 组件的后裔。\n\n## 访问 Props {#accessing-props}\n\n`setup` 函数的第一个参数是组件的 `props`。和标准的组件一致，一个 `setup` 函数的 `props` 是响应式的，并且会在传入新的 props 时同步更新。\n\n```js\nexport default {\n  props: {\n    title: String\n  },\n  setup(props) {\n    console.log(props.title)\n  }\n}\n```\n\n请注意如果你解构了 `props` 对象，解构出的变量将会丢失响应性。因此我们推荐通过 `props.xxx` 的形式来使用其中的 props。\n\n如果你确实需要解构 `props` 对象，或者需要将某个 prop 传到一个外部函数中并保持响应性，那么你可以使用 [toRefs()](./reactivity-utilities#torefs) 和 [toRef()](/api/reactivity-utilities#toref) 这两个工具函数：\n\n```js\nimport { toRefs, toRef } from 'vue'\n\nexport default {\n  setup(props) {\n    // 将 `props` 转为一个其中全是 ref 的对象，然后解构\n    const { title } = toRefs(props)\n    // `title` 是一个追踪着 `props.title` 的 ref\n    console.log(title.value)\n\n    // 或者，将 `props` 的单个属性转为一个 ref\n    const title = toRef(props, 'title')\n  }\n}\n```\n\n## Setup 上下文 {#setup-context}\n\n传入 `setup` 函数的第二个参数是一个 **Setup 上下文**对象。上下文对象暴露了其他一些在 `setup` 中可能会用到的值：\n\n```js\nexport default {\n  setup(props, context) {\n    // 透传 Attributes (非响应式的对象，等价于 $attrs)\n    console.log(context.attrs)\n\n    // 插槽(非响应式的对象，等价于 $slots)\n    console.log(context.slots)\n\n    // 触发事件(函数，等价于 $emit)\n    console.log(context.emit)\n\n    // 暴露公共属性(函数)\n    console.log(context.expose)\n  }\n}\n```\n\n该上下文对象是非响应式的，可以安全地解构：\n\n```js\nexport default {\n  setup(props, { attrs, slots, emit, expose }) {\n    ...\n  }\n}\n```\n\n`attrs` 和 `slots` 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 `attrs.x` 或 `slots.x` 的形式使用其中的属性。此外还需注意，和 `props` 不同，`attrs` 和 `slots` 的属性都**不是**响应式的。如果你想要基于 `attrs` 或 `slots` 的改变来执行副作用，那么你应该在 `onBeforeUpdate` 生命周期钩子中编写相关逻辑。\n\n### 暴露公共属性 {#exposing-public-properties}\n\n`expose` 函数用于显式地限制该组件暴露出的属性，当父组件通过[模板引用](/guide/essentials/template-refs#ref-on-component)访问该组件的实例时，将仅能访问 `expose` 函数暴露出的内容：\n\n```js{5,10}\nexport default {\n  setup(props, { expose }) {\n    // 让组件实例处于 “关闭状态”\n    // 即不向父组件暴露任何东西\n    expose()\n\n    const publicCount = ref(0)\n    const privateCount = ref(0)\n    // 有选择地暴露局部状态\n    expose({ count: publicCount })\n  }\n}\n```\n\n## 与渲染函数一起使用 {#usage-with-render-functions}\n\n`setup` 也可以返回一个[渲染函数](/guide/extras/render-function)，此时在渲染函数中可以直接使用在同一作用域下声明的响应式状态：\n\n```js{6}\nimport { h, ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    return () => h('div', count.value)\n  }\n}\n```\n\n返回一个渲染函数将会阻止我们返回其他东西。对于组件内部来说，这样没有问题，但如果我们想通过模板引用将这个组件的方法暴露给父组件，那就有问题了。\n\n我们可以通过调用 [`expose()`](#exposing-public-properties) 解决这个问题：\n\n```js{8-10}\nimport { h, ref } from 'vue'\n\nexport default {\n  setup(props, { expose }) {\n    const count = ref(0)\n    const increment = () => ++count.value\n\n    expose({\n      increment\n    })\n\n    return () => h('div', count.value)\n  }\n}\n```\n\n此时父组件可以通过模板引用来访问这个 `increment` 方法。\n\n\n\n================================================\nFILE: src/api/custom-elements.md\n================================================\n# 自定义元素 API {#custom-elements-api}\n\n## defineCustomElement() {#definecustomelement}\n\n此方法接受的参数与 [`defineComponent`](/api/general.html#definecomponent) 相同，但返回一个原生[自定义元素](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements)类构造函数。\n\n- **类型**\n\n  ```ts\n  function defineCustomElement(\n    component:\n      | (ComponentOptions & CustomElementsOptions)\n      | ComponentOptions['setup'],\n    options?: CustomElementsOptions\n  ): {\n    new (props?: object): HTMLElement\n  }\n\n  interface CustomElementsOptions {\n    styles?: string[]\n\n    // 以下选项在 3.5+ 版本中支持\n    configureApp?: (app: App) => void\n    shadowRoot?: boolean\n    nonce?: string\n  }\n  ```\n\n  > 类型为简化版，便于阅读。\n\n- **详情**\n\n  除了常规的组件选项，`defineCustomElement()` 还支持一系列特定于自定义元素的选项：\n\n  - **`styles`**：一个内联 CSS 字符串数组，用于提供应注入元素 shadow root 的 CSS。\n\n  - **`configureApp`** <sup class=\"vt-badge\" data-text=\"3.5+\"/>：一个函数，可用于配置自定义元素的 Vue 应用实例。\n\n  - **`shadowRoot`** <sup class=\"vt-badge\" data-text=\"3.5+\"/>：`boolean`，默认为 `true`。设置为 `false` 以在不带 shadow root 的情况下渲染自定义元素。这意味着自定义元素单文件组件中的 `<style>` 将不再被封装隔离。\n\n  - **`nonce`** <sup class=\"vt-badge\" data-text=\"3.5+\"/>：`string`，如果提供，将在注入到 shadow root 样式标签上设置 `nonce` attribute。\n\n  注意，这些选项也可以不作为组件本身的一部分传递，而是通过第二个参数传递：\n\n  ```js\n  import Element from './MyElement.ce.vue'\n\n  defineCustomElement(Element, {\n    configureApp(app) {\n      // ...\n    }\n  })\n  ```\n\n  返回值是一个自定义元素构造函数，可以使用 [`customElements.define()`](https://developer.mozilla.org/zh-CN/docs/Web/API/CustomElementRegistry/define) 注册。\n\n- **示例**\n\n  ```js\n  import { defineCustomElement } from 'vue'\n\n  const MyVueElement = defineCustomElement({\n    /* 组件选项 */\n  })\n\n  // 注册自定义元素\n  customElements.define('my-vue-element', MyVueElement)\n  ```\n\n- **参考**\n\n  - [指南 - 使用 Vue 构建自定义元素](/guide/extras/web-components#building-custom-elements-with-vue)\n\n  - 请注意，使用单文件组件时，`defineCustomElement()` 需要进行[特殊配置](/guide/extras/web-components#sfc-as-custom-element)。\n\n## useHost() <sup class=\"vt-badge\" data-text=\"3.5+\"/> {#usehost}\n\n一个组合式 API 辅助函数，返回当前 Vue 自定义元素的宿主元素。\n\n## useShadowRoot() <sup class=\"vt-badge\" data-text=\"3.5+\"/> {#useshadowroot}\n\n一个组合式 API 辅助函数，返回当前 Vue 自定义元素的 shadow root。\n\n## this.$host <sup class=\"vt-badge\" data-text=\"3.5+\"/> {#this-host}\n\n一个选项式 API 的 property，暴露当前 Vue 自定义元素的宿主元素。\n\n\n\n================================================\nFILE: src/api/custom-renderer.md\n================================================\n# 自定义渲染器 API {#custom-renderer-api}\n\n## createRenderer() {#createrenderer}\n\n创建一个自定义渲染器。通过提供平台特定的节点创建以及更改 API，你可以在非 DOM 环境中也享受到 Vue 核心运行时的特性。\n\n- **类型**\n\n  ```ts\n  function createRenderer<HostNode, HostElement>(\n    options: RendererOptions<HostNode, HostElement>\n  ): Renderer<HostElement>\n\n  interface Renderer<HostElement> {\n    render: RootRenderFunction<HostElement>\n    createApp: CreateAppFunction<HostElement>\n  }\n\n  interface RendererOptions<HostNode, HostElement> {\n    patchProp(\n      el: HostElement,\n      key: string,\n      prevValue: any,\n      nextValue: any,\n      namespace?: ElementNamespace,\n      parentComponent?: ComponentInternalInstance | null,\n    ): void\n    insert(el: HostNode, parent: HostElement, anchor?: HostNode | null): void\n    remove(el: HostNode): void\n    createElement(\n      type: string,\n      namespace?: ElementNamespace,\n      isCustomizedBuiltIn?: string,\n      vnodeProps?: (VNodeProps & { [key: string]: any }) | null,\n    ): HostElement\n    createText(text: string): HostNode\n    createComment(text: string): HostNode\n    setText(node: HostNode, text: string): void\n    setElementText(node: HostElement, text: string): void\n    parentNode(node: HostNode): HostElement | null\n    nextSibling(node: HostNode): HostNode | null\n    querySelector?(selector: string): HostElement | null\n    setScopeId?(el: HostElement, id: string): void\n    cloneNode?(node: HostNode): HostNode\n    insertStaticContent?(\n      content: string,\n      parent: HostElement,\n      anchor: HostNode | null,\n      namespace: ElementNamespace,\n      start?: HostNode | null,\n      end?: HostNode | null,\n    ): [HostNode, HostNode]\n  }\n  ```\n\n- **示例**\n\n  ```js\n  import { createRenderer } from '@vue/runtime-core'\n\n  const { render, createApp } = createRenderer({\n    patchProp,\n    insert,\n    remove,\n    createElement\n    // ...\n  })\n\n  // `render` 是底层 API\n  // `createApp` 返回一个应用实例\n  export { render, createApp }\n\n  // 重新导出 Vue 的核心 API\n  export * from '@vue/runtime-core'\n  ```\n\n  Vue 自身的 `@vue/runtime-dom` 也是[利用这套 API 实现的](https://github.com/vuejs/core/blob/main/packages/runtime-dom/src/index.ts)。要想了解一个简单一些的实现，请参考 [`@vue/runtime-test`](https://github.com/vuejs/core/blob/main/packages/runtime-test/src/index.ts)，这是一个 Vue 自己做单元测试的私有包。\n\n\n\n================================================\nFILE: src/api/general.md\n================================================\n# 全局 API：常规 {#global-api-general}\n\n## version {#version}\n\n暴露当前所使用的 Vue 版本。\n\n- **类型** `string`\n\n- **示例**\n\n  ```js\n  import { version } from 'vue'\n\n  console.log(version)\n  ```\n\n## nextTick() {#nexttick}\n\n等待下一次 DOM 更新刷新的工具方法。\n\n- **类型**\n\n  ```ts\n  function nextTick(callback?: () => void): Promise<void>\n  ```\n\n- **详细信息**\n\n  当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。\n\n  `nextTick()` 可以在状态改变后立即使用，以等待 DOM 更新完成。你可以传递一个回调函数作为参数，或者 await 返回的 Promise。\n\n- **示例**\n\n  <div class=\"composition-api\">\n\n  ```vue\n  <script setup>\n  import { ref, nextTick } from 'vue'\n\n  const count = ref(0)\n\n  async function increment() {\n    count.value++\n\n    // DOM 还未更新\n    console.log(document.getElementById('counter').textContent) // 0\n\n    await nextTick()\n    // DOM 此时已经更新\n    console.log(document.getElementById('counter').textContent) // 1\n  }\n  </script>\n\n  <template>\n    <button id=\"counter\" @click=\"increment\">{{ count }}</button>\n  </template>\n  ```\n\n  </div>\n  <div class=\"options-api\">\n\n  ```vue\n  <script>\n  import { nextTick } from 'vue'\n\n  export default {\n    data() {\n      return {\n        count: 0\n      }\n    },\n    methods: {\n      async increment() {\n        this.count++\n\n        // DOM 还未更新\n        console.log(document.getElementById('counter').textContent) // 0\n\n        await nextTick()\n        // DOM 此时已经更新\n        console.log(document.getElementById('counter').textContent) // 1\n      }\n    }\n  }\n  </script>\n\n  <template>\n    <button id=\"counter\" @click=\"increment\">{{ count }}</button>\n  </template>\n  ```\n\n  </div>\n\n- **参考** [`this.$nextTick()`](/api/component-instance#nexttick)\n\n## defineComponent() {#definecomponent}\n\n在定义 Vue 组件时提供类型推导的辅助函数。\n\n- **类型**\n\n  ```ts\n  // 选项语法\n  function defineComponent(\n    component: ComponentOptions\n  ): ComponentConstructor\n\n  // 函数语法 (需要 3.3+)\n  function defineComponent(\n    setup: ComponentOptions['setup'],\n    extraOptions?: ComponentOptions\n  ): () => any\n  ```\n\n  > 为了便于阅读，对类型进行了简化。\n\n- **详细信息**\n\n  第一个参数是一个组件选项对象。返回值将是该选项对象本身，因为该函数实际上在运行时没有任何操作，仅用于提供类型推导。\n\n  注意返回值的类型有一点特别：它会是一个构造函数类型，它的实例类型是根据选项推断出的组件实例类型。这是为了能让该返回值在 TSX 中用作标签时提供类型推导支持。\n\n  你可以像这样从 `defineComponent()` 的返回类型中提取出一个组件的实例类型 (与其选项中的 `this` 的类型等价)：\n\n  ```ts\n  const Foo = defineComponent(/* ... */)\n\n  type FooInstance = InstanceType<typeof Foo>\n  ```\n\n  ### 函数签名 {#function-signature}\n\n  - 仅在 3.3+ 中支持\n\n  `defineComponent()` 还有一种备用签名，旨在与组合式 API 和[渲染函数或 JSX](/guide/extras/render-function.html) 一起使用。\n\n  与传递选项对象不同的是，它需要传入一个函数。这个函数的工作方式与组合式 API 的 [`setup()`](/api/composition-api-setup.html#composition-api-setup) 函数相同：它接收 props 和 setup 上下文。返回值应该是一个渲染函数——支持 `h()` 和 JSX：\n\n  ```js\n  import { ref, h } from 'vue'\n\n  const Comp = defineComponent(\n    (props) => {\n      // 就像在 <script setup> 中一样使用组合式 API\n      const count = ref(0)\n\n      return () => {\n        // 渲染函数或 JSX\n        return h('div', count.value)\n      }\n    },\n    // 其他选项，例如声明 props 和 emits。\n    {\n      props: {\n        /* ... */\n      }\n    }\n  )\n  ```\n\n  此签名的主要用例是使用 TypeScript (特别是使用 TSX)，因为它支持泛型：\n\n  ```tsx\n  const Comp = defineComponent(\n    <T extends string | number>(props: { msg: T; list: T[] }) => {\n      // 就像在 <script setup> 中一样使用组合式 API\n      const count = ref(0)\n\n      return () => {\n        // 渲染函数或 JSX\n        return <div>{count.value}</div>\n      }\n    },\n    // 目前仍然需要手动声明运行时的 props\n    {\n      props: ['msg', 'list']\n    }\n  )\n  ```\n\n  在将来，我们计划提供一个 Babel 插件，自动推断并注入运行时 props (就像在单文件组件中的 `defineProps` 一样)，以便省略运行时 props 的声明。\n\n  ### webpack Treeshaking 的注意事项 {#note-on-webpack-treeshaking}\n\n  因为 `defineComponent()` 是一个函数调用，所以它可能被某些构建工具认为会产生副作用，如 webpack。即使一个组件从未被使用，也有可能不被 tree-shake。\n\n  为了告诉 webpack 这个函数调用可以被安全地 tree-shake，我们可以在函数调用之前添加一个 `/*#__PURE__*/` 形式的注释：\n\n  ```js\n  export default /*#__PURE__*/ defineComponent(/* ... */)\n  ```\n\n  请注意，如果你的项目中使用的是 Vite，就不需要这么做，因为 Rollup (Vite 底层使用的生产环境打包工具) 可以智能地确定 `defineComponent()` 实际上并没有副作用，所以无需手动注释。\n\n- **参考**[指南 - 配合 TypeScript 使用 Vue](/guide/typescript/overview#general-usage-notes)\n\n## defineAsyncComponent() {#defineasynccomponent}\n\n定义一个异步组件，它在运行时是懒加载的。参数可以是一个异步加载函数，或是对加载行为进行更具体定制的一个选项对象。\n\n- **类型**\n\n  ```ts\n  function defineAsyncComponent(\n    source: AsyncComponentLoader | AsyncComponentOptions\n  ): Component\n\n  type AsyncComponentLoader = () => Promise<Component>\n\n  interface AsyncComponentOptions {\n    loader: AsyncComponentLoader\n    loadingComponent?: Component\n    errorComponent?: Component\n    delay?: number\n    timeout?: number\n    suspensible?: boolean\n    onError?: (\n      error: Error,\n      retry: () => void,\n      fail: () => void,\n      attempts: number\n    ) => any\n  }\n  ```\n\n- **参考**[指南 - 异步组件](/guide/components/async)\n\n\n\n================================================\nFILE: src/api/index.md\n================================================\n---\ntitle: API 参考\nsidebar: false\npage: true\nfooter: false\n---\n\n<script setup>\nimport ApiIndex from './ApiIndex.vue'\n</script>\n\n<ApiIndex />\n\n\n\n================================================\nFILE: src/api/options-composition.md\n================================================\n# 组合选项 {#options-composition}\n\n## provide {#provide}\n\n用于提供可以被后代组件注入的值。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    provide?: object | ((this: ComponentPublicInstance) => object)\n  }\n  ```\n\n- **详细信息**\n\n  `provide` 和 [`inject`](#inject) 通常成对一起使用，使一个祖先组件作为其后代组件的依赖注入方，无论这个组件的层级有多深都可以注入成功，只要他们处于同一条组件链上。\n\n  这个 `provide` 选项应当是一个对象或是返回一个对象的函数。这个对象包含了可注入其后代组件的属性。你可以在这个对象中使用 Symbol 类型的值作为 key。\n\n- **示例**\n\n  基本使用方式：\n\n  ```js\n  const s = Symbol()\n\n  export default {\n    provide: {\n      foo: 'foo',\n      [s]: 'bar'\n    }\n  }\n  ```\n\n  使用函数可以提供其组件中的状态：\n\n  ```js\n  export default {\n    data() {\n      return {\n        msg: 'foo'\n      }\n    }\n    provide() {\n      return {\n        msg: this.msg\n      }\n    }\n  }\n  ```\n\n  请注意，针对上面这个例子，所供给的 `msg` 将**不会**是响应式的。请查看[和响应式数据配合使用](/guide/components/provide-inject#working-with-reactivity)一节获取更多细节。\n\n- **参考**[依赖注入](/guide/components/provide-inject)\n\n## inject {#inject}\n\n用于声明要通过从上层提供方匹配并注入进当前组件的属性。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    inject?: ArrayInjectOptions | ObjectInjectOptions\n  }\n\n  type ArrayInjectOptions = string[]\n\n  type ObjectInjectOptions = {\n    [key: string | symbol]:\n      | string\n      | symbol\n      | { from?: string | symbol; default?: any }\n  }\n  ```\n\n- **详细信息**\n\n  该 `inject` 选项应该是以下两种之一：\n\n  - 一个字符串数组\n  - 一个对象，其 key 名就是在当前组件中的本地绑定名称，而它的值应该是以下两种之一：\n    - 匹配可用注入的 key (string 或者 Symbol)\n    - 一个对象\n      - 它的 `from` 属性是一个 key (string 或者 Symbol)，用于匹配可用的注入\n      - 它的 `default` 属性用作候补值。和 props 的默认值类似，如果它是一个对象，那么应该使用一个工厂函数来创建，以避免多个组件共享同一个对象。\n\n  如果没有供给相匹配的属性、也没有提供默认值，那么注入的属性将为 `undefined`。\n\n  请注意，注入绑定并非响应式的。这是有意为之的一个设计。如果要注入的值是一个响应式对象，那么这个对象上的属性将会保留响应性。请看[配合响应性](/guide/components/provide-inject#working-with-reactivity)一节获取更多细节。\n\n- **示例**\n\n  基本使用方式：\n\n  ```js\n  export default {\n    inject: ['foo'],\n    created() {\n      console.log(this.foo)\n    }\n  }\n  ```\n\n  使用注入的值作为 props 的默认值：\n\n  ```js\n  const Child = {\n    inject: ['foo'],\n    props: {\n      bar: {\n        default() {\n          return this.foo\n        }\n      }\n    }\n  }\n  ```\n\n  使用注入的值作为 data：\n\n  ```js\n  const Child = {\n    inject: ['foo'],\n    data() {\n      return {\n        bar: this.foo\n      }\n    }\n  }\n  ```\n\n  注入项可以选择是否带有默认值：\n\n  ```js\n  const Child = {\n    inject: {\n      foo: { default: 'foo' }\n    }\n  }\n  ```\n\n  如果需要从不同名字的属性中注入，请使用 `from` 指明来源属性。\n\n  ```js\n  const Child = {\n    inject: {\n      foo: {\n        from: 'bar',\n        default: 'foo'\n      }\n    }\n  }\n  ```\n\n  和 props 默认值类似，对于非原始数据类型的值，你需要使用工厂函数：\n\n  ```js\n  const Child = {\n    inject: {\n      foo: {\n        from: 'bar',\n        default: () => [1, 2, 3]\n      }\n    }\n  }\n  ```\n\n- **参考**[依赖注入](/guide/components/provide-inject)\n\n## mixins {#mixins}\n\n一个包含组件选项对象的数组，这些选项都将被混入到当前组件的实例中。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    mixins?: ComponentOptions[]\n  }\n  ```\n\n- **详细信息**\n\n  `mixins` 选项接受一个 mixin 对象数组。这些 mixin 对象可以像普通的实例对象一样包含实例选项，它们将使用一定的选项合并逻辑与最终的选项进行合并。举例来说，如果你的 mixin 包含了一个 `created` 钩子，而组件自身也有一个，那么这两个函数都会被调用。\n\n  Mixin 钩子的调用顺序与提供它们的选项顺序相同，且会在组件自身的钩子前被调用。\n\n  :::warning 不再推荐\n  在 Vue 2 中，mixins 是创建可重用组件逻辑的主要方式。尽管在 Vue 3 中保留了 mixins 支持，但对于组件间的逻辑复用，[使用组合式 API 的组合式函数](/guide/reusability/composables)是现在更推荐的方式。\n  :::\n\n- **示例**\n\n  ```js\n  const mixin = {\n    created() {\n      console.log(1)\n    }\n  }\n\n  createApp({\n    created() {\n      console.log(2)\n    },\n    mixins: [mixin]\n  })\n\n  // => 1\n  // => 2\n  ```\n\n## extends {#extends}\n\n要继承的“基类”组件。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    extends?: ComponentOptions\n  }\n  ```\n\n- **详细信息**\n\n  使一个组件可以继承另一个组件的组件选项。\n\n  从实现角度来看，`extends` 几乎和 `mixins` 相同。通过 `extends` 指定的组件将会当作第一个 mixin 来处理。\n\n  然而，`extends` 和 `mixins` 表达的是不同的目标。`mixins` 选项基本用于组合功能，而 `extends` 则一般更关注继承关系。\n\n  同 `mixins` 一样，所有选项 (`setup()` 除外) 都将使用相关的策略进行合并。\n\n- **示例**\n\n  ```js\n  const CompA = { ... }\n\n  const CompB = {\n    extends: CompA,\n    ...\n  }\n  ```\n\n  :::warning 不建议用于组合式 API\n  `extends` 是为选项式 API 设计的，不会处理 `setup()` 钩子的合并。\n\n  在组合式 API 中，逻辑复用的首选模式是“组合”而不是“继承”。如果一个组件中的逻辑需要复用，考虑将相关逻辑提取到[组合式函数](/guide/reusability/composables#composables)中。\n\n  如果你仍然想要通过组合式 API 来“继承”一个组件，可以在继承组件的 `setup()` 中调用基类组件的 `setup()`：\n\n  ```js\n  import Base from './Base.js'\n  export default {\n    extends: Base,\n    setup(props, ctx) {\n      return {\n        ...Base.setup(props, ctx),\n        // 本地绑定\n      }\n    }\n  }\n  ```\n  :::\n\n\n\n================================================\nFILE: src/api/options-lifecycle.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/api/options-misc.md\n================================================\n# 其他杂项选项 {#options-misc}\n\n## name {#name}\n\n用于显式声明组件展示时的名称。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    name?: string\n  }\n  ```\n\n- **详细信息**\n\n  组件的名字有以下用途：\n\n  - 在组件自己的模板中递归引用自己时\n  - 在 Vue 开发者工具中的组件树显示时\n  - 在组件抛出的警告追踪栈信息中显示时\n\n  当你在使用单文件组件时，组件已经会根据其文件名推导出其名称。举例来说，一个名为 `MyComponent.vue` 的文件会推导出显示名称为“MyComponent”。\n\n  另一种场景是当一个组件通过 [`app.component`](/api/application#app-component) 被全局注册时，这个全局 ID 就自动被设为了其名称。\n\n  使用 `name` 选项使你可以覆盖推导出的名称，或是在没有推导出名字时显式提供一个。(例如没有使用构建工具时，或是一个内联的非单文件组件)\n\n  有一种场景下 `name` 必须是已显式声明的：即 [`<KeepAlive>`](/guide/built-ins/keep-alive) 通过其 `include / exclude` prop 来匹配其需要缓存的组件时。\n\n  :::tip\n  在 3.2.34 或以上的版本中，使用 `<script setup>` 的单文件组件会自动根据文件名生成对应的 `name` 选项，即使是在配合 `<KeepAlive>` 使用时也无需再手动声明。\n  :::\n\n## inheritAttrs {#inheritattrs}\n\n用于控制是否启用默认的组件 attribute 透传行为。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    inheritAttrs?: boolean // 默认值：true\n  }\n  ```\n\n- **详细信息**\n\n  默认情况下，父组件传递的，但没有被子组件解析为 props 的 attributes 绑定会被“透传”。这意味着当我们有一个单根节点的子组件时，这些绑定会被作为一个常规的 HTML attribute 应用在子组件的根节点元素上。当你编写的组件想要在一个目标元素或其他组件外面包一层时，可能并不期望这样的行为。我们可以通过设置 `inheritAttrs` 为 `false` 来禁用这个默认行为。这些 attributes 可以通过 `$attrs` 这个实例属性来访问，并且可以通过 `v-bind` 来显式绑定在一个非根节点的元素上。\n\n- **示例**\n\n  <div class=\"options-api\">\n\n  ```vue\n  <script>\n  export default {\n    inheritAttrs: false,\n    props: ['label', 'value'],\n    emits: ['input']\n  }\n  </script>\n\n  <template>\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on:input=\"$emit('input', $event.target.value)\"\n      />\n    </label>\n  </template>\n  ```\n\n  </div>\n  <div class=\"composition-api\">\n\n  在一个使用了 `<script setup>` 的组件中声明这个选项时，可以使用 [`defineOptions`](/api/sfc-script-setup#defineoptions) 宏：\n\n  ```vue\n  <script setup>\n  defineProps(['label', 'value'])\n  defineEmits(['input'])\n  defineOptions({\n    inheritAttrs: false\n  })\n  </script>\n\n  <template>\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on:input=\"$emit('input', $event.target.value)\"\n      />\n    </label>\n  </template>\n  ```\n\n  </div>\n\n- **参考**\n\n  - [透传 attribute](/guide/components/attrs)\n  <div class=\"composition-api\">\n\n  - [在常规 `<script>` 中使用 `inheritAttrs`](/api/sfc-script-setup.html#usage-alongside-normal-script)\n  </div>\n\n## components {#components}\n\n一个对象，用于注册对当前组件实例可用的组件。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    components?: { [key: string]: Component }\n  }\n  ```\n\n- **示例**\n\n  ```js\n  import Foo from './Foo.vue'\n  import Bar from './Bar.vue'\n\n  export default {\n    components: {\n      // 简写\n      Foo,\n      // 注册为一个不同的名称\n      RenamedBar: Bar\n    }\n  }\n  ```\n\n- **参考**[组件注册](/guide/components/registration)\n\n## directives {#directives}\n\n一个对象，用于注册对当前组件实例可用的指令。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    directives?: { [key: string]: Directive }\n  }\n  ```\n\n- **示例**\n\n  ```js\n  export default {\n    directives: {\n      // 在模板中启用 v-focus\n      focus: {\n        mounted(el) {\n          el.focus()\n        }\n      }\n    }\n  }\n  ```\n\n  ```vue-html\n  <input v-focus>\n  ```\n\n- **参考**[自定义指令](/guide/reusability/custom-directives)\n\n\n\n================================================\nFILE: src/api/options-rendering.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/api/options-state.md\n================================================\n# 状态选项 {#options-state}\n\n## data {#data}\n\n用于声明组件初始响应式状态的函数。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    data?(\n      this: ComponentPublicInstance,\n      vm: ComponentPublicInstance\n    ): object\n  }\n  ```\n\n- **详细信息**\n\n  该函数应当返回一个普通 JavaScript 对象，Vue 会将它转换为响应式对象。实例创建后，可以通过 `this.$data` 访问该响应式对象。组件实例也代理了该数据对象上所有的属性，因此 `this.a` 等价于 `this.$data.a`。\n\n  所有会用到的顶层数据属性都应该提前在这个对象中声明。虽然理论上可以向 `this.$data` 添加新属性，但并不推荐这么做。如果一个属性的值在一开始还获取不到，应当先用 `undefined` 或是 `null` 值来占位，让 Vue 知道这个属性是存在的。\n\n  以 `_` 或 `$` 开头的属性将**不会**被组件实例代理，因为它们可能和 Vue 的内置属性、API 方法冲突。你必须以 `this.$data._property` 的方式访问它们。\n\n  **不**推荐返回一个可能改变自身状态的对象，如浏览器 API 原生对象或是带原型的类实例等。理想情况下，返回的对象应是一个纯粹代表组件状态的普通对象。\n\n- **示例**\n\n  ```js\n  export default {\n    data() {\n      return { a: 1 }\n    },\n    created() {\n      console.log(this.a) // 1\n      console.log(this.$data) // { a: 1 }\n    }\n  }\n  ```\n\n  注意，如果你为 `data` 属性使用了一个箭头函数，则 `this` 将不会指向该组件实例，不过你仍然可以通过该函数的第一个参数来访问实例：\n\n  ```js\n  data: (vm) => ({ a: vm.myProp })\n  ```\n\n- **参考**[深入响应式系统](/guide/extras/reactivity-in-depth)\n\n## props {#props}\n\n用于声明一个组件的 props。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    props?: ArrayPropsOptions | ObjectPropsOptions\n  }\n\n  type ArrayPropsOptions = string[]\n\n  type ObjectPropsOptions = { [key: string]: Prop }\n\n  type Prop<T = any> = PropOptions<T> | PropType<T> | null\n\n  interface PropOptions<T> {\n    type?: PropType<T>\n    required?: boolean\n    default?: T | ((rawProps: object) => T)\n    validator?: (value: unknown, rawProps: object) => boolean\n  }\n\n  type PropType<T> = { new (): T } | { new (): T }[]\n  ```\n\n  > 为了便于阅读，对类型进行了简化。\n\n- **详细信息**\n\n  在 Vue 中，所有的组件 props 都需要被显式声明。组件 props 可以通过两种方式声明：\n\n  - 使用字符串数组的简易形式。\n  - 使用对象的完整形式。该对象的每个属性键是对应 prop 的名称，值则是该 prop 应具有的类型的构造函数，或是更高级的选项。\n\n  在基于对象的语法中，每个 prop 可以进一步定义如下选项：\n\n  - **`type`**：可以是下列原生构造函数之一：`String`、`Number`、`Boolean`、`Array`、`Object`、`Date`、`Function`、`Symbol`、任何自定义构造函数，或由上述内容组成的数组。在开发模式中，Vue 会检查一个 prop 的值是否匹配其声明的类型，如果不匹配则会抛出警告。详见 [Prop 校验](/guide/components/props#prop-validation)。\n\n    还要注意，一个 `Boolean` 类型的 prop 会影响它在开发或生产模式下的值转换行为。详见 [Boolean 类型转换](/guide/components/props#boolean-casting)。\n\n  - **`default`**：为该 prop 指定一个当其没有被传入或值为 `undefined` 时的默认值。对象或数组的默认值必须从一个工厂函数返回。工厂函数也接收原始 prop 对象作为参数。\n\n  - **`required`**：定义该 prop 是否必需传入。在非生产环境中，如果 required 值为[真值](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)且 prop 未被传入，一个控制台警告将会被抛出。\n\n  - **`validator`**：将 prop 值及其对象作为参数传入的自定义验证函数。在开发模式下，如果该函数返回一个[假值](https://developer.mozilla.org/en-US/docs/Glossary/Falsy) (即验证失败)，一个控制台警告将会被抛出。\n\n- **示例**\n\n  简易声明：\n\n  ```js\n  export default {\n    props: ['size', 'myMessage']\n  }\n  ```\n\n  对象声明，带有验证：\n\n  ```js\n  export default {\n    props: {\n      // 类型检查\n      height: Number,\n      // 类型检查 + 其他验证\n      age: {\n        type: Number,\n        default: 0,\n        required: true,\n        validator: (value) => {\n          return value >= 0\n        }\n      }\n    }\n  }\n  ```\n\n- **参考**\n  - [指南 - Props](/guide/components/props)\n  - [指南 - 为组件的 props 标注类型](/guide/typescript/options-api#typing-component-props) <sup class=\"vt-badge ts\" />\n\n## computed {#computed}\n\n用于声明要在组件实例上暴露的计算属性。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    computed?: {\n      [key: string]: ComputedGetter<any> | WritableComputedOptions<any>\n    }\n  }\n\n  type ComputedGetter<T> = (\n    this: ComponentPublicInstance,\n    vm: ComponentPublicInstance\n  ) => T\n\n  type ComputedSetter<T> = (\n    this: ComponentPublicInstance,\n    value: T\n  ) => void\n\n  type WritableComputedOptions<T> = {\n    get: ComputedGetter<T>\n    set: ComputedSetter<T>\n  }\n  ```\n\n- **详细信息**\n\n  该选项接收一个对象，其中键是计算属性的名称，值是一个计算属性 getter，或一个具有 `get` 和 `set` 方法的对象 (用于声明可写的计算属性)。\n\n  所有的 getters 和 setters 会将它们的 `this` 上下文自动绑定为组件实例。\n\n  注意，如果你为一个计算属性使用了箭头函数，则 `this` 不会指向该组件实例，不过你仍然可以通过该函数的第一个参数来访问实例：\n\n  ```js\n  export default {\n    computed: {\n      aDouble: (vm) => vm.a * 2\n    }\n  }\n  ```\n\n- **示例**\n\n  ```js\n  export default {\n    data() {\n      return { a: 1 }\n    },\n    computed: {\n      // 只读\n      aDouble() {\n        return this.a * 2\n      },\n      // 可写\n      aPlus: {\n        get() {\n          return this.a + 1\n        },\n        set(v) {\n          this.a = v - 1\n        }\n      }\n    },\n    created() {\n      console.log(this.aDouble) // => 2\n      console.log(this.aPlus) // => 2\n\n      this.aPlus = 3\n      console.log(this.a) // => 2\n      console.log(this.aDouble) // => 4\n    }\n  }\n  ```\n\n- **参考**\n  - [指南 - 计算属性](/guide/essentials/computed)\n  - [指南 - 为计算属性标记类型](/guide/typescript/options-api#typing-computed-properties) <sup class=\"vt-badge ts\" />\n\n## methods {#methods}\n\n用于声明要混入到组件实例中的方法。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    methods?: {\n      [key: string]: (this: ComponentPublicInstance, ...args: any[]) => any\n    }\n  }\n  ```\n\n- **详细信息**\n\n  声明的方法可以直接通过组件实例访问，或者在模板语法表达式中使用。所有的方法都会将它们的 `this` 上下文自动绑定为组件实例，即使在传递时也如此。\n\n  在声明方法时避免使用箭头函数，因为它们不能通过 `this` 访问组件实例。\n\n- **示例**\n\n  ```js\n  export default {\n    data() {\n      return { a: 1 }\n    },\n    methods: {\n      plus() {\n        this.a++\n      }\n    },\n    created() {\n      this.plus()\n      console.log(this.a) // => 2\n    }\n  }\n  ```\n\n- **参考**[事件处理](/guide/essentials/event-handling)\n\n## watch {#watch}\n\n用于声明在数据更改时调用的侦听回调。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    watch?: {\n      [key: string]: WatchOptionItem | WatchOptionItem[]\n    }\n  }\n\n  type WatchOptionItem = string | WatchCallback | ObjectWatchOptionItem\n\n  type WatchCallback<T> = (\n    value: T,\n    oldValue: T,\n    onCleanup: (cleanupFn: () => void) => void\n  ) => void\n\n  type ObjectWatchOptionItem = {\n    handler: WatchCallback | string\n    immediate?: boolean // default: false\n    deep?: boolean // default: false\n    flush?: 'pre' | 'post' | 'sync' // default: 'pre'\n    onTrack?: (event: DebuggerEvent) => void\n    onTrigger?: (event: DebuggerEvent) => void\n  }\n  ```\n\n  > 为了便于阅读，对类型进行了简化。\n\n- **详细信息**\n\n  `watch` 选项期望接受一个对象，其中键是需要侦听的响应式组件实例属性 (例如，通过 `data` 或 `computed` 声明的属性)——值是相应的回调函数。该回调函数接受被侦听源的新值和旧值。\n\n  除了一个根级属性，键名也可以是一个简单的由点分隔的路径，例如 `a.b.c`。注意，这种用法**不支持**复杂表达式——仅支持由点分隔的路径。如果你需要侦听复杂的数据源，可以使用命令式的 [`$watch()`](/api/component-instance#watch) API。\n\n  值也可以是一个方法名称的字符串 (通过 `methods` 声明)，或包含额外选项的对象。当使用对象语法时，回调函数应被声明在 `handler` 中。额外的选项包含：\n\n  - **`immediate`**：在侦听器创建时立即触发回调。第一次调用时，旧值将为 `undefined`。\n  - **`deep`**：如果源是对象或数组，则强制深度遍历源，以便在深度变更时触发回调。详见[深层侦听器](/guide/essentials/watchers#deep-watchers)。\n  - **`flush`**：调整回调的刷新时机。详见[回调的触发时机](/guide/essentials/watchers#callback-flush-timing)及 [`watchEffect()`](/api/reactivity-core#watcheffect)。\n  - **`onTrack / onTrigger`**：调试侦听器的依赖关系。详见[侦听器调试](/guide/extras/reactivity-in-depth#watcher-debugging)。\n\n  声明侦听器回调时避免使用箭头函数，因为它们将无法通过 `this` 访问组件实例。\n\n- **示例**\n\n  ```js\n  export default {\n    data() {\n      return {\n        a: 1,\n        b: 2,\n        c: {\n          d: 4\n        },\n        e: 5,\n        f: 6\n      }\n    },\n    watch: {\n      // 侦听根级属性\n      a(val, oldVal) {\n        console.log(`new: ${val}, old: ${oldVal}`)\n      },\n      // 字符串方法名称\n      b: 'someMethod',\n      // 该回调将会在被侦听的对象的属性改变时调动，无论其被嵌套多深\n      c: {\n        handler(val, oldVal) {\n          console.log('c changed')\n        },\n        deep: true\n      },\n      // 侦听单个嵌套属性：\n      'c.d': function (val, oldVal) {\n        // do something\n      },\n      // 该回调将会在侦听开始之后立即调用\n      e: {\n        handler(val, oldVal) {\n          console.log('e changed')\n        },\n        immediate: true\n      },\n      // 你可以传入回调数组，它们将会被逐一调用\n      f: [\n        'handle1',\n        function handle2(val, oldVal) {\n          console.log('handle2 triggered')\n        },\n        {\n          handler: function handle3(val, oldVal) {\n            console.log('handle3 triggered')\n          }\n          /* ... */\n        }\n      ]\n    },\n    methods: {\n      someMethod() {\n        console.log('b changed')\n      },\n      handle1() {\n        console.log('handle 1 triggered')\n      }\n    },\n    created() {\n      this.a = 3 // => new: 3, old: 1\n    }\n  }\n  ```\n\n- **参考**[侦听器](/guide/essentials/watchers)\n\n## emits {#emits}\n\n用于声明由组件触发的自定义事件。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    emits?: ArrayEmitsOptions | ObjectEmitsOptions\n  }\n\n  type ArrayEmitsOptions = string[]\n\n  type ObjectEmitsOptions = { [key: string]: EmitValidator | null }\n\n  type EmitValidator = (...args: unknown[]) => boolean\n  ```\n\n- **详细信息**\n\n  可以以两种形式声明触发的事件：\n\n  - 使用字符串数组的简易形式。\n  - 使用对象的完整形式。该对象的每个属性键是事件的名称，值是 `null` 或一个验证函数。\n\n  验证函数会接收到传递给组件的 `$emit` 调用的额外参数。例如，如果 `this.$emit('foo', 1)` 被调用，`foo` 相应的验证函数将接受参数 `1`。验证函数应返回布尔值，以表明事件参数是否通过了验证。\n\n  注意，`emits` 选项会影响一个监听器被解析为组件事件监听器，还是原生 DOM 事件监听器。被声明为组件事件的监听器不会被透传到组件的根元素上，且将从组件的 `$attrs` 对象中移除。详见[透传 Attributes](/guide/components/attrs)。\n\n- **示例**\n\n  数组语法：\n\n  ```js\n  export default {\n    emits: ['check'],\n    created() {\n      this.$emit('check')\n    }\n  }\n  ```\n\n  对象语法：\n\n  ```js\n  export default {\n    emits: {\n      // 没有验证函数\n      click: null,\n\n      // 具有验证函数\n      submit: (payload) => {\n        if (payload.email && payload.password) {\n          return true\n        } else {\n          console.warn(`Invalid submit event payload!`)\n          return false\n        }\n      }\n    }\n  }\n  ```\n\n- **参考**\n  - [指南 - 透传 Attributes](/guide/components/attrs)\n  - [指南 - 为组件的 emits 标注类型](/guide/typescript/options-api#typing-component-emits) <sup class=\"vt-badge ts\" />\n\n## expose {#expose}\n\n用于声明当组件实例被父组件通过模板引用访问时暴露的公共属性。\n\n- **类型**\n\n  ```ts\n  interface ComponentOptions {\n    expose?: string[]\n  }\n  ```\n\n- **详细信息**\n\n  默认情况下，当通过 `$parent`、`$root` 或模板引用访问时，组件实例将向父组件暴露所有的实例属性。这可能不是我们希望看到的，因为组件很可能拥有一些应保持私有的内部状态或方法，以避免紧耦合。\n\n  `expose` 选项值应当是一个包含要暴露的属性名称字符串的数组。当使用 `expose` 时，只有显式列出的属性将在组件实例上暴露。\n\n  `expose` 仅影响用户定义的属性——它不会过滤掉内置的组件实例属性。\n\n- **示例**\n\n  ```js\n  export default {\n    // 只有 `publicMethod` 在公共实例上可用\n    expose: ['publicMethod'],\n    methods: {\n      publicMethod() {\n        // ...\n      },\n      privateMethod() {\n        // ...\n      }\n    }\n  }\n  ```\n\n\n\n================================================\nFILE: src/api/reactivity-advanced.md\n================================================\n# 响应式 API：进阶 {#reactivity-api-advanced}\n\n## shallowRef() {#shallowref}\n\n[`ref()`](./reactivity-core#ref) 的浅层作用形式。\n\n- **类型**\n\n  ```ts\n  function shallowRef<T>(value: T): ShallowRef<T>\n\n  interface ShallowRef<T> {\n    value: T\n  }\n  ```\n\n- **详细信息**\n\n  和 `ref()` 不同，浅层 ref 的内部值将会原样存储和暴露，并且不会被深层递归地转为响应式。只有对 `.value` 的访问是响应式的。\n\n  `shallowRef()` 常常用于对大型数据结构的性能优化或是与外部的状态管理系统集成。\n\n- **示例**\n\n  ```js\n  const state = shallowRef({ count: 1 })\n\n  // 不会触发更改\n  state.value.count = 2\n\n  // 会触发更改\n  state.value = { count: 2 }\n  ```\n\n- **参考**\n  - [指南 - 减少大型不可变结构的响应性开销](/guide/best-practices/performance#reduce-reactivity-overhead-for-large-immutable-structures)\n  - [指南 - 与其他状态系统集成](/guide/extras/reactivity-in-depth#integration-with-external-state-systems)\n\n## triggerRef() {#triggerref}\n\n强制触发依赖于一个[浅层 ref](#shallowref) 的副作用，这通常在对浅引用的内部值进行深度变更后使用。\n\n- **类型**\n\n  ```ts\n  function triggerRef(ref: ShallowRef): void\n  ```\n\n- **示例**\n\n  ```js\n  const shallow = shallowRef({\n    greet: 'Hello, world'\n  })\n\n  // 触发该副作用第一次应该会打印 \"Hello, world\"\n  watchEffect(() => {\n    console.log(shallow.value.greet)\n  })\n\n  // 这次变更不应触发副作用，因为这个 ref 是浅层的\n  shallow.value.greet = 'Hello, universe'\n\n  // 打印 \"Hello, universe\"\n  triggerRef(shallow)\n  ```\n\n## customRef() {#customref}\n\n创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。\n\n- **类型**\n\n  ```ts\n  function customRef<T>(factory: CustomRefFactory<T>): Ref<T>\n\n  type CustomRefFactory<T> = (\n    track: () => void,\n    trigger: () => void\n  ) => {\n    get: () => T\n    set: (value: T) => void\n  }\n  ```\n\n- **详细信息**\n\n  `customRef()` 预期接收一个工厂函数作为参数，这个工厂函数接受 `track` 和 `trigger` 两个函数作为参数，并返回一个带有 `get` 和 `set` 方法的对象。\n\n  一般来说，`track()` 应该在 `get()` 方法中调用，而 `trigger()` 应该在 `set()` 中调用。然而事实上，你对何时调用、是否应该调用他们有完全的控制权。\n\n- **示例**\n\n  创建一个防抖 ref，即只在最近一次 set 调用后的一段固定间隔后再调用：\n\n  ```js\n  import { customRef } from 'vue'\n\n  export function useDebouncedRef(value, delay = 200) {\n    let timeout\n    return customRef((track, trigger) => {\n      return {\n        get() {\n          track()\n          return value\n        },\n        set(newValue) {\n          clearTimeout(timeout)\n          timeout = setTimeout(() => {\n            value = newValue\n            trigger()\n          }, delay)\n        }\n      }\n    })\n  }\n  ```\n\n  在组件中使用：\n\n  ```vue\n  <script setup>\n  import { useDebouncedRef } from './debouncedRef'\n  const text = useDebouncedRef('hello')\n  </script>\n\n  <template>\n    <input v-model=\"text\" />\n  </template>\n  ```\n\n  [在演练场中尝试一下](https://play.vuejs.org/#eNplUkFugzAQ/MqKC1SiIekxIpEq9QVV1BMXCguhBdsyaxqE/PcuGAhNfYGd3Z0ZDwzeq1K7zqB39OI205UiaJGMOieiapTUBAOYFt/wUxqRYf6OBVgotGzA30X5Bt59tX4iMilaAsIbwelxMfCvWNfSD+Gw3++fEhFHTpLFuCBsVJ0ScgUQjw6Az+VatY5PiroHo3IeaeHANlkrh7Qg1NBL43cILUmlMAfqVSXK40QUOSYmHAZHZO0KVkIZgu65kTnWp8Qb+4kHEXfjaDXkhd7DTTmuNZ7MsGyzDYbz5CgSgbdppOBFqqT4l0eX1gZDYOm057heOBQYRl81coZVg9LQWGr+IlrchYKAdJp9h0C6KkvUT3A6u8V1dq4ASqRgZnVnWg04/QWYNyYzC2rD5Y3/hkDgz8fY/cOT1ZjqizMZzGY3rDPC12KGZYyd3J26M8ny1KKx7c3X25q1c1wrZN3L9LCMWs/+AmeG6xI=)\n\n  :::warning 谨慎使用\n  当使用 customRef 时，我们应该谨慎对待其 getter 的返回值，尤其是在每次运行 getter 时都生成新对象数据类型的情况下。当这样的 customRef 作为 prop 传递时，将影响父组件和子组件之间的关系。\n\n  父组件的渲染函数可能会被其他的响应式状态变化触发。在重新渲染过程中，我们会重新评估 customRef 的值，并返回一个新的对象数据类型作为子组件的 prop。这个 prop 会与其上一个值进行比较，由于两者不同，子组件中 customRef 的响应式依赖将被触发。与此同时，因为没有调用 customRef 的 setter，父组件中的响应式依赖不会运行。\n\n  [在演练场中尝试一下](https://play.vuejs.org/#eNqFVEtP3DAQ/itTS9Vm1ZCt1J6WBZUiDvTQIsoNcwiOkzU4tmU7+9Aq/71jO1mCWuhlN/PyfPP45kAujCk2HSdLsnLMCuPBcd+Zc6pEa7T1cADWOa/bW17nYMPPtvRsDT3UVrcww+DZ0flStybpKSkWQQqPU0IVVUwr58FYvdvDWXgpu6ek1pqSHL0fS0vJw/z0xbN1jUPHY/Ys87Zkzzl4K5qG2zmcnUN2oAqg4T6bQ/wENKNXNk+CxWKsSlmLTSk7XlhedYxnWclYDiK+MkQCoK4wnVtnIiBJuuEJNA2qPof7hzkEoc8DXgg9yzYTBBFgNr4xyY4FbaK2p6qfI0iqFgtgulOe27HyQRy69Dk1JXY9C03JIeQ6wg4xWvJCqFpnlNytOcyC2wzYulQNr0Ao+Mhw0KnTTEttl/CIaIJiMz8NGBHFtYetVrPwa58/IL48Zag4N0ssquNYLYBoW16J0vOkC3VQtVqk7cG9QcHz1kj0QAlgVYkNMFk6d0bJ1pbGYKUkmtD42HmvFfi94WhOEiXwjUnBnlEz9OLTJwy5qCo44D4O7en71SIFjI/F9VuG4jEy/GHQKq5hQrJAKOc4uNVighBF5/cygS0GgOMoK+HQb7+EWvLdMM7weVIJy5kXWi0Rj+xaNRhLKRp1IvB9hxYegA6WJ1xkUe9PcF4e9a+suA3YwYiC5MQ79KlFUzw5rZCZEUtoRWuE5PaXCXmxtuWIkpJSSr39EXXHQcWYNWfP/9A/uV3QUXJjueN2E1ZhtPnSIqGS+er3T77D76Ox1VUn0fsd4y3HfewCxuT2vVMVwp74RbTX8WQI1dy5qx12xI1Fpa1K5AreeEHCCN8q/QXul+LrSC3s4nh93jltkVPDIYt5KJkcIKStCReo4rVQ/CZI6dyEzToCCJu7hAtry/1QH/qXncQB400KJwqPxZHxEyona0xS/E3rt1m9Ld1rZl+uhaxecRtP3EjtgddCyimtXyj9H/Ii3eId7uOGTkyk/wOEbQ9h)\n\n  :::\n\n## shallowReactive() {#shallowreactive}\n\n[`reactive()`](./reactivity-core#reactive) 的浅层作用形式。\n\n- **类型**\n\n  ```ts\n  function shallowReactive<T extends object>(target: T): T\n  ```\n\n- **详细信息**\n\n  和 `reactive()` 不同，这里没有深层级的转换：一个浅层响应式对象里只有根级别的属性是响应式的。属性的值会被原样存储和暴露，这也意味着值为 ref 的属性**不会**被自动解包了。\n\n  :::warning 谨慎使用\n  浅层数据结构应该只用于组件中的根级状态。请避免将其嵌套在深层次的响应式对象中，因为它创建的树具有不一致的响应行为，这可能很难理解和调试。\n  :::\n\n- **示例**\n\n  ```js\n  const state = shallowReactive({\n    foo: 1,\n    nested: {\n      bar: 2\n    }\n  })\n\n  // 更改状态自身的属性是响应式的\n  state.foo++\n\n  // ...但下层嵌套对象不会被转为响应式\n  isReactive(state.nested) // false\n\n  // 不是响应式的\n  state.nested.bar++\n  ```\n\n## shallowReadonly() {#shallowreadonly}\n\n[`readonly()`](./reactivity-core#readonly) 的浅层作用形式\n\n- **类型**\n\n  ```ts\n  function shallowReadonly<T extends object>(target: T): Readonly<T>\n  ```\n\n- **详细信息**\n\n  和 `readonly()` 不同，这里没有深层级的转换：只有根层级的属性变为了只读。属性的值都会被原样存储和暴露，这也意味着值为 ref 的属性**不会**被自动解包了。\n\n  :::warning 谨慎使用\n  浅层数据结构应该只用于组件中的根级状态。请避免将其嵌套在深层次的响应式对象中，因为它创建的树具有不一致的响应行为，这可能很难理解和调试。\n  :::\n\n- **示例**\n\n  ```js\n  const state = shallowReadonly({\n    foo: 1,\n    nested: {\n      bar: 2\n    }\n  })\n\n  // 更改状态自身的属性会失败\n  state.foo++\n\n  // ...但可以更改下层嵌套对象\n  isReadonly(state.nested) // false\n\n  // 这是可以通过的\n  state.nested.bar++\n  ```\n\n## toRaw() {#toraw}\n\n根据一个 Vue 创建的代理返回其原始对象。\n\n- **类型**\n\n  ```ts\n  function toRaw<T>(proxy: T): T\n  ```\n\n- **详细信息**\n\n  `toRaw()` 可以返回由 [`reactive()`](./reactivity-core#reactive)、[`readonly()`](./reactivity-core#readonly)、[`shallowReactive()`](#shallowreactive) 或者 [`shallowReadonly()`](#shallowreadonly) 创建的代理对应的原始对象。\n\n  这是一个可以用于临时读取而不引起代理访问/跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。\n\n- **示例**\n\n  ```js\n  const foo = {}\n  const reactiveFoo = reactive(foo)\n\n  console.log(toRaw(reactiveFoo) === foo) // true\n  ```\n\n## markRaw() {#markraw}\n\n将一个对象标记为不可被转为代理。返回该对象本身。\n\n- **类型**\n\n  ```ts\n  function markRaw<T extends object>(value: T): T\n  ```\n\n- **示例**\n\n  ```js\n  const foo = markRaw({})\n  console.log(isReactive(reactive(foo))) // false\n\n  // 也适用于嵌套在其他响应性对象\n  const bar = reactive({ foo })\n  console.log(isReactive(bar.foo)) // false\n  ```\n\n  :::warning 谨慎使用\n  `markRaw()` 和类似 `shallowReactive()` 这样的浅层式 API 使你可以有选择地避开默认的深度响应/只读转换，并在状态关系谱中嵌入原始的、非代理的对象。它们可能出于各种各样的原因被使用：\n\n  - 有些值不应该是响应式的，例如复杂的第三方类实例或 Vue 组件对象。\n\n  - 当呈现带有不可变数据源的大型列表时，跳过代理转换可以提高性能。\n\n  这应该是一种进阶需求，因为只在根层能访问到原始值，所以如果把一个嵌套的、没有标记的原始对象设置成一个响应式对象，然后再次访问它，你获取到的是代理的版本。这可能会导致**对象身份风险**，即执行一个依赖于对象身份的操作，但却同时使用了同一对象的原始版本和代理版本：\n\n  ```js\n  const foo = markRaw({\n    nested: {}\n  })\n\n  const bar = reactive({\n    // 尽管 `foo` 被标记为了原始对象，但 foo.nested 却没有\n    nested: foo.nested\n  })\n\n  console.log(foo.nested === bar.nested) // false\n  ```\n\n  识别风险一般是很罕见的。然而，要正确使用这些 API，同时安全地避免这样的风险，需要你对响应性系统的工作方式有充分的了解。\n\n  :::\n\n## effectScope() {#effectscope}\n\n创建一个 effect 作用域，可以捕获其中所创建的响应式副作用 (即计算属性和侦听器)，这样捕获到的副作用可以一起处理。对于该 API 的使用细节，请查阅对应的 [RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md)。\n\n- **类型**\n\n  ```ts\n  function effectScope(detached?: boolean): EffectScope\n\n  interface EffectScope {\n    run<T>(fn: () => T): T | undefined // 如果作用域不活跃就为 undefined\n    stop(): void\n  }\n  ```\n\n- **示例**\n\n  ```js\n  const scope = effectScope()\n\n  scope.run(() => {\n    const doubled = computed(() => counter.value * 2)\n\n    watch(doubled, () => console.log(doubled.value))\n\n    watchEffect(() => console.log('Count: ', doubled.value))\n  })\n\n  // 处理掉当前作用域内的所有 effect\n  scope.stop()\n  ```\n\n## getCurrentScope() {#getcurrentscope}\n\n如果有的话，返回当前活跃的 [effect 作用域](#effectscope)。\n\n- **类型**\n\n  ```ts\n  function getCurrentScope(): EffectScope | undefined\n  ```\n\n## onScopeDispose() {#onscopedispose}\n\n在当前活跃的 [effect 作用域](#effectscope)上注册一个处理回调函数。当相关的 effect 作用域停止时会调用这个回调函数。\n\n这个方法可以作为可复用的组合式函数中 `onUnmounted` 的替代品，它并不与组件耦合，因为每一个 Vue 组件的 `setup()` 函数也是在一个 effect 作用域中调用的。\n\n如果在没有活跃的 effect 作用域的情况下调用此函数，将会抛出警告。在 3.5+ 版本中，可以通过将第二个参数设为 `true` 来消除此警告。\n\n- **类型**\n\n  ```ts\n  function onScopeDispose(fn: () => void, failSilently?: boolean): void\n  ```\n\n\n\n================================================\nFILE: src/api/reactivity-core.md\n================================================\n# 响应式 API：核心 {#reactivity-api-core}\n\n:::info 参考\n要更好地了解响应式 API，推荐阅读下面几个指南中的章节：\n\n- [响应式基础](/guide/essentials/reactivity-fundamentals) (with the API preference set to Composition API)\n- [深入响应式系统](/guide/extras/reactivity-in-depth)\n  :::\n\n## ref() {#ref}\n\n接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 `.value`。\n\n- **类型**\n\n  ```ts\n  function ref<T>(value: T): Ref<UnwrapRef<T>>\n\n  interface Ref<T> {\n    value: T\n  }\n  ```\n\n- **详细信息**\n\n  ref 对象是可更改的，也就是说你可以为 `.value` 赋予新的值。它也是响应式的，即所有对 `.value` 的操作都将被追踪，并且写操作会触发与之相关的副作用。\n\n  如果将一个对象赋值给 ref，那么这个对象将通过 [reactive()](#reactive) 转为具有深层次响应式的对象。这也意味着如果对象中包含了嵌套的 ref，它们将被深层地解包。\n\n  若要避免这种深层次的转换，请使用 [`shallowRef()`](./reactivity-advanced#shallowref) 来替代。\n\n- **示例**\n\n  ```js\n  const count = ref(0)\n  console.log(count.value) // 0\n\n  count.value = 1\n  console.log(count.value) // 1\n  ```\n\n- **参考**\n  - [指南 - `ref()` 的响应式基础](/guide/essentials/reactivity-fundamentals#reactive-variables-with-ref)\n  - [指南 - 为 `ref()` 标注类型](/guide/typescript/composition-api#typing-ref) <sup class=\"vt-badge ts\" />\n\n## computed() {#computed}\n\n接受一个 [getter 函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description)，返回一个只读的响应式 [ref](#ref) 对象。该 ref 通过 `.value` 暴露 getter 函数的返回值。它也可以接受一个带有 `get` 和 `set` 函数的对象来创建一个可写的 ref 对象。\n\n- **类型**\n\n  ```ts\n  // 只读\n  function computed<T>(\n    getter: (oldValue: T | undefined) => T,\n    // 查看下方的 \"计算属性调试\" 链接\n    debuggerOptions?: DebuggerOptions\n  ): Readonly<Ref<Readonly<T>>>\n\n  // 可写的\n  function computed<T>(\n    options: {\n      get: (oldValue: T | undefined) => T\n      set: (value: T) => void\n    },\n    debuggerOptions?: DebuggerOptions\n  ): Ref<T>\n  ```\n\n- **示例**\n\n  创建一个只读的计算属性 ref：\n\n  ```js\n  const count = ref(1)\n  const plusOne = computed(() => count.value + 1)\n\n  console.log(plusOne.value) // 2\n\n  plusOne.value++ // 错误\n  ```\n\n  创建一个可写的计算属性 ref：\n\n  ```js\n  const count = ref(1)\n  const plusOne = computed({\n    get: () => count.value + 1,\n    set: (val) => {\n      count.value = val - 1\n    }\n  })\n\n  plusOne.value = 1\n  console.log(count.value) // 0\n  ```\n\n  调试：\n\n  ```js\n  const plusOne = computed(() => count.value + 1, {\n    onTrack(e) {\n      debugger\n    },\n    onTrigger(e) {\n      debugger\n    }\n  })\n  ```\n\n- **参考**\n  - [指南 - 计算属性](/guide/essentials/computed)\n  - [指南 - 计算属性调试](/guide/extras/reactivity-in-depth#computed-debugging)\n  - [指南 - 为 `computed()` 标注类型](/guide/typescript/composition-api#typing-computed) <sup class=\"vt-badge ts\" />\n  - [指南 - 性能优化 - 计算属性稳定性](/guide/best-practices/performance#computed-stability)\n\n## reactive() {#reactive}\n\n返回一个对象的响应式代理。\n\n- **类型**\n\n  ```ts\n  function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\n  ```\n\n- **详细信息**\n\n  响应式转换是“深层”的：它会影响到所有嵌套的属性。一个响应式对象也将深层地解包任何 [ref](#ref) 属性，同时保持响应性。\n\n  值得注意的是，当访问到某个响应式数组或 `Map` 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包。\n\n  若要避免深层响应式转换，只想保留对这个对象顶层次访问的响应性，请使用 [shallowReactive()](./reactivity-advanced#shallowreactive) 作替代。\n\n  返回的对象以及其中嵌套的对象都会通过 [ES Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 包裹，因此**不等于**源对象，建议只使用响应式代理，避免使用原始对象。\n\n- **示例**\n\n  创建一个响应式对象：\n\n  ```js\n  const obj = reactive({ count: 0 })\n  obj.count++\n  ```\n\n  ref 的解包：\n\n  ```ts\n  const count = ref(1)\n  const obj = reactive({ count })\n\n  // ref 会被解包\n  console.log(obj.count === count.value) // true\n\n  // 会更新 `obj.count`\n  count.value++\n  console.log(count.value) // 2\n  console.log(obj.count) // 2\n\n  // 也会更新 `count` ref\n  obj.count++\n  console.log(obj.count) // 3\n  console.log(count.value) // 3\n  ```\n\n\t注意当访问到某个响应式数组或 `Map` 这样的原生集合类型中的 ref 元素时，**不会**执行 ref 的解包：\n\n  ```js\n  const books = reactive([ref('Vue 3 Guide')])\n  // 这里需要 .value\n  console.log(books[0].value)\n\n  const map = reactive(new Map([['count', ref(0)]]))\n  // 这里需要 .value\n  console.log(map.get('count').value)\n  ```\n\n  将一个 [ref](#ref) 赋值给一个 `reactive` 属性时，该 ref 会被自动解包：\n\n  ```ts\n  const count = ref(1)\n  const obj = reactive({})\n\n  obj.count = count\n\n  console.log(obj.count) // 1\n  console.log(obj.count === count.value) // true\n  ```\n\n- **参考**\n  - [指南 - 响应式基础](/guide/essentials/reactivity-fundamentals)\n  - [指南 - 为 `reactive()` 标注类型](/guide/typescript/composition-api#typing-reactive) <sup class=\"vt-badge ts\" />\n\n## readonly() {#readonly}\n\n接受一个对象 (不论是响应式还是普通的) 或是一个 [ref](#ref)，返回一个原值的只读代理。\n\n- **类型**\n\n  ```ts\n  function readonly<T extends object>(\n    target: T\n  ): DeepReadonly<UnwrapNestedRefs<T>>\n  ```\n\n- **详细信息**\n\n  只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的 ref 解包行为与 `reactive()` 相同，但解包得到的值是只读的。\n\n  要避免深层级的转换行为，请使用 [shallowReadonly()](./reactivity-advanced#shallowreadonly) 作替代。\n\n- **示例**\n\n  ```js\n  const original = reactive({ count: 0 })\n\n  const copy = readonly(original)\n\n  watchEffect(() => {\n    // 用来做响应性追踪\n    console.log(copy.count)\n  })\n\n  // 更改源属性会触发其依赖的侦听器\n  original.count++\n\n  // 更改该只读副本将会失败，并会得到一个警告\n  copy.count++ // warning!\n  ```\n\n## watchEffect() {#watcheffect}\n\n立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。\n\n- **类型**\n\n  ```ts\n  function watchEffect(\n    effect: (onCleanup: OnCleanup) => void,\n    options?: WatchEffectOptions\n  ): WatchHandle\n\n  type OnCleanup = (cleanupFn: () => void) => void\n\n  interface WatchEffectOptions {\n    flush?: 'pre' | 'post' | 'sync' // 默认：'pre'\n    onTrack?: (event: DebuggerEvent) => void\n    onTrigger?: (event: DebuggerEvent) => void\n  }\n\n  interface WatchHandle {\n    (): void // 可调用，与 `stop` 相同\n    pause: () => void\n    resume: () => void\n    stop: () => void\n  }\n  ```\n\n- **详细信息**\n\n  第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求 (参见下面的示例)。\n\n  第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。\n\n  默认情况下，侦听器将在组件渲染之前执行。设置 `flush: 'post'` 将会使侦听器延迟到组件渲染之后再执行。详见[回调的触发时机](/guide/essentials/watchers#callback-flush-timing)。在某些特殊情况下 (例如要使缓存失效)，可能有必要在响应式依赖发生改变时立即触发侦听器。这可以通过设置 `flush: 'sync'` 来实现。然而，该设置应谨慎使用，因为如果有多个属性同时更新，这将导致一些性能和数据一致性的问题。\n\n  返回值是一个用来停止该副作用的函数。\n\n- **示例**\n\n  ```js\n  const count = ref(0)\n\n  watchEffect(() => console.log(count.value))\n  // -> 输出 0\n\n  count.value++\n  // -> 输出 1\n  ```\n\n  停止侦听器：\n\n  ```js\n  const stop = watchEffect(() => {})\n\n  // 当不再需要此侦听器时:\n  stop()\n  ```\n\n  暂停/恢复侦听器：<sup class=\"vt-badge\" data-text=\"3.5+\" />\n\n  ```js\n  const { stop, pause, resume } = watchEffect(() => {})\n\n  // 暂停侦听器\n  pause()\n\n  // 稍后恢复\n  resume()\n\n  // 停止\n  stop()\n  ```\n\n  副作用清理：\n\n  ```js\n  watchEffect(async (onCleanup) => {\n    const { response, cancel } = doAsyncWork(newId)\n    // 如果 `id` 变化，则调用 `cancel`，\n    // 如果之前的请求未完成，则取消该请求\n    onCleanup(cancel)\n    data.value = await response\n  })\n  ```\n\n  3.5+ 中的副作用清理：\n\n  ```js\n  import { onWatcherCleanup } from 'vue'\n\n  watchEffect(async () => {\n    const { response, cancel } = doAsyncWork(newId)\n    // 如果 `id` 变化，则调用 `cancel`，\n    // 如果之前的请求未完成，则取消该请求\n    onWatcherCleanup(cancel)\n    data.value = await response\n  })\n  ```\n\n  选项：\n\n  ```js\n  watchEffect(() => {}, {\n    flush: 'post',\n    onTrack(e) {\n      debugger\n    },\n    onTrigger(e) {\n      debugger\n    }\n  })\n  ```\n\n- **参考**\n  - [指南 - 侦听器](/guide/essentials/watchers#watcheffect)\n  - [指南 - 侦听器调试](/guide/extras/reactivity-in-depth#watcher-debugging)\n\n## watchPostEffect() {#watchposteffect}\n\n[`watchEffect()`](#watcheffect) 使用 `flush: 'post'` 选项时的别名。\n\n## watchSyncEffect() {#watchsynceffect}\n\n[`watchEffect()`](#watcheffect) 使用 `flush: 'sync'` 选项时的别名。\n\n## watch() {#watch}\n\n侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。\n\n- **类型**\n\n  ```ts\n  // 侦听单个来源\n  function watch<T>(\n    source: WatchSource<T>,\n    callback: WatchCallback<T>,\n    options?: WatchOptions\n  ): WatchHandle\n\n  // 侦听多个来源\n  function watch<T>(\n    sources: WatchSource<T>[],\n    callback: WatchCallback<T[]>,\n    options?: WatchOptions\n  ): WatchHandle\n\n  type WatchCallback<T> = (\n    value: T,\n    oldValue: T,\n    onCleanup: (cleanupFn: () => void) => void\n  ) => void\n\n  type WatchSource<T> =\n    | Ref<T> // ref\n    | (() => T) // getter\n    | (T extends object ? T : never) // 响应式对象\n\n  interface WatchOptions extends WatchEffectOptions {\n    immediate?: boolean // 默认：false\n    deep?: boolean | number // 默认：false\n    flush?: 'pre' | 'post' | 'sync' // 默认：'pre'\n    onTrack?: (event: DebuggerEvent) => void\n    onTrigger?: (event: DebuggerEvent) => void\n    once?: boolean // 默认：false (3.4+)\n  }\n\n  interface WatchHandle {\n    (): void // 可调用，与 `stop` 相同\n    pause: () => void\n    resume: () => void\n    stop: () => void\n  }\n  ```\n\n  > 为了便于阅读，对类型进行了简化。\n\n- **详细信息**\n\n  `watch()` 默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。\n\n  第一个参数是侦听器的**源**。这个来源可以是以下几种：\n\n  - 一个函数，返回一个值\n  - 一个 ref\n  - 一个响应式对象\n  - ...或是由以上类型的值组成的数组\n\n  第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数。该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。\n\n  当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。\n\n  第三个可选的参数是一个对象，支持以下这些选项：\n\n  - **`immediate`**：在侦听器创建时立即触发回调。第一次调用时旧值是 `undefined`。\n  - **`deep`**：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。在 3.5+ 中，此参数还可以是指示最大遍历深度的数字。参考[深层侦听器](/guide/essentials/watchers#deep-watchers)。\n  - **`flush`**：调整回调函数的刷新时机。参考[回调的刷新时机](/guide/essentials/watchers#callback-flush-timing)及 [`watchEffect()`](/api/reactivity-core#watcheffect)。\n  - **`onTrack / onTrigger`**：调试侦听器的依赖。参考[调试侦听器](/guide/extras/reactivity-in-depth#watcher-debugging)。\n  - **`once`**：(3.4+) 回调函数只会运行一次。侦听器将在回调函数首次运行后自动停止。\n\n  与 [`watchEffect()`](#watcheffect) 相比，`watch()` 使我们可以：\n\n  - 懒执行副作用；\n  - 更加明确是应该由哪个状态触发侦听器重新执行；\n  - 可以访问所侦听状态的前一个值和当前值。\n\n- **示例**\n\n  侦听一个 getter 函数：\n\n  ```js\n  const state = reactive({ count: 0 })\n  watch(\n    () => state.count,\n    (count, prevCount) => {\n      /* ... */\n    }\n  )\n  ```\n\n  侦听一个 ref：\n\n  ```js\n  const count = ref(0)\n  watch(count, (count, prevCount) => {\n    /* ... */\n  })\n  ```\n\n  当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值：\n\n  ```js\n  watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {\n    /* ... */\n  })\n  ```\n\n  当使用 getter 函数作为源时，回调只在此函数的返回值变化时才会触发。如果你想让回调在深层级变更时也能触发，你需要使用 `{ deep: true }` 强制侦听器进入深层级模式。在深层级模式时，如果回调函数由于深层级的变更而被触发，那么新值和旧值将是同一个对象。\n\n  ```js\n  const state = reactive({ count: 0 })\n  watch(\n    () => state,\n    (newValue, oldValue) => {\n      // newValue === oldValue\n    },\n    { deep: true }\n  )\n  ```\n\n  当直接侦听一个响应式对象时，侦听器会自动启用深层模式：\n\n  ```js\n  const state = reactive({ count: 0 })\n  watch(state, () => {\n    /* 深层级变更状态所触发的回调 */\n  })\n  ```\n\n  `watch()` 和 [`watchEffect()`](#watcheffect) 享有相同的刷新时机和调试选项：\n\n  ```js\n  watch(source, callback, {\n    flush: 'post',\n    onTrack(e) {\n      debugger\n    },\n    onTrigger(e) {\n      debugger\n    }\n  })\n  ```\n\n  停止侦听器：\n\n  ```js\n  const stop = watch(source, callback)\n\n  // 当已不再需要该侦听器时：\n  stop()\n  ```\n\n  暂停/恢复侦听器：<sup class=\"vt-badge\" data-text=\"3.5+\" />\n\n  ```js\n  const { stop, pause, resume } = watch(() => {})\n\n  // 暂停侦听器\n  pause()\n\n  // 稍后恢复\n  resume()\n\n  // 停止\n  stop()\n  ```\n\n  副作用清理：\n\n  ```js\n  watch(id, async (newId, oldId, onCleanup) => {\n    const { response, cancel } = doAsyncWork(newId)\n    // 当 `id` 变化时，`cancel` 将被调用，\n    // 取消之前的未完成的请求\n    onCleanup(cancel)\n    data.value = await response\n  })\n  ```\n\n  3.5+ 中的副作用清理：\n\n  ```js\n  import { onWatcherCleanup } from 'vue'\n\n  watch(id, async (newId) => {\n    const { response, cancel } = doAsyncWork(newId)\n    onWatcherCleanup(cancel)\n    data.value = await response\n  })\n  ```\n\n- **参考**\n\n  - [指南 - 侦听器](/guide/essentials/watchers)\n  - [指南 - 侦听器调试](/guide/extras/reactivity-in-depth#watcher-debugging)\n\n## onWatcherCleanup() <sup class=\"vt-badge\" data-text=\"3.5+\" /> {#onwatchercleanup}\n\n注册一个清理函数，在当前侦听器即将重新运行时执行。只能在 `watchEffect` 作用函数或 `watch` 回调函数的同步执行期间调用 (即不能在异步函数的 `await` 语句之后调用)。\n\n- **类型**\n\n  ```ts\n  function onWatcherCleanup(\n    cleanupFn: () => void,\n    failSilently?: boolean\n  ): void\n  ```\n\n- **示例**\n\n  ```ts\n  import { watch, onWatcherCleanup } from 'vue'\n\n  watch(id, (newId) => {\n    const { response, cancel } = doAsyncWork(newId)\n    // 如果 `id` 变化，则调用 `cancel`，\n    // 如果之前的请求未完成，则取消该请求\n    onWatcherCleanup(cancel)\n  })\n  ```\n\n\n\n================================================\nFILE: src/api/reactivity-utilities.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/api/render-function.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/api/sfc-css-features.md\n================================================\n# 单文件组件 CSS 功能 {#sfc-css-features}\n\n## 组件作用域 CSS {#scoped-css}\n\n当 `<style>` 标签带有 `scoped` attribute 的时候，它的 CSS 只会影响当前组件的元素，和 Shadow DOM 中的样式封装类似。使用时有一些注意事项，不过好处是不需要任何的 polyfill。它的实现方式是通过 PostCSS 将以下内容：\n\n```vue\n<style scoped>\n.example {\n  color: red;\n}\n</style>\n\n<template>\n  <div class=\"example\">hi</div>\n</template>\n```\n\n转换为：\n\n```vue\n<style>\n.example[data-v-f3f3eg9] {\n  color: red;\n}\n</style>\n\n<template>\n  <div class=\"example\" data-v-f3f3eg9>hi</div>\n</template>\n```\n\n### 子组件的根元素 {#child-component-root-elements}\n\n使用 `scoped` 后，父组件的样式将不会渗透到子组件中。不过，子组件的根节点会同时被父组件的作用域样式和子组件的作用域样式影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。\n\n### 深度选择器 {#deep-selectors}\n\n处于 `scoped` 样式中的选择器如果想要做更“深度”的选择，也即：影响到子组件，可以使用 `:deep()` 这个伪类：\n\n```vue\n<style scoped>\n.a :deep(.b) {\n  /* ... */\n}\n</style>\n```\n\n上面的代码会被编译成：\n\n```css\n.a[data-v-f3f3eg9] .b {\n  /* ... */\n}\n```\n\n:::tip\n通过 `v-html` 创建的 DOM 内容不会被作用域样式影响，但你仍然可以使用深度选择器来设置其样式。\n:::\n\n### 插槽选择器 {#slotted-selectors}\n\n默认情况下，作用域样式不会影响到 `<slot/>` 渲染出来的内容，因为它们被认为是父组件所持有并传递进来的。使用 `:slotted` 伪类以明确地将插槽内容作为选择器的目标：\n\n```vue\n<style scoped>\n:slotted(div) {\n  color: red;\n}\n</style>\n```\n\n### 全局选择器 {#global-selectors}\n\n如果想让其中一个样式规则应用到全局，比起另外创建一个 `<style>`，可以使用 `:global` 伪类来实现 (看下面的代码)：\n\n```vue\n<style scoped>\n:global(.red) {\n  color: red;\n}\n</style>\n```\n\n### 混合使用局部与全局样式 {#mixing-local-and-global-styles}\n\n你也可以在同一个组件中同时包含作用域样式和非作用域样式：\n\n```vue\n<style>\n/* 全局样式 */\n</style>\n\n<style scoped>\n/* 局部样式 */\n</style>\n```\n\n### 作用域样式须知 {#scoped-style-tips}\n\n- **作用域样式并没有消除对 class 的需求**。由于浏览器渲染各种各样 CSS 选择器的方式，`p { color: red }` 结合作用域样式使用时 (即当与 attribute 选择器组合的时候) 会慢很多倍。如果你使用 class 或者 id 来替代，例如 `.example { color: red }`，那你几乎就可以避免性能的损失。\n\n- **小心递归组件中的后代选择器**！对于一个使用了 `.a .b` 选择器的样式规则来说，如果匹配到 `.a` 的元素包含了一个递归的子组件，那么所有的在那个子组件中的 `.b` 都会匹配到这条样式规则。\n\n## CSS Modules {#css-modules}\n\n一个 `<style module>` 标签会被编译为 [CSS Modules](https://github.com/css-modules/css-modules) 并且将生成的 CSS class 作为 `$style` 对象暴露给组件：\n\n```vue\n<template>\n  <p :class=\"$style.red\">This should be red</p>\n</template>\n\n<style module>\n.red {\n  color: red;\n}\n</style>\n```\n\n得出的 class 将被哈希化以避免冲突，实现了同样的将 CSS 仅作用于当前组件的效果。\n\n参考 [CSS Modules spec](https://github.com/css-modules/css-modules) 以查看更多详情，例如 [global exceptions](https://github.com/css-modules/css-modules/blob/master/docs/composition.md#exceptions) 和 [composition](https://github.com/css-modules/css-modules/blob/master/docs/composition.md#composition)。\n\n### 自定义注入名称 {#custom-inject-name}\n\n你可以通过给 `module` attribute 一个值来自定义注入 class 对象的属性名：\n\n```vue\n<template>\n  <p :class=\"classes.red\">red</p>\n</template>\n\n<style module=\"classes\">\n.red {\n  color: red;\n}\n</style>\n```\n\n### 与组合式 API 一同使用 {#usage-with-composition-api}\n\n可以通过 `useCssModule` API 在 `setup()` 和 `<script setup>` 中访问注入的 class。对于使用了自定义注入名称的 `<style module>` 块，`useCssModule` 接收一个匹配的 `module` attribute 值作为第一个参数：\n\n```js\nimport { useCssModule } from 'vue'\n\n// 在 setup() 作用域中...\n// 默认情况下，返回 <style module> 的 class\nuseCssModule()\n\n// 具名情况下，返回 <style module=\"classes\"> 的 class\nuseCssModule('classes')\n```\n\n- **示例**\n\n```vue\n<script setup lang=\"ts\">\nimport { useCssModule } from 'vue'\n\nconst classes = useCssModule()\n</script>\n\n<template>\n  <p :class=\"classes.red\">red</p>\n</template>\n\n<style module>\n.red {\n  color: red;\n}\n</style>\n```\n\n## CSS 中的 `v-bind()` {#v-bind-in-css}\n\n单文件组件的 `<style>` 标签支持使用 `v-bind` CSS 函数将 CSS 的值链接到动态的组件状态：\n\n```vue\n<template>\n  <div class=\"text\">hello</div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      color: 'red'\n    }\n  }\n}\n</script>\n\n<style>\n.text {\n  color: v-bind(color);\n}\n</style>\n```\n\n这个语法同样也适用于 [`<script setup>`](./sfc-script-setup)，且支持 JavaScript 表达式 (需要用引号包裹起来)：\n\n```vue\n<script setup>\nimport { ref } from 'vue'\nconst theme = ref({\n    color: 'red',\n})\n</script>\n\n<template>\n  <p>hello</p>\n</template>\n\n<style scoped>\np {\n  color: v-bind('theme.color');\n}\n</style>\n```\n\n实际的值会被编译成哈希化的 CSS 自定义属性，因此 CSS 本身仍然是静态的。自定义属性会通过内联样式的方式应用到组件的根元素上，并且在源值变更的时候响应式地更新。\n\n\n\n================================================\nFILE: src/api/sfc-script-setup.md\n================================================\n# \\<script setup> {#script-setup}\n\n`<script setup>` 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。当同时使用单文件组件与组合式 API 时该语法是默认推荐。相比于普通的 `<script>` 语法，它具有更多优势：\n\n- 更少的样板内容，更简洁的代码。\n- 能够使用纯 TypeScript 声明 props 和自定义事件。\n- 更好的运行时性能 (其模板会被编译成同一作用域内的渲染函数，避免了渲染上下文代理对象)。\n- 更好的 IDE 类型推导性能 (减少了语言服务器从代码中抽取类型的工作)。\n\n## 基本语法 {#basic-syntax}\n\n要启用该语法，需要在 `<script>` 代码块上添加 `setup` attribute：\n\n```vue\n<script setup>\nconsole.log('hello script setup')\n</script>\n```\n\n里面的代码会被编译成组件 `setup()` 函数的内容。这意味着与普通的 `<script>` 只在组件被首次引入的时候执行一次不同，`<script setup>` 中的代码会在**每次组件实例被创建的时候执行**。\n\n### 顶层的绑定会被暴露给模板 {#top-level-bindings-are-exposed-to-template}\n\n当使用 `<script setup>` 的时候，任何在 `<script setup>` 声明的顶层的绑定 (包括变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用：\n\n```vue\n<script setup>\n// 变量\nconst msg = 'Hello!'\n\n// 函数\nfunction log() {\n  console.log(msg)\n}\n</script>\n\n<template>\n  <button @click=\"log\">{{ msg }}</button>\n</template>\n```\n\nimport 导入的内容也会以同样的方式暴露。这意味着我们可以在模板表达式中直接使用导入的 helper 函数，而不需要通过 `methods` 选项来暴露它：\n\n```vue\n<script setup>\nimport { capitalize } from './helpers'\n</script>\n\n<template>\n  <div>{{ capitalize('hello') }}</div>\n</template>\n```\n\n## 响应式 {#reactivity}\n\n响应式状态需要明确使用[响应式 API](/api/reactivity-core) 来创建。和 `setup()` 函数的返回值一样，ref 在模板中使用的时候会自动解包：\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">{{ count }}</button>\n</template>\n```\n\n## 使用组件 {#using-components}\n\n`<script setup>` 范围里的值也能被直接作为自定义组件的标签名使用：\n\n```vue\n<script setup>\nimport MyComponent from './MyComponent.vue'\n</script>\n\n<template>\n  <MyComponent />\n</template>\n```\n\n这里 `MyComponent` 应当被理解为像是在引用一个变量。如果你使用过 JSX，此处的心智模型是类似的。其 kebab-case 格式的 `<my-component>` 同样能在模板中使用——不过，我们强烈建议使用 PascalCase 格式以保持一致性。同时这也有助于区分原生的自定义元素。\n\n### 动态组件 {#dynamic-components}\n\n由于组件是通过变量引用而不是基于字符串组件名注册的，在 `<script setup>` 中要使用动态组件的时候，应该使用动态的 `:is` 来绑定：\n\n```vue\n<script setup>\nimport Foo from './Foo.vue'\nimport Bar from './Bar.vue'\n</script>\n\n<template>\n  <component :is=\"Foo\" />\n  <component :is=\"someCondition ? Foo : Bar\" />\n</template>\n```\n\n请注意组件是如何在三元表达式中被当做变量使用的。\n\n### 递归组件 {#recursive-components}\n\n一个单文件组件可以通过它的文件名被其自己所引用。例如：名为 `FooBar.vue` 的组件可以在其模板中用 `<FooBar/>` 引用它自己。\n\n请注意这种方式相比于导入的组件优先级更低。如果有具名的导入和组件自身推导的名字冲突了，可以为导入的组件添加别名：\n\n```js\nimport { FooBar as FooBarChild } from './components'\n```\n\n### 命名空间组件 {#namespaced-components}\n\n可以使用带 `.` 的组件标签，例如 `<Foo.Bar>` 来引用嵌套在对象属性中的组件。这在需要从单个文件中导入多个组件的时候非常有用：\n\n```vue\n<script setup>\nimport * as Form from './form-components'\n</script>\n\n<template>\n  <Form.Input>\n    <Form.Label>label</Form.Label>\n  </Form.Input>\n</template>\n```\n\n## 使用自定义指令 {#using-custom-directives}\n\n全局注册的自定义指令将正常工作。本地的自定义指令在 `<script setup>` 中不需要显式注册，但他们必须遵循 `vNameOfDirective` 这样的命名规范：\n\n```vue\n<script setup>\nconst vMyDirective = {\n  beforeMount: (el) => {\n    // 在元素上做些操作\n  }\n}\n</script>\n<template>\n  <h1 v-my-directive>This is a Heading</h1>\n</template>\n```\n\n如果指令是从别处导入的，可以通过重命名来使其符合命名规范：\n\n```vue\n<script setup>\nimport { myDirective as vMyDirective } from './MyDirective.js'\n</script>\n```\n\n## defineProps() 和 defineEmits() {#defineprops-defineemits}\n\n为了在声明 `props` 和 `emits` 选项时获得完整的类型推导支持，我们可以使用 `defineProps` 和 `defineEmits` API，它们将自动地在 `<script setup>` 中可用：\n\n```vue\n<script setup>\nconst props = defineProps({\n  foo: String\n})\n\nconst emit = defineEmits(['change', 'delete'])\n// setup 代码\n</script>\n```\n\n- `defineProps` 和 `defineEmits` 都是只能在 `<script setup>` 中使用的**编译器宏**。他们不需要导入，且会随着 `<script setup>` 的处理过程一同被编译掉。\n\n- `defineProps` 接收与 `props` 选项相同的值，`defineEmits` 接收与 `emits` 选项相同的值。\n\n- `defineProps` 和 `defineEmits` 在选项传入后，会提供恰当的类型推导。\n\n- 传入到 `defineProps` 和 `defineEmits` 的选项会从 setup 中提升到模块的作用域。因此，传入的选项不能引用在 setup 作用域中声明的局部变量。这样做会引起编译错误。但是，它*可以*引用导入的绑定，因为它们也在模块作用域内。\n\n### 针对类型的 props/emit 声明<sup class=\"vt-badge ts\" /> {#type-only-props-emit-declarations}\n\nprops 和 emit 也可以通过给 `defineProps` 和 `defineEmits` 传递纯类型参数的方式来声明：\n\n```ts\nconst props = defineProps<{\n  foo: string\n  bar?: number\n}>()\n\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n\n// 3.3+：另一种更简洁的语法\nconst emit = defineEmits<{\n  change: [id: number] // 具名元组语法\n  update: [value: string]\n}>()\n```\n\n- `defineProps` 或 `defineEmits` 要么使用运行时声明，要么使用类型声明。同时使用两种声明方式会导致编译报错。\n\n- 使用类型声明的时候，静态分析会自动生成等效的运行时声明，从而在避免双重声明的前提下确保正确的运行时行为。\n\n  - 在开发模式下，编译器会试着从类型来推导对应的运行时验证。例如这里从 `foo: string` 类型中推断出 `foo: String`。如果类型是对导入类型的引用，这里的推导结果会是 `foo: null` (与 `any` 类型相等)，因为编译器没有外部文件的信息。\n\n  - 在生产模式下，编译器会生成数组格式的声明来减少打包体积 (这里的 props 会被编译成 `['foo', 'bar']`)。\n\n- 在 3.2 及以下版本中，`defineProps()` 的泛型类型参数只能使用类型字面量或者本地接口的引用。\n\n  这个限制已经在 3.3 版本中解决。最新版本的 Vue 支持在类型参数的位置引用导入的和有限的复杂类型。然而，由于类型到运行时的转换仍然基于 AST，因此并不支持使用需要实际类型分析的复杂类型，例如条件类型等。你可以在单个 prop 的类型上使用条件类型，但不能对整个 props 对象使用。\n\n### 响应式 Props 解构 <sup class=\"vt-badge\" data-text=\"3.5+\" /> {#reactive-props-destructure}\n\n在 Vue 3.5 及以上版本中，从 `defineProps` 返回值解构出的变量是响应式的。当在同一个 `<script setup>` 块中的代码访问从 `defineProps` 解构出的变量时，Vue 的编译器会自动在前面添加 `props.`。\n\n```ts\nconst { foo } = defineProps(['foo'])\n\nwatchEffect(() => {\n  // 在 3.5 之前仅运行一次\n  // 在 3.5+ 版本中会在 \"foo\" prop 改变时重新运行\n  console.log(foo)\n})\n```\n\n以上编译成以下等效内容：\n\n```js {5}\nconst props = defineProps(['foo'])\n\nwatchEffect(() => {\n  // `foo` 由编译器转换为 `props.foo`\n  console.log(props.foo)\n})\n```\n\n此外，你可以使用 JavaScript 原生的默认值语法声明 props 的默认值。这在使用基于类型的 props 声明时特别有用。\n\n```ts\ninterface Props {\n  msg?: string\n  labels?: string[]\n}\n\nconst { msg = 'hello', labels = ['one', 'two'] } = defineProps<Props>()\n```\n\n### 使用类型声明时的默认 props 值 <sup class=\"vt-badge ts\" /> {#default-props-values-when-using-type-declaration}\n\n在 3.5 及以上版本中，当使用响应式 Props 解构时，可以自然地声明默认值。但在 3.4 及以下版本中，默认情况下并未启用响应式 Props 解构。为了用基于类型声明的方式声明 props 的默认值，需要使用 `withDefaults` 编译器宏：\n\n```ts\ninterface Props {\n  msg?: string\n  labels?: string[]\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  msg: 'hello',\n  labels: () => ['one', 'two']\n})\n```\n\n上面代码会被编译为等价的运行时 props 的 `default` 选项。此外，`withDefaults` 辅助函数提供了对默认值的类型检查，并确保返回的 `props` 的类型删除了已声明默认值的属性的可选标志。\n\n:::info\n请注意，在使用 `withDefaults` 时，默认值为可变引用类型 (如数组或对象) 应该封装在函数中，以避免意外修改和外部副作用。这样可以确保每个组件实例都获得默认值的自己的副本。在使用默认值解构时，这**不**是必要的。\n:::\n\n## defineModel() {#definemodel}\n\n- 仅在 3.4+ 中可用\n\n这个宏可以用来声明一个双向绑定 prop，通过父组件的 `v-model` 来使用。[组件 `v-model`](/guide/components/v-model) 指南中也讨论了示例用法。\n\n在底层，这个宏声明了一个 model prop 和一个相应的值更新事件。如果第一个参数是一个字符串字面量，它将被用作 prop 名称；否则，prop 名称将默认为 `\"modelValue\"`。在这两种情况下，你都可以再传递一个额外的对象，它可以包含 prop 的选项和 model ref 的值转换选项。\n\n```js\n// 声明 \"modelValue\" prop，由父组件通过 v-model 使用\nconst model = defineModel()\n// 或者：声明带选项的 \"modelValue\" prop\nconst model = defineModel({ type: String })\n\n// 在被修改时，触发 \"update:modelValue\" 事件\nmodel.value = \"hello\"\n\n// 声明 \"count\" prop，由父组件通过 v-model:count 使用\nconst count = defineModel(\"count\")\n// 或者：声明带选项的 \"count\" prop\nconst count = defineModel(\"count\", { type: Number, default: 0 })\n\nfunction inc() {\n  // 在被修改时，触发 \"update:count\" 事件\n  count.value++\n}\n```\n\n:::warning\n如果为 `defineModel` prop 设置了一个 `default` 值且父组件没有为该 prop 提供任何值，会导致父组件与子组件之间不同步。在下面的示例中，父组件的 `myRef` 是 undefined，而子组件的 `model` 是 1：\n\n```vue [Child.vue]\n<script setup>\nconst model = defineModel({ default: 1 })\n</script>\n```\n\n```vue [Parent.vue]\n<script setup>\nconst myRef = ref()\n</script>\n\n<template>\n  <Child v-model=\"myRef\"></Child>\n</template>\n```\n\n:::\n\n### 修饰符和转换器 {#modifiers-and-transformers}\n\n为了获取 `v-model` 指令使用的修饰符，我们可以像这样解构 `defineModel()` 的返回值：\n\n```js\nconst [modelValue, modelModifiers] = defineModel()\n\n// 对应 v-model.trim\nif (modelModifiers.trim) {\n  // ...\n}\n```\n\n当存在修饰符时，我们可能需要在读取或将其同步回父组件时对其值进行转换。我们可以通过使用 `get` 和 `set` 转换器选项来实现这一点：\n\n```js\nconst [modelValue, modelModifiers] = defineModel({\n  // get() 省略了，因为这里不需要它\n  set(value) {\n    // 如果使用了 .trim 修饰符，则返回裁剪过后的值\n    if (modelModifiers.trim) {\n      return value.trim()\n    }\n    // 否则，原样返回\n    return value\n  }\n})\n```\n\n### 在 TypeScript 中使用 <sup class=\"vt-badge ts\" /> {#usage-with-typescript}\n\n与 `defineProps` 和 `defineEmits` 一样，`defineModel` 也可以接收类型参数来指定 model 值和修饰符的类型：\n\n```ts\nconst modelValue = defineModel<string>()\n//    ^? Ref<string | undefined>\n\n// 用带有选项的默认 model，设置 required 去掉了可能的 undefined 值\nconst modelValue = defineModel<string>({ required: true })\n//    ^? Ref<string>\n\nconst [modelValue, modifiers] = defineModel<string, \"trim\" | \"uppercase\">()\n//                 ^? Record<'trim' | 'uppercase', true | undefined>\n```\n\n## defineExpose() {#defineexpose}\n\n使用 `<script setup>` 的组件是**默认关闭**的——即通过模板引用或者 `$parent` 链获取到的组件的公开实例，**不会**暴露任何在 `<script setup>` 中声明的绑定。\n\n可以通过 `defineExpose` 编译器宏来显式指定在 `<script setup>` 组件中要暴露出去的属性：\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst a = 1\nconst b = ref(2)\n\ndefineExpose({\n  a,\n  b\n})\n</script>\n```\n\n当父组件通过模板引用的方式获取到当前组件的实例，获取到的实例会像这样 `{ a: number, b: number }` (ref 会和在普通实例中一样被自动解包)\n\n## defineOptions() {#defineoptions}\n\n- 仅在 3.3+ 中支持\n\n这个宏可以用来直接在 `<script setup>` 中声明组件选项，而不必使用单独的 `<script>` 块：\n\n```vue\n<script setup>\ndefineOptions({\n  inheritAttrs: false,\n  customOptions: {\n    /* ... */\n  }\n})\n</script>\n```\n\n- 这是一个宏定义，选项将会被提升到模块作用域中，无法访问 `<script setup>` 中不是字面常数的局部变量。\n\n## defineSlots() <sup class=\"vt-badge ts\"/> {#defineslots}\n\n- 仅在 3.3+ 中支持\n\n这个宏可以用于为 IDE 提供插槽名称和 props 类型检查的类型提示。\n\n`defineSlots()` 只接受类型参数，没有运行时参数。类型参数应该是一个类型字面量，其中属性键是插槽名称，值类型是插槽函数。函数的第一个参数是插槽期望接收的 props，其类型将用于模板中的插槽 props。返回类型目前被忽略，可以是 `any`，但我们将来可能会利用它来检查插槽内容。\n\n它还返回 `slots` 对象，该对象等同于在 setup 上下文中暴露或由 `useSlots()` 返回的 `slots` 对象。\n\n```vue\n<script setup lang=\"ts\">\nconst slots = defineSlots<{\n  default(props: { msg: string }): any\n}>()\n</script>\n```\n\n## `useSlots()` 和 `useAttrs()` {#useslots-useattrs}\n\n在 `<script setup>` 使用 `slots` 和 `attrs` 的情况应该是相对来说较为罕见的，因为可以在模板中直接通过 `$slots` 和 `$attrs` 来访问它们。在你的确需要使用它们的罕见场景中，可以分别用 `useSlots` 和 `useAttrs` 两个辅助函数：\n\n```vue\n<script setup>\nimport { useSlots, useAttrs } from 'vue'\n\nconst slots = useSlots()\nconst attrs = useAttrs()\n</script>\n```\n\n`useSlots` 和 `useAttrs` 是真实的运行时函数，它的返回与 `setupContext.slots` 和 `setupContext.attrs` 等价。它们同样也能在普通的组合式 API 中使用。\n\n## 与普通的 `<script>` 一起使用 {#usage-alongside-normal-script}\n\n`<script setup>` 可以和普通的 `<script>` 一起使用。普通的 `<script>` 在有这些需要的情况下或许会被使用到：\n\n- 声明无法在 `<script setup>` 中声明的选项，例如 `inheritAttrs` 或插件的自定义选项 (在 3.3+ 中可以通过 [`defineOptions`](/api/sfc-script-setup#defineoptions) 替代)。\n- 声明模块的具名导出 (named exports)。\n- 运行只需要在模块作用域执行一次的副作用，或是创建单例对象。\n\n```vue\n<script>\n// 普通 <script>，在模块作用域下执行 (仅一次)\nrunSideEffectOnce()\n\n// 声明额外的选项\nexport default {\n  inheritAttrs: false,\n  customOptions: {}\n}\n</script>\n\n<script setup>\n// 在 setup() 作用域中执行 (对每个实例皆如此)\n</script>\n```\n\n在同一组件中将 `<script setup>` 与 `<script>` 结合使用的支持仅限于上述情况。具体来说：\n\n- **不要**为已经可以用 `<script setup>` 定义的选项使用单独的 `<script>` 部分，如 `props` 和 `emits`。\n- 在 `<script setup>` 中创建的变量不会作为属性添加到组件实例中，这使得它们无法从选项式 API 中访问。我们强烈反对以这种方式混合 API。\n\n如果你发现自己处于以上任一不被支持的场景中，那么你应该考虑切换到一个显式的 [`setup()`](/api/composition-api-setup) 函数，而不是使用 `<script setup>`。\n\n## 顶层 `await` {#top-level-await}\n\n`<script setup>` 中可以使用顶层 `await`。结果代码会被编译成 `async setup()`：\n\n```vue\n<script setup>\nconst post = await fetch(`/api/post/1`).then((r) => r.json())\n</script>\n```\n\n另外，await 的表达式会自动编译成在 `await` 之后保留当前组件实例上下文的格式。\n\n:::warning 注意\n`async setup()` 必须与 [`Suspense`](/guide/built-ins/suspense.html) 组合使用，该特性目前仍处于实验阶段。我们计划在未来的版本中完成该特性并编写文档——但如果你现在就感兴趣，可以参考其[测试](https://github.com/vuejs/core/blob/main/packages/runtime-core/__tests__/components/Suspense.spec.ts)来了解其工作方式。\n:::\n\n## 导入语句 {#imports-statements}\n\nVue 中的导入语句遵循 [ECMAScript 模块规范](https://nodejs.org/api/esm.html)。\n此外，你还可以使用构建工具配置中定义的别名：\n\n```vue\n<script setup>\nimport { ref } from 'vue'\nimport { componentA } from './Components'\nimport { componentB } from '@/Components'\nimport { componentC } from '~/Components'\n</script>\n```\n\n## 泛型 <sup class=\"vt-badge ts\" /> {#generics}\n\n可以使用 `<script>` 标签上的 `generic` 属性声明泛型类型参数：\n\n```vue\n<script setup lang=\"ts\" generic=\"T\">\ndefineProps<{\n  items: T[]\n  selected: T\n}>()\n</script>\n```\n\n`generic` 的值与 TypeScript 中位于 `<...>` 之间的参数列表完全相同。例如，你可以使用多个参数，`extends` 约束，默认类型和引用导入的类型：\n\n```vue\n<script\n  setup\n  lang=\"ts\"\n  generic=\"T extends string | number, U extends Item\"\n>\nimport type { Item } from './types'\ndefineProps<{\n  id: T\n  list: U[]\n}>()\n</script>\n```\n\n当无法自动推断泛型组件的具体类型时，可使用指令 `@vue-generic` 来显式指定：\n\n```vue\n<template>\n  <!-- @vue-generic {import('@/api').Actor} -->\n  <ApiSelect v-model=\"peopleIds\" endpoint=\"/api/actors\" id-prop=\"actorId\" />\n\n  <!-- @vue-generic {import('@/api').Genre} -->\n  <ApiSelect v-model=\"genreIds\" endpoint=\"/api/genres\" id-prop=\"genreId\" />\n</template>\n```\n\n为了在 `ref` 中使用泛型组件的引用，你需要使用 [`vue-component-type-helpers`](https://www.npmjs.com/package/vue-component-type-helpers) 库，因为 `InstanceType` 在这种场景下不起作用。\n\n```vue\n<script\n  setup\n  lang=\"ts\"\n>\nimport componentWithoutGenerics from '../component-without-generics.vue';\nimport genericComponent from '../generic-component.vue';\n\nimport type { ComponentExposed } from 'vue-component-type-helpers';\n\n// 适用于没有泛型的组件\nref<InstanceType<typeof componentWithoutGenerics>>();\n\nref<ComponentExposed<typeof genericComponent>>();\n```\n\n## 限制 {#restrictions}\n\n- 由于模块执行语义的差异，`<script setup>` 中的代码依赖单文件组件的上下文。当将其移动到外部的 `.js` 或者 `.ts` 文件中的时候，对于开发者和工具来说都会感到混乱。因此，**`<script setup>`** 不能和 `src` attribute 一起使用。\n- `<script setup>` 不支持 DOM 内根组件模板。([相关讨论](https://github.com/vuejs/core/issues/8391))\n\n\n\n================================================\nFILE: src/api/sfc-spec.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/api/ssr.md\n================================================\n# 服务端渲染 API {#server-side-rendering-api}\n\n## renderToString() {#rendertostring}\n\n- **导出自 `vue/server-renderer`**\n\n- **类型**\n\n  ```ts\n  function renderToString(\n    input: App | VNode,\n    context?: SSRContext\n  ): Promise<string>\n  ```\n\n- **示例**\n\n  ```js\n  import { createSSRApp } from 'vue'\n  import { renderToString } from 'vue/server-renderer'\n\n  const app = createSSRApp({\n    data: () => ({ msg: 'hello' }),\n    template: `<div>{{ msg }}</div>`\n  })\n\n  ;(async () => {\n    const html = await renderToString(app)\n    console.log(html)\n  })()\n  ```\n\n  ### SSR 上下文 {#ssr-context}\n\n  你可以传入一个可选的上下文对象用来在渲染过程中记录额外的数据，例如[访问 Teleport 的内容](/guide/scaling-up/ssr#teleports)：\n\n  ```js\n  const ctx = {}\n  const html = await renderToString(app, ctx)\n\n  console.log(ctx.teleports) // { '#teleported': 'teleported content' }\n  ```\n\n  这个页面中的其他大多数 SSR API 也可以接受一个上下文对象。该上下文对象可以在组件代码里通过 [useSSRContext](#usessrcontext) 辅助函数进行访问。\n\n- **参考**[指南 - 服务端渲染 (SSR)](/guide/scaling-up/ssr)\n\n## renderToNodeStream() {#rendertonodestream}\n\n将输入渲染为一个 [Node.js Readable stream](https://nodejs.org/api/stream.html#stream_class_stream_readable) 实例。\n\n- **导出自 `vue/server-renderer`**\n\n- **类型**\n\n  ```ts\n  function renderToNodeStream(\n    input: App | VNode,\n    context?: SSRContext\n  ): Readable\n  ```\n\n- **示例**\n\n  ```js\n  // 在一个 Node.js http 处理函数内\n  renderToNodeStream(app).pipe(res)\n  ```\n\n  :::tip 备注\n  `vue/server-renderer` 的 ESM 构建不支持此方法，因为它是与 Node.js 环境分离的。请换为使用 [`pipeToNodeWritable`](#pipetonodewritable)。\n  :::\n\n## pipeToNodeWritable() {#pipetonodewritable}\n\n将输入渲染并 pipe 到一个 [Node.js Writable stream](https://nodejs.org/api/stream.html#stream_writable_streams) 实例。\n\n- **导出自 `vue/server-renderer`**\n\n- **类型**\n\n  ```ts\n  function pipeToNodeWritable(\n    input: App | VNode,\n    context: SSRContext = {},\n    writable: Writable\n  ): void\n  ```\n\n- **示例**\n\n  ```js\n  // 在一个 Node.js http 处理函数内\n  pipeToNodeWritable(app, {}, res)\n  ```\n\n## renderToWebStream() {#rendertowebstream}\n\n将输入渲染为一个 [Web ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) 实例。\n\n- **导出自 `vue/server-renderer`**\n\n- **类型**\n\n  ```ts\n  function renderToWebStream(\n    input: App | VNode,\n    context?: SSRContext\n  ): ReadableStream\n  ```\n\n- **示例**\n\n  ```js\n  // 在一个支持 ReadableStream 的环境下\n  return new Response(renderToWebStream(app))\n  ```\n\n  :::tip 备注\n  在不能全局暴露 `ReadableStream` 构造函数的环境下，请换为使用 [`pipeToWebWritable()`](#pipetowebwritable)。\n  :::\n\n## pipeToWebWritable() {#pipetowebwritable}\n\n将输入渲染并 pipe 到一个 [Web WritableStream](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream) 实例。\n\n- **导出自 `vue/server-renderer`**\n\n- **类型**\n\n  ```ts\n  function pipeToWebWritable(\n    input: App | VNode,\n    context: SSRContext = {},\n    writable: WritableStream\n  ): void\n  ```\n\n- **示例**\n\n  通常与 [`TransformStream`](https://developer.mozilla.org/en-US/docs/Web/API/TransformStream) 结合使用：\n\n  ```js\n  // 诸如 CloudFlare worker 这样的环境中，TransformStream 是可用的。\n  // 在 Node.js 中，TransformStream 需要从 'stream/web' 显示导入。\n  const { readable, writable } = new TransformStream()\n  pipeToWebWritable(app, {}, writable)\n\n  return new Response(readable)\n  ```\n\n## renderToSimpleStream() {#rendertosimplestream}\n\n通过一个简单的接口，将输入以 stream 模式进行渲染。\n\n- **导出自 `vue/server-renderer`**\n\n- **类型**\n\n  ```ts\n  function renderToSimpleStream(\n    input: App | VNode,\n    context: SSRContext,\n    options: SimpleReadable\n  ): SimpleReadable\n\n  interface SimpleReadable {\n    push(content: string | null): void\n    destroy(err: any): void\n  }\n  ```\n\n- **示例**\n\n  ```js\n  let res = ''\n\n  renderToSimpleStream(\n    app,\n    {},\n    {\n      push(chunk) {\n        if (chunk === null) {\n          // done\n          console(`render complete: ${res}`)\n        } else {\n          res += chunk\n        }\n      },\n      destroy(err) {\n        // error encountered\n      }\n    }\n  )\n  ```\n\n## useSSRContext() {#usessrcontext}\n\n一个运行时 API，用于获取已传递给 `renderToString()` 或其他服务端渲染 API 的上下文对象。\n\n- **类型**\n\n  ```ts\n  function useSSRContext<T = Record<string, any>>(): T | undefined\n  ```\n\n- **示例**\n\n  得到的上下文能够作为附加信息用于渲染最终的 HTML (例如 head 中的元数据)。\n\n  ```vue\n  <script setup>\n  import { useSSRContext } from 'vue'\n\n  // 确保只在服务端渲染时调用\n  // https://cn.vitejs.dev/guide/ssr.html#conditional-logic\n  if (import.meta.env.SSR) {\n    const ctx = useSSRContext()\n    // ...给上下文对象添加属性\n  }\n  </script>\n  ```\n\n## data-allow-mismatch <sup class=\"vt-badge\" data-text=\"3.5+\" /> {#data-allow-mismatch}\n\n可以消除[激活不匹配](/guide/scaling-up/ssr#hydration-mismatch)警告的特殊 attribute。\n\n- **示例**\n\n  ```html\n  <div data-allow-mismatch=\"text\">{{ data.toLocaleString() }}</div>\n  ```\n\n  值可以限制不匹配为特定类型。允许的值有：\n\n  - `text`\n  - `children` (仅允许直接子组件不匹配)\n  - `class`\n  - `style`\n  - `attribute`\n\n  如果没有提供值，则会允许所有类型的不匹配。\n\n\n\n================================================\nFILE: src/api/utility-types.md\n================================================\n# TypeScript 工具类型 {#utility-types}\n\n:::info\n此页面仅列出了一些可能需要解释其使用方式的常用工具类型。有关导出类型的完整列表，请查看[源代码](https://github.com/vuejs/core/blob/main/packages/runtime-core/src/index.ts#L131)。\n:::\n\n## PropType\\<T> {#proptype-t}\n\n用于在用运行时 props 声明时给一个 prop 标注更复杂的类型定义。\n\n- **示例**\n\n  ```ts\n  import type { PropType } from 'vue'\n\n  interface Book {\n    title: string\n    author: string\n    year: number\n  }\n\n  export default {\n    props: {\n      book: {\n        // 提供一个比 `Object` 更具体的类型\n        type: Object as PropType<Book>,\n        required: true\n      }\n    }\n  }\n  ```\n\n- **参考**[指南 - 为组件 props 标注类型](/guide/typescript/options-api#typing-component-props)\n\n## MaybeRef\\<T> {#mayberef}\n\n- 仅在 3.3+ 版本中支持。\n\n`T | Ref<T>` 的别名。对于标注[组合式函数](/guide/reusability/composables.html)的参数很有用。\n\n## MaybeRefOrGetter\\<T> {#maybereforgetter}\n\n- 仅在 3.3+ 版本中支持。\n\n`T | Ref<T> | (() => T)` 的别名。对于标注[组合式函数](/guide/reusability/composables.html)的参数很有用。\n\n## ExtractPropTypes\\<T> {#extractproptypes}\n\n从运行时的 props 选项对象中提取 props 类型。提取到的类型是面向内部的，也就是说组件接收到的是解析后的 props。这意味着 boolean 类型的 props 和带有默认值的 props 总是一个定义的值，即使它们不是必需的。\n\n要提取面向外部的 props，即父组件允许传递的 props，请使用 [`ExtractPublicPropTypes`](#extractpublicproptypes)。\n\n- **示例**\n\n  ```ts\n  const propsOptions = {\n    foo: String,\n    bar: Boolean,\n    baz: {\n      type: Number,\n      required: true\n    },\n    qux: {\n      type: Number,\n      default: 1\n    }\n  } as const\n\n  type Props = ExtractPropTypes<typeof propsOptions>\n  // {\n  //   foo?: string,\n  //   bar: boolean,\n  //   baz: number,\n  //   qux: number\n  // }\n  ```\n\n## ExtractPublicPropTypes\\<T> {#extractpublicproptypes}\n\n- 仅在 3.3+ 版本中支持。\n\n从运行时的 props 选项对象中提取 prop。提取的类型是面向外部的，即父组件允许传递的 props。\n\n- **示例**\n\n  ```ts\n  const propsOptions = {\n    foo: String,\n    bar: Boolean,\n    baz: {\n      type: Number,\n      required: true\n    },\n    qux: {\n      type: Number,\n      default: 1\n    }\n  } as const\n\n  type Props = ExtractPublicPropTypes<typeof propsOptions>\n  // {\n  //   foo?: string,\n  //   bar?: boolean,\n  //   baz: number,\n  //   qux?: number\n  // }\n  ```\n\n## ComponentCustomProperties {#componentcustomproperties}\n\n用于增强组件实例类型以支持自定义全局属性。\n\n- **示例**\n\n  ```ts\n  import axios from 'axios'\n\n  declare module 'vue' {\n    interface ComponentCustomProperties {\n      $http: typeof axios\n      $translate: (key: string) => string\n    }\n  }\n  ```\n\n  :::tip\n  类型扩展必须被放置在一个模块 `.ts` 或 `.d.ts` 文件中。查看[类型扩展指南](/guide/typescript/options-api#augmenting-global-properties)了解更多细节\n  :::\n\n- **参考**[指南 - 扩展全局属性](/guide/typescript/options-api#augmenting-global-properties)\n\n## ComponentCustomOptions {#componentcustomoptions}\n\n用来扩展组件选项类型以支持自定义选项。\n\n- **示例**\n\n  ```ts\n  import { Route } from 'vue-router'\n\n  declare module 'vue' {\n    interface ComponentCustomOptions {\n      beforeRouteEnter?(to: any, from: any, next: () => void): void\n    }\n  }\n  ```\n\n  :::tip\n  类型扩展必须被放置在一个模块 `.ts` 或 `.d.ts` 文件中。查看[类型扩展指南](/guide/typescript/options-api#augmenting-global-properties)了解更多细节。\n  :::\n\n- **参考**[指南 - 扩展自定义选项](/guide/typescript/options-api#augmenting-custom-options)\n\n## ComponentCustomProps {#componentcustomprops}\n\n用于扩展全局可用的 TSX props，以便在 TSX 元素上使用没有在组件选项上定义过的 props。\n\n- **示例**\n\n  ```ts\n  declare module 'vue' {\n    interface ComponentCustomProps {\n      hello?: string\n    }\n  }\n\n  export {}\n  ```\n\n  ```tsx\n  // 现在即使没有在组件选项上定义过 hello 这个 prop 也依然能通过类型检查了\n  <MyComponent hello=\"world\" />\n  ```\n\n  :::tip\n  类型扩展必须被放置在一个模块 `.ts` 或 `.d.ts` 文件中。查看[类型扩展指南](/guide/typescript/options-api#augmenting-global-properties)了解更多细节。\n  :::\n\n## CSSProperties {#cssproperties}\n\n用于扩展在样式属性绑定上允许的值的类型。\n\n- **示例**\n\n允许任意自定义 CSS 属性：\n\n  ```ts\n  declare module 'vue' {\n    interface CSSProperties {\n      [key: `--${string}`]: string\n    }\n  }\n  ```\n\n  ```tsx\n  <div style={ { '--bg-color': 'blue' } }>\n  ```\n\n  ```html\n  <div :style=\"{ '--bg-color': 'blue' }\"></div>\n  ```\n\n:::tip\n类型增强必须被放置在一个模块 `.ts` 或 `.d.ts` 文件中。查看[类型增强指南](/guide/typescript/options-api#augmenting-global-properties)了解更多细节。\n:::\n\n:::info 参考\n单文件组件 `<style>` 标签支持通过 `v-bind` CSS 函数来链接 CSS 值与组件状态。这允许在没有类型扩展的情况下自定义属性。\n\n- [CSS 中的 v-bind()](/api/sfc-css-features#v-bind-in-css)\n:::\n\n\n\n================================================\nFILE: src/ecosystem/newsletters.md\n================================================\n# 社区新闻简报 {#community-newsletters}\n\n社区有许多优秀的新闻简报 / Vue 相关博客，他们会为你带来 Vue 生态系统中最新的消息和动态。以下是我们收集到的一份较为活跃的不完全列表：\n\n- [Vue.js Feed](https://vuejsfeed.com/)\n- [Michael Thiessen](https://michaelnthiessen.com/newsletter)\n- [Jakub Andrzejewski](https://dev.to/jacobandrewsky)\n- [Weekly Vue News](https://weekly-vue.news/)\n- [Vue.js Developers Newsletter](https://vuejsdevelopers.com/newsletter/)\n\n如果你还知道其他优秀的内容，请使用[该链接](https://github.com/vuejs/docs/edit/main/src/ecosystem/newsletters.md)提交一个 pull request！\n\n\n\n================================================\nFILE: src/ecosystem/themes.md\n================================================\n---\npage: true\n---\n\n<script setup>\nimport ThemePage from './themes/ThemePage.vue'\n</script>\n\n<ThemePage />\n\n\n\n================================================\nFILE: src/ecosystem/themes/ThemeContact.vue\n================================================\n<template>\n  <aside class=\"ThemeContact\">\n    <p class=\"text\">\n      <slot />\n    </p>\n  </aside>\n</template>\n\n<style scoped>\n.ThemeContact {\n  padding: 32px 24px;\n  border-bottom: 1px solid var(--vt-c-divider-light);\n  background-color: var(--vt-c-bg-soft);\n  transition: border-color 0.25s, background-color 0.25s;\n}\n\n.dark .ThemeContact {\n  border-bottom-color: var(--vt-c-bg-soft);\n}\n\n@media (min-width: 768px) {\n  .ThemeContact {\n    padding: 48px 32px;\n  }\n}\n\n.container {\n  margin: 0 auto;\n  max-width: 960px;\n}\n\n.text {\n  text-align: center;\n  line-height: 24px;\n  font-size: 16px;\n  font-weight: 500;\n  transition: color 0.25s;\n}\n\n.text :deep(.link) {\n  color: var(--vt-c-brand);\n  white-space: nowrap;\n  transition: color 0.25s;\n}\n\n.text :deep(.link:hover) {\n  color: var(--vt-c-brand-dark);\n}\n</style>\n\n\n\n================================================\nFILE: src/ecosystem/themes/ThemeHero.vue\n================================================\n<template>\n  <div class=\"ThemeHero\">\n    <div class=\"container\">\n      <h1 class=\"title\">\n        <slot name=\"title\" />\n      </h1>\n      <p class=\"lead\">\n        <slot name=\"lead\" />\n      </p>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.ThemeHero {\n  padding: 48px 24px;\n}\n\n@media (min-width: 768px) {\n  .ThemeHero {\n    padding: 64px 32px 48px;\n  }\n}\n\n.container {\n  margin: 0 auto;\n  max-width: 960px;\n}\n\n.title,\n.lead {\n  transition: color 0.25s;\n}\n\n.title {\n  line-height: 32px;\n  font-size: 32px;\n  font-weight: 500;\n}\n\n@media (min-width: 768px) {\n  .title {\n    line-height: 40px;\n    font-size: 40px;\n  }\n}\n\n.lead {\n  padding-top: 8px;\n  font-size: 16px;\n  font-weight: 500;\n  max-width: 512px;\n  color: var(--vt-c-text-2);\n}\n</style>\n\n\n\n================================================\nFILE: src/ecosystem/themes/ThemeList.vue\n================================================\n<script setup lang=\"ts\">\nimport themes from './themes.json'\nimport ThemeListItem from './ThemeListItem.vue'\n</script>\n\n<template>\n  <div class=\"ThemeList\">\n    <div class=\"container\">\n      <div v-for=\"provider in themes\" :key=\"provider.name\" class=\"item\">\n        <ThemeListItem :provider=\"provider\" />\n      </div>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.ThemeList {\n  padding: 0 24px 96px;\n}\n\n@media (min-width: 768px) {\n  .ThemeList {\n    padding: 0 32px 96px;\n  }\n}\n\n.container {\n  margin: 0 auto;\n  max-width: 960px;\n}\n\n.item + .item {\n  padding-top: 48px;\n}\n\n@media (min-width: 768px) {\n  .item + .item {\n    padding-top: 64px;\n  }\n}\n</style>\n\n\n\n================================================\nFILE: src/ecosystem/themes/ThemeListItem.vue\n================================================\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport { VTLink } from '@vue/theme'\nimport ThemeProduct from './ThemeProduct.vue'\n\nconst props = defineProps<{\n  provider: Record<string, any>\n}>()\n\nconst description = computed(() => {\n  // replace markdown link to html tag.\n  // [name](https://...) -> <a href=\"https://...\">name</a>\n  return props.provider.description.replace(\n    /\\[([^\\]]+)\\]\\(([^\\)]+)\\)/g,\n    '<a href=\"$2\" class=\"link\" target=\"_blank\" rel=\"noopener\">$1</a>'\n  )\n})\n</script>\n\n<template>\n  <section class=\"ThemeListItem\">\n    <h2 class=\"title\">{{ provider.name }}</h2>\n    <p class=\"description\" v-html=\"description\" />\n\n    <div class=\"container\">\n      <div class=\"products\">\n        <div v-for=\"product in provider.products\" :key=\"product.name\" class=\"product\">\n          <ThemeProduct :product=\"product\" />\n        </div>\n      </div>\n    </div>\n\n    <div class=\"action\">\n      <VTLink class=\"action-link\" :href=\"provider.seeMoreUrl\" no-icon>\n        查看更多来自 {{ provider.name }} 的主题\n      </VTLink>\n    </div>\n  </section>\n</template>\n\n<style scoped>\n.ThemeListItem {\n  border-top: 1px solid var(--vt-c-divider-light);\n  padding-top: 16px;\n}\n\n@media (min-width: 768px) {\n  .ThemeListItem {\n    padding-top: 24px;\n  }\n}\n\n.title {\n  font-size: 20px;\n  font-weight: 500;\n  transition: color 0.25s;\n}\n\n.description {\n  padding-top: 8px;\n  font-size: 14px;\n  font-weight: 500;\n  max-width: 512px;\n  color: var(--vt-c-text-2);\n  transition: color 0.25s;\n}\n\n.description :deep(.link) {\n  color: var(--vt-c-brand);\n  transition: color 0.25s;\n}\n\n.description :deep(.link:hover) {\n  color: var(--vt-c-brand-dark);\n}\n\n.container {\n  margin: 0 auto;\n  padding-top: 32px;\n  max-width: 304px;\n}\n\n@media (min-width: 640px) {\n  .container {\n    max-width: 632px;\n  }\n}\n\n@media (min-width: 960px) {\n  .container {\n    max-width: 960px;\n  }\n}\n\n.products {\n  display: flex;\n  flex-wrap: wrap;\n  margin: -16px -12px;\n}\n\n.product {\n  flex-shrink: 0;\n  padding: 16px 12px;\n  width: 100%;\n}\n\n@media (min-width: 640px) {\n  .product {\n    width: 50%;\n  }\n}\n\n@media (min-width: 960px) {\n  .product {\n    width: calc(100% / 3);\n  }\n}\n\n.action {\n  padding-top: 40px;\n  text-align: center;\n}\n\n.action-link {\n  display: inline-block;\n  border: 1px solid var(--vt-c-brand);\n  border-radius: 24px;\n  padding: 0 24px;\n  line-height: 48px;\n  font-size: 14px;\n  font-weight: 500;\n  color: var(--vt-c-brand);\n  transition: border-color 0.25s, color 0.25s;\n}\n\n.action-link:hover {\n  border-color: var(--vt-c-brand-dark);\n  color: var(--vt-c-brand-dark);\n}\n</style>\n\n\n\n================================================\nFILE: src/ecosystem/themes/ThemePage.vue\n================================================\n<script setup lang=\"ts\">\nimport ThemeHero from './ThemeHero.vue'\nimport ThemeList from './ThemeList.vue'\nimport ThemeContact from './ThemeContact.vue'\n</script>\n\n<template>\n  <div class=\"ThemePage\">\n    <ThemeHero>\n      <template #title>主题</template>\n      <template #lead>查看主题、UI Kits 和插件。你可以看到我们的合作伙伴是如何用 Vue 构建一个真实世界的应用。</template>\n    </ThemeHero>\n\n    <ThemeList />\n\n    <ThemeContact>\n      想在这里介绍你的主题吗？ <a class=\"link\" href=\"mailto:evan@vuejs.org?subject=Theme+affiliation\">联系我们!</a>\n    </ThemeContact>\n  </div>\n</template>\n\n\n\n================================================\nFILE: src/ecosystem/themes/ThemeProduct.vue\n================================================\n<script setup lang=\"ts\">\nimport { VTLink } from '@vue/theme'\n\ndefineProps<{\n  product: Record<string, any>\n}>()\n</script>\n\n<template>\n  <VTLink class=\"ThemeProduct\" :href=\"product.url\" no-icon>\n    <article class=\"container\">\n      <figure class=\"figure\">\n        <img class=\"image\" :src=\"product.image\" :alt=\"product.name\">\n      </figure>\n\n      <div class=\"data\">\n        <div class=\"title\">\n          <h1 class=\"name\">{{ product.name }}</h1>\n          <p class=\"description\">{{ product.description }}</p>\n        </div>\n\n        <div class=\"price\">\n          <p v-if=\"product.price > 0\" class=\"value\">${{ product.price }}</p>\n          <p v-else class=\"free\">免费</p>\n        </div>\n      </div>\n    </article>\n  </VTLink>\n</template>\n\n<style scoped>\n.ThemeProduct {\n  display: block;\n}\n\n.ThemeProduct:hover .figure {\n  transform: translateY(-4px);\n}\n\n.ThemeProduct:hover .name {\n  color: var(--vt-c-brand);\n}\n\n.figure {\n  border-radius: 8px;\n  overflow: hidden;\n  transition: transform 0.25s;\n}\n\n.data {\n  display: flex;\n  justify-content: space-between;\n  padding-top: 12px;\n}\n\n.title {\n  flex-grow: 1;\n  padding-right: 8px;\n}\n\n.name {\n  font-size: 16px;\n  font-weight: 500;\n  transition: color 0.25s;\n}\n\n.description {\n  padding-top: 2px;\n  line-height: 20px;\n  font-size: 14px;\n  font-weight: 500;\n  color: var(--vt-c-text-2);\n  transition: color 0.25s;\n}\n\n.price {\n  text-align: right;\n  flex-shrink: 0;\n  width: 56px;\n}\n\n.value {\n  font-size: 16px;\n  font-weight: 500;\n}\n\n.free {\n  display: inline-block;\n  border-radius: 4px;\n  padding: 0 8px;\n  line-height: 24px;\n  font-size: 12px;\n  font-weight: 500;\n  color: var(--vt-c-white);\n  background-color: var(--vt-c-brand);\n  transform: translateY(-2px);\n}\n</style>\n\n\n\n================================================\nFILE: src/ecosystem/themes/themes.json\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/error-reference/errors.data.ts\n================================================\nimport { defineLoader } from 'vitepress'\nimport { errorMessages } from 'vue/compiler-sfc'\n// @ts-expect-error internal api\nimport { ErrorTypeStrings } from 'vue'\n\nfunction filterEmptyMsg(data: Record<number, string>) {\n  return Object.fromEntries(Object.entries(data).filter(([_, msg]) => msg))\n}\n\nexport default defineLoader({\n  load() {\n    return {\n      compiler: filterEmptyMsg(errorMessages),\n      runtime: filterEmptyMsg(ErrorTypeStrings)\n    }\n  }\n})\n\n\n\n================================================\nFILE: src/error-reference/ErrorsTable.vue\n================================================\n<script setup lang=\"ts\">\ndefineProps<{\n  kind: string\n  errors: Record<any, string>\n  highlight?: any\n}>()\n</script>\n\n<template>\n  <table>\n    <thead>\n      <tr>\n        <th>错误码</th>\n        <th>信息</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr\n        v-for=\"(msg, code) of errors\"\n        :class=\"{ highlight: highlight === `${kind}-${code}` }\"\n      >\n        <td :id=\"`${kind}-${code}`\" v-text=\"code\" />\n        <td v-text=\"msg\" />\n      </tr>\n    </tbody>\n  </table>\n</template>\n\n<style scoped>\n.highlight {\n  color: var(--vt-c-yellow-darker);\n  font-weight: bold;\n}\n</style>\n\n\n\n================================================\nFILE: src/error-reference/index.md\n================================================\n<script setup>\nimport { ref, onMounted } from 'vue'\nimport { data } from './errors.data.ts'\nimport ErrorsTable from './ErrorsTable.vue'\n\nconst highlight = ref()\nonMounted(() => {\n  highlight.value = location.hash.slice(1)\n})\n</script>\n\n# 生产环境错误代码参考 {#error-reference}\n\n## 运行时错误 {#runtime-errors}\n\n在生产环境中，传递给以下错误处理程序 API 的第三个参数是一个短代码，而不是含有完整信息的字符串：\n\n- [`app.config.errorHandler`](/api/application#app-config-errorhandler)\n- [`onErrorCaptured`](/api/composition-api-lifecycle#onerrorcaptured) (组合式 API)\n- [`errorCaptured`](/api/options-lifecycle#errorcaptured) (选项式 API)\n\n下表提供了代码和其原始的完整信息字符串的映射。\n\n<ErrorsTable kind=\"runtime\" :errors=\"data.runtime\" :highlight=\"highlight\" />\n\n## 编译错误 {#compiler-errors}\n\n下表提供了生产环境的编译错误代码与其原始消息的映射。\n\n<ErrorsTable kind=\"compiler\" :errors=\"data.compiler\" :highlight=\"highlight\" />\n\n\n\n================================================\nFILE: src/examples/ExampleRepl.vue\n================================================\n<script setup lang=\"ts\">\nimport { Repl, useStore, useVueImportMap } from '@vue/repl'\nimport CodeMirror from '@vue/repl/codemirror-editor'\nimport { data } from './examples.data'\nimport { inject, watchEffect, Ref, onMounted, ref, onUnmounted } from 'vue'\nimport {\n  resolveSFCExample,\n  resolveNoBuildExample,\n  onHashChange\n} from './utils'\n\nconst { vueVersion, defaultVersion, importMap } = useVueImportMap({\n  runtimeDev: () =>\n    `https://unpkg.com/vue@${\n      vueVersion.value || defaultVersion\n    }/dist/vue.esm-browser.js`\n})\nconst store = useStore({\n  vueVersion,\n  builtinImportMap: importMap\n})\n\nconst preferComposition = inject('prefer-composition') as Ref<boolean>\nconst preferSFC = inject('prefer-sfc') as Ref<boolean>\n\nwatchEffect(updateExample, {\n  onTrigger(e) {\n    console.log(e)\n    debugger\n  }\n})\nonHashChange(updateExample)\n\n/**\n * We perform some runtime logic to transform source files into different\n * API / format combinations:\n * - Options vs. Composition\n * - plain HTML vs. SFCs\n */\nfunction updateExample() {\n  let hash = location.hash.slice(1)\n  if (!data.hasOwnProperty(hash)) {\n    hash = 'hello-world'\n    location.hash = `#${hash}`\n  }\n  store.setFiles(\n    preferSFC.value\n      ? resolveSFCExample(data[hash], preferComposition.value)\n      : resolveNoBuildExample(data[hash], preferComposition.value),\n    preferSFC.value ? 'App.vue' : 'index.html'\n  )\n}\n\nconst heightProvider = ref<HTMLDivElement>()\nonMounted(() => {\n  const set = () => {\n    heightProvider.value!.style.setProperty(\n      '--vh',\n      window.innerHeight + 'px'\n    )\n  }\n  set()\n  window.addEventListener('resize', set)\n\n  onUnmounted(() => {\n    window.removeEventListener('resize', set)\n  })\n})\n</script>\n\n<template>\n  <div ref=\"heightProvider\">\n    <Repl\n      :editor=\"CodeMirror\"\n      :store=\"store\"\n      :showImportMap=\"!preferSFC\"\n      :showCompileOutput=\"false\"\n      :clearConsole=\"false\"\n    />\n  </div>\n</template>\n\n<style>\n.vue-repl {\n  max-width: 1105px;\n  border-right: 1px solid var(--vt-c-divider-light);\n  height: calc(\n    var(--vh, 0px) - var(--vt-nav-height) - var(--vt-banner-height, 0px)\n  );\n}\n\n@media (max-width: 960px) {\n  .vue-repl {\n    border: none;\n    height: calc(\n      var(--vh, 0px) - var(--vt-nav-height) - var(--vt-banner-height, 0px) -\n        48px\n    );\n  }\n}\n</style>\n\n\n\n================================================\nFILE: src/examples/examples.data.ts\n================================================\nimport fs from 'fs'\nimport path from 'path'\nimport type { ExampleData } from './utils'\n\nexport declare const data: Record<string, ExampleData>\n\nexport { ExampleData }\n\nexport default {\n  watch: 'src/**',\n  load() {\n    const srcDir = path.resolve(__dirname, './src')\n    return readExamples(srcDir)\n  }\n}\n\nexport function readExamples(srcDir: string): Record<string, ExampleData> {\n  const examples = fs.readdirSync(srcDir)\n  const data: Record<string, ExampleData> = {}\n  for (const name of examples) {\n    data[name] = readExample(path.join(srcDir, name))\n  }\n  return data\n}\n\nfunction readExample(dir: string): ExampleData {\n  const filenames = fs.readdirSync(dir)\n  const files: ExampleData = {}\n  for (const filename of filenames) {\n    const fullPath = path.join(dir, filename)\n    if (fs.statSync(fullPath).isDirectory()) {\n      if (filename === '_hint') {\n        files[filename] = readExample(fullPath)\n      } else {\n        files[filename] = readComponentDir(fullPath)\n      }\n    } else {\n      files[filename] = fs.readFileSync(fullPath, 'utf-8')\n    }\n  }\n\n  // fallback so that we can omit identical files in _hint\n  if (files._hint) {\n    for (const filename in files) {\n      if (filename !== '_hint') {\n        let hint = files._hint[filename]\n        if (!hint) {\n          hint = files._hint[filename] = {}\n        }\n        const original = files[filename]\n        if (typeof original !== 'string' && typeof hint !== 'string') {\n          for (const key in original) {\n            if (!(key in hint)) {\n              hint[key] = original[key]\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return files\n}\n\nfunction readComponentDir(dir: string): Record<string, string> {\n  const filenames = fs.readdirSync(dir)\n  const files: Record<string, string> = {}\n  for (const filename of filenames) {\n    let content = fs.readFileSync(path.join(dir, filename), 'utf-8')\n    if (!content.endsWith('\\n')) content += '\\n'\n    files[filename] = content\n  }\n  return files\n}\n\n\n\n================================================\nFILE: src/examples/index.md\n================================================\n---\npage: true\ntitle: Examples\naside: false\nfooter: false\noutline: false\n---\n\n<script>\nimport { defineAsyncComponent } from 'vue'\nimport ReplLoading from '@theme/components/ReplLoading.vue'\n\nexport default {\n  components: {\n    ExampleRepl: defineAsyncComponent({\n      loader: () => import('./ExampleRepl.vue'),\n      loadingComponent: ReplLoading\n    })\n  }\n}\n</script>\n\n<ClientOnly>\n  <ExampleRepl />\n</ClientOnly>\n\n\n\n================================================\nFILE: src/examples/utils.ts\n================================================\nimport { onBeforeUnmount } from 'vue'\n\nexport type ExampleData = {\n  [key: string]: string | Record<string, string>\n} & {\n  'import-map.json'?: string\n  _hint?: ExampleData\n}\n\nfunction indent(str: string): string {\n  return str\n    .split('\\n')\n    .map((l) => (l.trim() ? `  ${l}` : l))\n    .join('\\n')\n}\n\nfunction deindent(str: string, tabsize = 2): string {\n  return str\n    .split('\\n')\n    .map((l) => l.replace(tabsize === 1 ? /^\\s{2}/ : /^\\s{4}/, ''))\n    .join('\\n')\n}\n\nfunction toKebabTags(str: string): string {\n  return str\n    .replace(/(<\\/?)([A-Z]\\w+)(\\s|>)/g, (_, open, tagName, end) => {\n      return (\n        open + tagName.replace(/\\B([A-Z])/g, '-$1').toLowerCase() + end\n      )\n    })\n    .replace(/<([\\w-]+)([^/]*?)\\s?\\/>/g, (_, tagName, attrs) => {\n      return `<${tagName}${attrs}></${tagName}>`\n    })\n}\n\nfunction toScriptSetup(src: string, template: string): string {\n  const exportDefaultIndex = src.indexOf('export default')\n  const lastReturnIndex = src.lastIndexOf('return {')\n\n  let setupCode =\n    lastReturnIndex > -1\n      ? deindent(\n          src\n            .slice(exportDefaultIndex, lastReturnIndex)\n            .replace(/export default[^]+?setup\\([^)]*\\)\\s*{/, '')\n            .trim()\n        )\n      : ''\n\n  const propsStartIndex = src.indexOf(`\\n  props:`)\n  if (propsStartIndex > -1) {\n    const propsEndIndex = src.indexOf(`\\n  }`, propsStartIndex) + 4\n    const propsVar =\n      /\\bprops\\b/.test(template) || /\\bprops\\b/.test(src)\n        ? `const props = `\n        : ``\n    const propsDef = deindent(\n      src\n        .slice(propsStartIndex, propsEndIndex)\n        .trim()\n        .replace(/,$/, '')\n        .replace(/^props: /, `${propsVar}defineProps(`) + ')',\n      1\n    )\n    setupCode = (propsDef + '\\n\\n' + setupCode).trim()\n  }\n\n  const emitsStartIndex = src.indexOf(`\\n  emits:`)\n  if (emitsStartIndex > -1) {\n    const emitsEndIndex = src.indexOf(`]`, emitsStartIndex) + 1\n    const emitsDef =\n      src\n        .slice(emitsStartIndex, emitsEndIndex)\n        .trim()\n        .replace(/,$/, '')\n        .replace(/^emits: /, `const emit = defineEmits(`) + ')'\n    setupCode = (emitsDef + '\\n\\n' + setupCode).trim()\n  }\n\n  const res = src.slice(0, exportDefaultIndex) + setupCode\n  return (setupCode ? res : res.trim()) + '\\n'\n}\n\nfunction forEachComponent(\n  raw: ExampleData,\n  files: Record<string, string>,\n  cb: (filename: string, file: Record<string, string>) => void\n) {\n  for (const filename in raw) {\n    const content = raw[filename]\n    if (\n      filename === 'description.txt' ||\n      filename === 'description.md' ||\n      filename === '_hint'\n    ) {\n      continue\n    } else if (typeof content === 'string') {\n      files[filename] = content\n    } else {\n      const {\n        'template.html': template,\n        'composition.js': composition,\n        'options.js': options,\n        'style.css': style\n      } = content\n      cb(filename, { template, composition, options, style })\n    }\n  }\n}\n\nfunction injectCreateApp(src: string): string {\n  const importVueRE = /import {(.*?)} from 'vue'/\n  if (importVueRE.test(src)) {\n    src = src.replace(importVueRE, `import { createApp,$1} from 'vue'`)\n  } else {\n    const newline = src.startsWith(`import`) ? `\\n` : `\\n\\n`\n    src = `import { createApp } from 'vue'${newline}${src}`\n  }\n  return src.replace(\n    /export default ({[^]*\\n})/,\n    \"createApp($1).mount('#app')\"\n  )\n}\n\nexport function resolveSFCExample(\n  raw: ExampleData,\n  preferComposition: boolean\n) {\n  const files: Record<string, string> = {}\n  forEachComponent(\n    raw,\n    files,\n    (filename, { template, composition, options, style }) => {\n      const desc = raw['description.txt'] as string\n      let sfcContent =\n        desc && filename === 'App' ? `<!--\\n${desc.trim()}\\n-->\\n\\n` : ``\n      if (preferComposition && composition) {\n        sfcContent += `<script setup>\\n${toScriptSetup(\n          composition,\n          template\n        )}<\\/script>\\n\\n`\n      }\n      if (!preferComposition && options) {\n        sfcContent += `<script>\\n${options}<\\/script>\\n\\n`\n      }\n      sfcContent += `<template>\\n${indent(template)}</template>`\n      if (style) {\n        sfcContent += `\\n\\n<style>\\n${style}</style>`\n      }\n      files[filename + '.vue'] = sfcContent\n    }\n  )\n  return files\n}\n\nexport function resolveNoBuildExample(\n  raw: ExampleData,\n  preferComposition: boolean\n) {\n  const files: Record<string, string> = {}\n\n  const desc = raw['description.txt'] as string\n  let html = desc ? `<!--\\n${desc.trim()}\\n-->\\n\\n` : ``\n  let css = ''\n\n  // set it first for ordering\n  files['index.html'] = html\n  forEachComponent(\n    raw,\n    files,\n    (filename, { template, composition, options, style }) => {\n      let js = (preferComposition ? composition : options) || ''\n      // rewrite imports to *.vue\n      js = js.replace(\n        /import (.*) from '(.*)\\.vue'/g,\n        \"import $1 from '$2.js'\"\n      )\n\n      const _template = indent(toKebabTags(template).trim())\n      if (style) css += style\n\n      if (filename === 'App') {\n        if (js) {\n          html += `<script type=\"module\">\\n${injectCreateApp(\n            js\n          )}<\\/script>\\n\\n`\n        }\n        html += `<div id=\"app\">\\n${_template}\\n</div>`\n      } else {\n        // html += `\\n\\n<template id=\"${filename}\">\\n${_template}</template>`\n        if (js) {\n          js = js.replace(\n            /export default \\{([^]*)\\n\\}/,\n            `export default {$1,\\n  template: \\`\\n${_template}\\n  \\`\\n}`\n          )\n        } else {\n          js = `export default {\\n  template: \\`\\n${_template}\\n  \\`\\n}`\n        }\n        files[filename + '.js'] = js\n      }\n    }\n  )\n  files['index.html'] = html\n  if (css) {\n    files['style.css'] = css\n  }\n  return files\n}\n\nexport function onHashChange(cb: () => void) {\n  window.addEventListener('hashchange', cb)\n  onBeforeUnmount(() => {\n    window.removeEventListener('hashchange', cb)\n  })\n}\n\n\n\n================================================\nFILE: src/examples/src/attribute-bindings/description.txt\n================================================\n现在我们将元素的 attribute / property 响应式地绑定到状态上。\n这个 :title 语法是 v-bind:title 的简写。\n\n\n================================================\nFILE: src/examples/src/attribute-bindings/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const message = ref('Hello World!')\n    const isRed = ref(true)\n    const color = ref('green')\n\n    function toggleRed() {\n      isRed.value = !isRed.value\n    }\n\n    function toggleColor() {\n      color.value = color.value === 'green' ? 'blue' : 'green'\n    }\n\n    return {\n      message,\n      isRed,\n      color,\n      toggleRed,\n      toggleColor\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/attribute-bindings/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      message: 'Hello World!',\n      isRed: true,\n      color: 'green'\n    }\n  },\n  methods: {\n    toggleRed() {\n      this.isRed = !this.isRed\n    },\n    toggleColor() {\n      this.color = this.color === 'green' ? 'blue' : 'green'\n    }\n  }\n}\n\n\n================================================\nFILE: src/examples/src/attribute-bindings/App/style.css\n================================================\n.red {\n  color: red;\n}\n\n\n================================================\nFILE: src/examples/src/attribute-bindings/App/template.html\n================================================\n<p>\n  <span :title=\"message\">\n    Hover your mouse over me for a few seconds to see my dynamically bound title!\n  </span>\n</p>\n\n<!--\n除了普通字符串之外，\nclass 绑定还特别支持了对象和数组\n-->\n<p :class=\"{ red: isRed }\" @click=\"toggleRed\">\n  This should be red... but click me to toggle it.\n</p>\n\n<!-- 样式绑定也支持对象和数组 -->\n<p :style=\"{ color }\" @click=\"toggleColor\">\n  This should be green, and should toggle between green and blue on click.\n</p>\n\n\n\n================================================\nFILE: src/examples/src/cells/description.txt\n================================================\nhttps://eugenkiss.github.io/7guis/tasks/#cells\n\n\n================================================\nFILE: src/examples/src/cells/store.js\n================================================\nimport { reactive } from 'vue'\n\nconst COLS = 5\nconst ROWS = 20\n\nexport const cells = reactive(\n  Array.from(Array(COLS).keys()).map((i) =>\n    Array.from(Array(ROWS).keys()).map((i) => '')\n  )\n)\n\n// 原版 https://codesandbox.io/s/jotai-7guis-task7-cells-mzoit?file=/src/atoms.ts\n// 作者 @dai-shi\nexport function evalCell(exp) {\n  if (!exp.startsWith('=')) {\n    return exp\n  }\n\n  // = A1 + B2 ---> get(0,1) + get(1,2)\n  exp = exp\n    .slice(1)\n    .replace(\n      /\\b([A-Z])(\\d{1,2})\\b/g,\n      (_, c, r) => `get(${c.charCodeAt(0) - 65},${r})`\n    )\n\n  try {\n    return new Function('get', `return ${exp}`)(getCellValue)\n  } catch (e) {\n    return `#ERROR ${e}`\n  }\n}\n\nfunction getCellValue(c, r) {\n  const val = evalCell(cells[c][r])\n  const num = Number(val)\n  return Number.isFinite(num) ? num : val\n}\n\n\n\n================================================\nFILE: src/examples/src/cells/App/composition.js\n================================================\nimport Cell from './Cell.vue'\nimport { cells } from './store.js'\n\nexport default {\n  components: {\n    Cell\n  },\n  setup() {\n    const cols = cells.map((_, i) => String.fromCharCode(65 + i))\n    return {\n      cols,\n      cells\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/cells/App/options.js\n================================================\nimport Cell from './Cell.vue'\nimport { cells } from './store.js'\n\nexport default {\n  components: {\n    Cell\n  },\n  data() {\n    return {\n      cols: cells.map((_, i) => String.fromCharCode(65 + i)),\n      cells\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/cells/App/style.css\n================================================\nbody {\n  margin: 0;\n}\n\ntable {\n  border-collapse: collapse;\n  table-layout: fixed;\n  width: 100%;\n}\n\nth {\n  background-color: #eee;\n}\n\ntr:first-of-type th {\n  width: 100px;\n}\n\ntr:first-of-type th:first-of-type {\n  width: 25px;\n}\n\ntd {\n  border: 1px solid #ccc;\n  height: 1.5em;\n  overflow: hidden;\n}\n\n\n\n================================================\nFILE: src/examples/src/cells/App/template.html\n================================================\n<table>\n  <thead>\n    <tr>\n      <th></th>\n      <th v-for=\"c in cols\">{{ c }}</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr v-for=\"i in cells[0].length\">\n      <th>{{ i - 1 }}</th>\n      <td v-for=\"(c, j) in cols\">\n        <Cell :r=\"i - 1\" :c=\"j\"></Cell>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n\n\n================================================\nFILE: src/examples/src/cells/Cell/composition.js\n================================================\nimport { ref } from 'vue'\nimport { cells, evalCell } from './store.js'\n\nexport default {\n  props: {\n    c: Number,\n    r: Number\n  },\n  setup(props) {\n    const editing = ref(false)\n\n    function update(e) {\n      editing.value = false\n      cells[props.c][props.r] = e.target.value.trim()\n    }\n\n    return {\n      cells,\n      editing,\n      evalCell,\n      update\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/cells/Cell/options.js\n================================================\nimport { cells, evalCell } from './store.js'\n\nexport default {\n  props: {\n    c: Number,\n    r: Number\n  },\n  data() {\n    return {\n      editing: false,\n      cells\n    }\n  },\n  methods: {\n    evalCell,\n    update(e) {\n      this.editing = false\n      cells[this.c][this.r] = e.target.value.trim()\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/cells/Cell/style.css\n================================================\n.cell, .cell input {\n  height: 1.5em;\n  line-height: 1.5;\n  font-size: 15px;\n}\n\n.cell span {\n  padding: 0 6px;\n}\n\n.cell input {\n  width: 100%;\n  box-sizing: border-box;\n}\n\n\n================================================\nFILE: src/examples/src/cells/Cell/template.html\n================================================\n<div class=\"cell\" :title=\"cells[c][r]\" @click=\"editing = true\">\n  <input\n    v-if=\"editing\"\n    :value=\"cells[c][r]\"\n    @change=\"update\"\n    @blur=\"update\"\n    @vue:mounted=\"({ el }) => el.focus()\"\n  >\n  <span v-else>{{ evalCell(cells[c][r]) }}</span>\n</div>\n\n\n\n================================================\nFILE: src/examples/src/circle-drawer/description.txt\n================================================\nhttps://eugenkiss.github.io/7guis/tasks/#circle\n\n\n================================================\nFILE: src/examples/src/circle-drawer/App/composition.js\n================================================\nimport { ref, shallowReactive, toRaw } from 'vue'\n\nexport default {\n  setup() {\n    const history = shallowReactive([[]])\n    const index = ref(0)\n    const circles = ref([])\n    const selected = ref()\n    const adjusting = ref(false)\n\n    function onClick({ clientX: x, clientY: y }) {\n      if (adjusting.value) {\n        adjusting.value = false\n        selected.value = null\n        push()\n        return\n      }\n\n      selected.value = [...circles.value].reverse().find(({ cx, cy, r }) => {\n        const dx = cx - x\n        const dy = cy - y\n        return Math.sqrt(dx * dx + dy * dy) <= r\n      })\n\n      if (!selected.value) {\n        circles.value.push({\n          cx: x,\n          cy: y,\n          r: 50\n        })\n        push()\n      }\n    }\n\n    function adjust(circle) {\n      selected.value = circle\n      adjusting.value = true\n    }\n\n    function push() {\n      history.length = ++index.value\n      history.push(clone(circles.value))\n      console.log(toRaw(history))\n    }\n\n    function undo() {\n      circles.value = clone(history[--index.value])\n    }\n\n    function redo() {\n      circles.value = clone(history[++index.value])\n    }\n\n    function clone(circles) {\n      return circles.map((c) => ({ ...c }))\n    }\n\n    return {\n      history,\n      index,\n      circles,\n      selected,\n      adjusting,\n      onClick,\n      adjust,\n      undo,\n      redo\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/circle-drawer/App/options.js\n================================================\nfunction clone(circles) {\n  return circles.map((c) => ({ ...c }))\n}\n\nexport default {\n  data() {\n    return {\n      history: [[]],\n      index: 0,\n      circles: [],\n      selected: null,\n      adjusting: false\n    }\n  },\n  methods: {\n    onClick({ clientX: x, clientY: y }) {\n      if (this.adjusting) {\n        this.adjusting = false\n        this.selected = null\n        this.push()\n        return\n      }\n\n      this.selected = [...this.circles].reverse().find(({ cx, cy, r }) => {\n        const dx = cx - x\n        const dy = cy - y\n        return Math.sqrt(dx * dx + dy * dy) <= r\n      })\n\n      if (!this.selected) {\n        this.circles.push({\n          cx: x,\n          cy: y,\n          r: 50\n        })\n        this.push()\n      }\n    },\n\n    adjust(circle) {\n      this.selected = circle\n      this.adjusting = true\n    },\n\n    push() {\n      this.history.length = ++this.index\n      this.history.push(clone(this.circles))\n    },\n\n    undo() {\n      this.circles = clone(this.history[--this.index])\n    },\n\n    redo() {\n      this.circles = clone(this.history[++this.index])\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/circle-drawer/App/style.css\n================================================\nbody {\n  margin: 0;\n  overflow: hidden;\n}\n\nsvg {\n  width: 100vw;\n  height: 100vh;\n  background-color: #eee;\n}\n\ncircle {\n  stroke: #000;\n}\n\n.controls {\n  position: fixed;\n  top: 10px;\n  left: 0;\n  right: 0;\n  text-align: center;\n}\n\n.controls button + button {\n  margin-left: 6px;\n}\n\n.dialog {\n  position: fixed;\n  top: calc(50% - 50px);\n  left: calc(50% - 175px);\n  background: #fff;\n  width: 350px;\n  height: 100px;\n  padding: 5px 20px;\n  box-sizing: border-box;\n  border-radius: 4px;\n  text-align: center;\n  box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.25);\n}\n\n.dialog input {\n  display: block;\n  width: 200px;\n  margin: 0px auto;\n}\n\n.tip {\n  text-align: center;\n  padding: 0 50px;\n  color: #bbb;\n}\n\n\n================================================\nFILE: src/examples/src/circle-drawer/App/template.html\n================================================\n<svg @click=\"onClick\">\n  <foreignObject x=\"0\" y=\"40%\" width=\"100%\" height=\"200\">\n    <p class=\"tip\">\n      Click on the canvas to draw a circle. Click on a circle to select it.\n      Right-click on the canvas to adjust the radius of the selected circle.\n    </p>\n  </foreignObject>\n  <circle\n    v-for=\"circle in circles\"\n    :cx=\"circle.cx\"\n    :cy=\"circle.cy\"\n    :r=\"circle.r\"\n    :fill=\"circle === selected ? '#ccc' : '#fff'\"\n    @click=\"selected = circle\"\n    @contextmenu.prevent=\"adjust(circle)\"\n  ></circle>\n</svg>\n\n<div class=\"controls\">\n  <button @click=\"undo\" :disabled=\"index <= 0\">Undo</button>\n  <button @click=\"redo\" :disabled=\"index >= history.length - 1\">Redo</button>\n</div>\n\n<div class=\"dialog\" v-if=\"adjusting\" @click.stop>\n  <p>Adjust radius of circle at ({{ selected.cx }}, {{ selected.cy }})</p>\n  <input type=\"range\" v-model=\"selected.r\" min=\"1\" max=\"300\">\n</div>\n\n\n\n================================================\nFILE: src/examples/src/conditionals-and-loops/description.txt\n================================================\n我们可以通过 v-if 和 v-for 指令条件性地或循环地渲染内容。\n\n\n================================================\nFILE: src/examples/src/conditionals-and-loops/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const show = ref(true)\n    const list = ref([1, 2, 3])\n\n    return {\n      show,\n      list\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/conditionals-and-loops/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      show: true,\n      list: [1, 2, 3]\n    }\n  }\n}\n\n\n================================================\nFILE: src/examples/src/conditionals-and-loops/App/template.html\n================================================\n<button @click=\"show = !show\">Toggle List</button>\n<button @click=\"list.push(list.length + 1)\">Push Number</button>\n<button @click=\"list.pop()\">Pop Number</button>\n<button @click=\"list.reverse()\">Reverse List</button>\n\n<ul v-if=\"show && list.length\">\n  <li v-for=\"item of list\">{{ item }}</li>\n</ul>\n<p v-else-if=\"list.length\">List is not empty, but hidden.</p>\n<p v-else>List is empty.</p>\n\n\n\n================================================\nFILE: src/examples/src/counter/description.txt\n================================================\nhttps://eugenkiss.github.io/7guis/tasks/#counter\n\n\n================================================\nFILE: src/examples/src/counter/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    return {\n      count\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/counter/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  }\n}\n\n\n================================================\nFILE: src/examples/src/counter/App/template.html\n================================================\n{{ count }}\n<button @click=\"count++\">Count</button>\n\n\n================================================\nFILE: src/examples/src/crud/description.txt\n================================================\nhttps://eugenkiss.github.io/7guis/tasks/#crud\n\n\n================================================\nFILE: src/examples/src/crud/App/composition.js\n================================================\nimport { ref, reactive, computed, watch } from 'vue'\n\nexport default {\n  setup() {\n    const names = reactive(['Emil, Hans', 'Mustermann, Max', 'Tisch, Roman'])\n    const selected = ref('')\n    const prefix = ref('')\n    const first = ref('')\n    const last = ref('')\n\n    const filteredNames = computed(() =>\n      names.filter((n) =>\n        n.toLowerCase().startsWith(prefix.value.toLowerCase())\n      )\n    )\n\n    watch(selected, (name) => {\n      [last.value, first.value] = name.split(', ')\n    })\n\n    function create() {\n      if (hasValidInput()) {\n        const fullName = `${last.value}, ${first.value}`\n        if (!names.includes(fullName)) {\n          names.push(fullName)\n          first.value = last.value = ''\n        }\n      }\n    }\n\n    function update() {\n      if (hasValidInput() && selected.value) {\n        const i = names.indexOf(selected.value)\n        names[i] = selected.value = `${last.value}, ${first.value}`\n      }\n    }\n\n    function del() {\n      if (selected.value) {\n        const i = names.indexOf(selected.value)\n        names.splice(i, 1)\n        selected.value = first.value = last.value = ''\n      }\n    }\n\n    function hasValidInput() {\n      return first.value.trim() && last.value.trim()\n    }\n\n    return {\n      filteredNames,\n      selected,\n      prefix,\n      first,\n      last,\n      create,\n      update,\n      del\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/crud/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      names: ['Emil, Hans', 'Mustermann, Max', 'Tisch, Roman'],\n      selected: '',\n      prefix: '',\n      first: '',\n      last: ''\n    }\n  },\n  computed: {\n    filteredNames() {\n      return this.names.filter((n) =>\n        n.toLowerCase().startsWith(this.prefix.toLowerCase())\n      )\n    }\n  },\n  watch: {\n    selected(name) {\n      ;[this.last, this.first] = name.split(', ')\n    }\n  },\n  methods: {\n    create() {\n      if (this.hasValidInput()) {\n        const fullName = `${this.last}, ${this.first}`\n        if (!this.names.includes(fullName)) {\n          this.names.push(fullName)\n          this.first = this.last = ''\n        }\n      }\n    },\n    update() {\n      if (this.hasValidInput() && this.selected) {\n        const i = this.names.indexOf(this.selected)\n        this.names[i] = this.selected = `${this.last}, ${this.first}`\n      }\n    },\n    del() {\n      if (this.selected) {\n        const i = this.names.indexOf(this.selected)\n        this.names.splice(i, 1)\n        this.selected = this.first = this.last = ''\n      }\n    },\n    hasValidInput() {\n      return this.first.trim() && this.last.trim()\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/crud/App/style.css\n================================================\n* {\n  font-size: inherit;\n}\n\ninput {\n  display: block;\n  margin-bottom: 10px;\n}\n\nselect {\n  float: left;\n  margin: 0 1em 1em 0;\n  width: 14em;\n}\n\n.buttons {\n  clear: both;\n}\n\nbutton + button {\n  margin-left: 5px;\n}\n\n\n\n================================================\nFILE: src/examples/src/crud/App/template.html\n================================================\n<div><input v-model=\"prefix\" placeholder=\"Filter prefix\"></div>\n\n<select size=\"5\" v-model=\"selected\">\n  <option v-for=\"name in filteredNames\" :key=\"name\">{{ name }}</option>\n</select>\n\n<label>Name: <input v-model=\"first\"></label>\n<label>Surname: <input v-model=\"last\"></label>\n\n<div class=\"buttons\">\n  <button @click=\"create\">Create</button>\n  <button @click=\"update\">Update</button>\n  <button @click=\"del\">Delete</button>\n</div>\n\n\n\n================================================\nFILE: src/examples/src/fetching-data/description.txt\n================================================\n这个示例会通过 GitHub 的 API 获取最新的 Vue Core 提交信息并将其展示为列表。\n你可以在两个分支之间切换。\n\n\n\n================================================\nFILE: src/examples/src/fetching-data/App/composition.js\n================================================\nimport { ref, watchEffect } from 'vue'\n\nconst API_URL = `https://api.github.com/repos/vuejs/core/commits?per_page=3&sha=`\nconst branches = ['main', 'minor']\n\nexport default {\n  setup() {\n    const currentBranch = ref(branches[0])\n    const commits = ref([])\n\n    watchEffect(async () => {\n      // 该 effect 会立即运行，\n      // 并且在 currentBranch.value 改变时重新运行\n      const url = `${API_URL}${currentBranch.value}`\n      commits.value = await (await fetch(url)).json()\n    })\n\n    function truncate(v) {\n      const newline = v.indexOf('\\n')\n      return newline > 0 ? v.slice(0, newline) : v\n    }\n\n    function formatDate(v) {\n      return v.replace(/T|Z/g, ' ')\n    }\n\n    return {\n      branches,\n      currentBranch,\n      commits,\n      truncate,\n      formatDate\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/fetching-data/App/options.js\n================================================\nconst API_URL = `https://api.github.com/repos/vuejs/core/commits?per_page=3&sha=`\n\nexport default {\n  data: () => ({\n    branches: ['main', 'minor'],\n    currentBranch: 'main',\n    commits: []\n  }),\n\n  created() {\n    // 在初始化的时候进行获取\n    this.fetchData()\n  },\n\n  watch: {\n    // 当 currentBranch 改变时重新获取\n    currentBranch: 'fetchData'\n  },\n\n  methods: {\n    async fetchData() {\n      const url = `${API_URL}${this.currentBranch}`\n      this.commits = await (await fetch(url)).json()\n    },\n    truncate(v) {\n      const newline = v.indexOf('\\n')\n      return newline > 0 ? v.slice(0, newline) : v\n    },\n    formatDate(v) {\n      return v.replace(/T|Z/g, ' ')\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/fetching-data/App/style.css\n================================================\na {\n  text-decoration: none;\n  color: #42b883;\n}\nli {\n  line-height: 1.5em;\n  margin-bottom: 20px;\n}\n.author,\n.date {\n  font-weight: bold;\n}\n\n\n\n================================================\nFILE: src/examples/src/fetching-data/App/template.html\n================================================\n<h1>Latest Vue Core Commits</h1>\n<template v-for=\"branch in branches\">\n  <input type=\"radio\"\n    :id=\"branch\"\n    :value=\"branch\"\n    name=\"branch\"\n    v-model=\"currentBranch\">\n  <label :for=\"branch\">{{ branch }}</label>\n</template>\n<p>vuejs/core@{{ currentBranch }}</p>\n<ul v-if=\"commits.length > 0\">\n  <li v-for=\"{ html_url, sha, author, commit } in commits\" :key=\"sha\">\n    <a :href=\"html_url\" target=\"_blank\" class=\"commit\">{{ sha.slice(0, 7) }}</a>\n    - <span class=\"message\">{{ truncate(commit.message) }}</span><br>\n    by <span class=\"author\">\n      <a :href=\"author.html_url\" target=\"_blank\">{{ commit.author.name }}</a>\n    </span>\n    at <span class=\"date\">{{ formatDate(commit.author.date) }}</span>\n  </li>\n</ul>\n\n\n\n================================================\nFILE: src/examples/src/flight-booker/description.txt\n================================================\nhttps://eugenkiss.github.io/7guis/tasks/#flight\n\n\n================================================\nFILE: src/examples/src/flight-booker/App/composition.js\n================================================\nimport { ref, computed } from 'vue'\n\nexport default {\n  setup() {\n    const flightType = ref('one-way flight')\n    const departureDate = ref(dateToString(new Date()))\n    const returnDate = ref(departureDate.value)\n\n    const isReturn = computed(() => flightType.value === 'return flight')\n\n    const canBook = computed(\n      () =>\n        !isReturn.value ||\n        stringToDate(returnDate.value) > stringToDate(departureDate.value)\n    )\n\n    function book() {\n      alert(\n        isReturn.value\n          ? `You have booked a return flight leaving on ${departureDate.value} and returning on ${returnDate.value}.`\n          : `You have booked a one-way flight leaving on ${departureDate.value}.`\n      )\n    }\n\n    function stringToDate(str) {\n      const [y, m, d] = str.split('-')\n      return new Date(+y, m - 1, +d)\n    }\n\n    function dateToString(date) {\n      return (\n        date.getFullYear() +\n        '-' +\n        pad(date.getMonth() + 1) +\n        '-' +\n        pad(date.getDate())\n      )\n    }\n\n    function pad(n, s = String(n)) {\n      return s.length < 2 ? `0${s}` : s\n    }\n\n    return {\n      flightType,\n      departureDate,\n      returnDate,\n      isReturn,\n      canBook,\n      book\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/flight-booker/App/options.js\n================================================\nfunction stringToDate(str) {\n  const [y, m, d] = str.split('-')\n  return new Date(+y, m - 1, +d)\n}\n\nfunction dateToString(date) {\n  return (\n    date.getFullYear() +\n    '-' +\n    pad(date.getMonth() + 1) +\n    '-' +\n    pad(date.getDate())\n  )\n}\n\nfunction pad(n, s = String(n)) {\n  return s.length < 2 ? `0${s}` : s\n}\n\nexport default {\n  data() {\n    return {\n      flightType: 'one-way flight',\n      departureDate: dateToString(new Date()),\n      returnDate: dateToString(new Date())\n    }\n  },\n  computed: {\n    isReturn() {\n      return this.flightType === 'return flight'\n    },\n    canBook() {\n      return (\n        !this.isReturn ||\n        stringToDate(this.returnDate) > stringToDate(this.departureDate)\n      )\n    }\n  },\n  methods: {\n    book() {\n      alert(\n        this.isReturn\n          ? `You have booked a return flight leaving on ${this.departureDate} and returning on ${this.returnDate}.`\n        \t: `You have booked a one-way flight leaving on ${this.departureDate}.`\n      )\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/flight-booker/App/style.css\n================================================\nselect,\ninput,\nbutton {\n  display: block;\n  margin: 0.5em 0;\n  font-size: 15px;\n}\n\ninput[disabled] {\n  color: #999;\n}\n\np {\n  color: red;\n}\n\n\n================================================\nFILE: src/examples/src/flight-booker/App/template.html\n================================================\n<select v-model=\"flightType\">\n  <option value=\"one-way flight\">One-way Flight</option>\n  <option value=\"return flight\">Return Flight</option>\n</select>\n\n<input type=\"date\" v-model=\"departureDate\">\n<input type=\"date\" v-model=\"returnDate\" :disabled=\"!isReturn\">\n\n<button :disabled=\"!canBook\" @click=\"book\">Book</button>\n\n<p>{{ canBook ? '' : 'Return date must be after departure date.' }}</p>\n\n\n\n================================================\nFILE: src/examples/src/form-bindings/description.txt\n================================================\n我们可以使用 v-model 指令在状态和表单输入之间创建双向绑定。\n\n\n================================================\nFILE: src/examples/src/form-bindings/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const text = ref('Edit me')\n    const checked = ref(true)\n    const checkedNames = ref(['Jack'])\n    const picked = ref('One')\n    const selected = ref('A')\n    const multiSelected = ref(['A'])\n\n    return {\n      text,\n      checked,\n      checkedNames,\n      picked,\n      selected,\n      multiSelected\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/form-bindings/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      text: 'Edit me',\n      checked: true,\n      checkedNames: ['Jack'],\n      picked: 'One',\n      selected: 'A',\n      multiSelected: ['A']\n    }\n  }\n}\n\n\n================================================\nFILE: src/examples/src/form-bindings/App/template.html\n================================================\n<h2>Text Input</h2>\n<input v-model=\"text\">\n<p>{{ text }}</p>\n\n<h2>Checkbox</h2>\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n<label for=\"checkbox\">Checked: {{ checked }}</label>\n\n<!--\n  多个复选框可以绑定到\n  相同的 v-model 数组\n-->\n<h2>Multi Checkbox</h2>\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<label for=\"jack\">Jack</label>\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<label for=\"john\">John</label>\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n<label for=\"mike\">Mike</label>\n<p>Checked names: {{ checkedNames }}</p>\n\n<h2>Radio</h2>\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n<label for=\"one\">One</label>\n<br>\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n<label for=\"two\">Two</label>\n<p>Picked: {{ picked }}</p>\n\n<h2>Select</h2>\n<select v-model=\"selected\">\n  <option disabled value=\"\">Please select one</option>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n<p>Selected: {{ selected }}</p>\n\n<h2>Multi Select</h2>\n<select v-model=\"multiSelected\" multiple style=\"width:100px\">\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n<p>Selected: {{ multiSelected }}</p>\n\n\n\n================================================\nFILE: src/examples/src/grid/description.txt\n================================================\n该示例创建了一个可复用网格组件，并结合外部数据使用它。\n\n\n================================================\nFILE: src/examples/src/grid/App/composition.js\n================================================\nimport DemoGrid from './Grid.vue'\nimport { ref } from 'vue'\n\nexport default {\n  components: {\n    DemoGrid\n  },\n  setup() {\n    const searchQuery = ref('')\n    const gridColumns = ['name', 'power']\n    const gridData = [\n      { name: 'Chuck Norris', power: Infinity },\n      { name: 'Bruce Lee', power: 9000 },\n      { name: 'Jackie Chan', power: 7000 },\n      { name: 'Jet Li', power: 8000 }\n    ]\n\n    return {\n      searchQuery,\n      gridColumns,\n      gridData\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/grid/App/options.js\n================================================\nimport DemoGrid from './Grid.vue'\n\nexport default {\n  components: {\n    DemoGrid\n  },\n  data: () => ({\n    searchQuery: '',\n    gridColumns: ['name', 'power'],\n    gridData: [\n      { name: 'Chuck Norris', power: Infinity },\n      { name: 'Bruce Lee', power: 9000 },\n      { name: 'Jackie Chan', power: 7000 },\n      { name: 'Jet Li', power: 8000 }\n    ]\n  })\n}\n\n\n\n================================================\nFILE: src/examples/src/grid/App/template.html\n================================================\n<form id=\"search\">\n  Search <input name=\"query\" v-model=\"searchQuery\">\n</form>\n<DemoGrid\n  :data=\"gridData\"\n  :columns=\"gridColumns\"\n  :filter-key=\"searchQuery\">\n</DemoGrid>\n\n\n================================================\nFILE: src/examples/src/grid/Grid/composition.js\n================================================\nimport { ref, computed } from 'vue'\n\nexport default {\n  props: {\n    data: Array,\n    columns: Array,\n    filterKey: String\n  },\n  setup(props) {\n    const sortKey = ref('')\n    const sortOrders = ref(\n      props.columns.reduce((o, key) => ((o[key] = 1), o), {})\n    )\n\n    const filteredData = computed(() => {\n      let { data, filterKey } = props\n      if (filterKey) {\n        filterKey = filterKey.toLowerCase()\n        data = data.filter((row) => {\n          return Object.keys(row).some((key) => {\n            return String(row[key]).toLowerCase().indexOf(filterKey) > -1\n          })\n        })\n      }\n      const key = sortKey.value\n      if (key) {\n        const order = sortOrders.value[key]\n        data = data.slice().sort((a, b) => {\n          a = a[key]\n          b = b[key]\n          return (a === b ? 0 : a > b ? 1 : -1) * order\n        })\n      }\n      return data\n    })\n\n    function sortBy(key) {\n      sortKey.value = key\n      sortOrders.value[key] *= -1\n    }\n\n    function capitalize(str) {\n      return str.charAt(0).toUpperCase() + str.slice(1)\n    }\n\n    return {\n      sortKey,\n      sortOrders,\n      filteredData,\n      sortBy,\n      capitalize\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/grid/Grid/options.js\n================================================\nexport default {\n  props: {\n    data: Array,\n    columns: Array,\n    filterKey: String\n  },\n  data() {\n    return {\n      sortKey: '',\n      sortOrders: this.columns.reduce((o, key) => ((o[key] = 1), o), {})\n    }\n  },\n  computed: {\n    filteredData() {\n      const sortKey = this.sortKey\n      const filterKey = this.filterKey && this.filterKey.toLowerCase()\n      const order = this.sortOrders[sortKey] || 1\n      let data = this.data\n      if (filterKey) {\n        data = data.filter((row) => {\n          return Object.keys(row).some((key) => {\n            return String(row[key]).toLowerCase().indexOf(filterKey) > -1\n          })\n        })\n      }\n      if (sortKey) {\n        data = data.slice().sort((a, b) => {\n          a = a[sortKey]\n          b = b[sortKey]\n          return (a === b ? 0 : a > b ? 1 : -1) * order\n        })\n      }\n      return data\n    }\n  },\n  methods: {\n    sortBy(key) {\n      this.sortKey = key\n      this.sortOrders[key] = this.sortOrders[key] * -1\n    },\n    capitalize(str) {\n      return str.charAt(0).toUpperCase() + str.slice(1)\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/grid/Grid/style.css\n================================================\ntable {\n  border: 2px solid #42b983;\n  border-radius: 3px;\n  background-color: #fff;\n}\n\nth {\n  background-color: #42b983;\n  color: rgba(255, 255, 255, 0.66);\n  cursor: pointer;\n  user-select: none;\n}\n\ntd {\n  background-color: #f9f9f9;\n}\n\nth,\ntd {\n  min-width: 120px;\n  padding: 10px 20px;\n}\n\nth.active {\n  color: #fff;\n}\n\nth.active .arrow {\n  opacity: 1;\n}\n\n.arrow {\n  display: inline-block;\n  vertical-align: middle;\n  width: 0;\n  height: 0;\n  margin-left: 5px;\n  opacity: 0.66;\n}\n\n.arrow.asc {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-bottom: 4px solid #fff;\n}\n\n.arrow.dsc {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-top: 4px solid #fff;\n}\n\n\n\n================================================\nFILE: src/examples/src/grid/Grid/template.html\n================================================\n<table v-if=\"filteredData.length\">\n  <thead>\n    <tr>\n      <th v-for=\"key in columns\"\n        @click=\"sortBy(key)\"\n        :class=\"{ active: sortKey == key }\">\n        {{ capitalize(key) }}\n        <span class=\"arrow\" :class=\"sortOrders[key] > 0 ? 'asc' : 'dsc'\">\n        </span>\n      </th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr v-for=\"entry in filteredData\">\n      <td v-for=\"key in columns\">\n        {{entry[key]}}\n      </td>\n    </tr>\n  </tbody>\n</table>\n<p v-else>No matches found.</p>\n\n\n================================================\nFILE: src/examples/src/handling-input/description.txt\n================================================\n这个示例展示了如何通过 v-on 指令处理用户输入。\n\n\n================================================\nFILE: src/examples/src/handling-input/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const message = ref('Hello World!')\n\n    function reverseMessage() {\n      // 通过其 .value 属性\n      // 访问/修改一个 ref 的值。\n      message.value = message.value.split('').reverse().join('')\n    }\n\n    function notify() {\n      alert('navigation was prevented.')\n    }\n\n    return {\n      message,\n      reverseMessage,\n      notify\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/handling-input/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      message: 'Hello World!'\n    }\n  },\n  methods: {\n    reverseMessage() {\n      this.message = this.message.split('').reverse().join('')\n    },\n    notify() {\n      alert('navigation was prevented.')\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/handling-input/App/style.css\n================================================\nbutton, a {\n  display: block;\n  margin-bottom: 1em;\n}\n\n\n================================================\nFILE: src/examples/src/handling-input/App/template.html\n================================================\n<!--\n  注意我们不需要在模板中写 .value，\n  因为在模板中 ref 会自动“解包”。\n-->\n<h1>{{ message }}</h1>\n\n<!--\n  绑定到一个方法/函数。\n  这个 @click 语法是 v-on:click 的简写。\n-->\n<button @click=\"reverseMessage\">Reverse Message</button>\n\n<!-- 也可以写成一个内联表达式语句 -->\n<button @click=\"message += '!'\">Append \"!\"</button>\n\n<!--\n  Vue 也为一些像 e.preventDefault() 和 e.stopPropagation()\n  这样的常见任务提供了修饰符。\n-->\n<a href=\"https://vuejs.org\" @click.prevent=\"notify\">\n  A link with e.preventDefault()\n</a>\n\n\n\n================================================\nFILE: src/examples/src/hello-world/description.txt\n================================================\n跟 Vue 说 Hello World！\n\n\n================================================\nFILE: src/examples/src/hello-world/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    // “ref”是用来存储值的响应式数据源。\n    // 理论上我们在展示该字符串的时候不需要将其包装在 ref() 中，\n    // 但是在下一个示例中更改这个值的时候，我们就需要它了。\n    const message = ref('Hello World!')\n\n    return {\n      message\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/hello-world/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      message: 'Hello World!'\n    }\n  }\n}\n\n\n================================================\nFILE: src/examples/src/hello-world/App/template.html\n================================================\n<h1>{{ message }}</h1>\n\n\n================================================\nFILE: src/examples/src/list-transition/description.txt\n================================================\n通过内建的 <TransitionGroup> 实现“FLIP”列表过渡效果。\nhttps://aerotwist.com/blog/flip-your-animations/\n\n\n================================================\nFILE: src/examples/src/list-transition/import-map.json\n================================================\n{\n  \"imports\": {\n    \"lodash-es\": \"https://cdn.jsdelivr.net/npm/lodash-es/+esm\"\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/list-transition/App/composition.js\n================================================\nimport { shuffle as _shuffle } from 'lodash-es'\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const getInitialItems = () => [1, 2, 3, 4, 5]\n    const items = ref(getInitialItems())\n    let id = items.value.length + 1\n\n    function insert() {\n      const i = Math.round(Math.random() * items.value.length)\n      items.value.splice(i, 0, id++)\n    }\n\n    function reset() {\n      items.value = getInitialItems()\n      id = items.value.length + 1\n    }\n\n    function shuffle() {\n      items.value = _shuffle(items.value)\n    }\n\n    function remove(item) {\n      const i = items.value.indexOf(item)\n      if (i > -1) {\n        items.value.splice(i, 1)\n      }\n    }\n\n    return {\n      items,\n      insert,\n      reset,\n      shuffle,\n      remove\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/list-transition/App/options.js\n================================================\nimport { shuffle } from 'lodash-es'\n\nconst getInitialItems = () => [1, 2, 3, 4, 5]\nlet id = getInitialItems().length + 1\n\nexport default {\n  data() {\n    return {\n      items: getInitialItems()\n    }\n  },\n  methods: {\n    insert() {\n      const i = Math.round(Math.random() * this.items.length)\n      this.items.splice(i, 0, id++)\n    },\n    reset() {\n      this.items = getInitialItems()\n      id = getInitialItems().length + 1\n    },\n    shuffle() {\n      this.items = shuffle(this.items)\n    },\n    remove(item) {\n      const i = this.items.indexOf(item)\n      if (i > -1) {\n        this.items.splice(i, 1)\n      }\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/list-transition/App/style.css\n================================================\n.container {\n  position: relative;\n  padding: 0;\n  list-style-type: none;\n}\n\n.item {\n  width: 100%;\n  height: 30px;\n  background-color: #f3f3f3;\n  border: 1px solid #666;\n  box-sizing: border-box;\n}\n\n/* 1. 声明过渡效果 */\n.fade-move,\n.fade-enter-active,\n.fade-leave-active {\n  transition: all 0.5s cubic-bezier(0.55, 0, 0.1, 1);\n}\n\n/* 2. 声明进入和离开的状态 */\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n  transform: scaleY(0.01) translate(30px, 0);\n}\n\n/* 3. 确保离开的项目被移除出了布局流\n      以便正确地计算移动时的动画效果。 */\n.fade-leave-active {\n  position: absolute;\n}\n\n\n\n================================================\nFILE: src/examples/src/list-transition/App/template.html\n================================================\n<button @click=\"insert\">Insert at random index</button>\n<button @click=\"reset\">Reset</button>\n<button @click=\"shuffle\">Shuffle</button>\n\n<TransitionGroup tag=\"ul\" name=\"fade\" class=\"container\">\n  <li v-for=\"item in items\" class=\"item\" :key=\"item\">\n    {{ item }}\n    <button @click=\"remove(item)\">x</button>\n  </li>\n</TransitionGroup>\n\n\n\n================================================\nFILE: src/examples/src/markdown/description.txt\n================================================\n一个简单的 markdown 编辑器。\n\n\n================================================\nFILE: src/examples/src/markdown/import-map.json\n================================================\n{\n  \"imports\": {\n    \"marked\": \"https://cdn.jsdelivr.net/npm/marked/+esm\",\n    \"lodash-es\": \"https://cdn.jsdelivr.net/npm/lodash-es/+esm\"\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/markdown/App/composition.js\n================================================\nimport { marked } from 'marked'\nimport { debounce } from 'lodash-es'\nimport { ref, computed } from 'vue'\n\nexport default {\n  setup() {\n    const input = ref('# hello')\n\n    const output = computed(() => marked(input.value))\n\n    const update = debounce((e) => {\n      input.value = e.target.value\n    }, 100)\n\n    return {\n      input,\n      output,\n      update\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/markdown/App/options.js\n================================================\nimport { marked } from 'marked'\nimport { debounce } from 'lodash-es'\n\nexport default {\n  data: () => ({\n    input: '# hello'\n  }),\n  computed: {\n    output() {\n      return marked(this.input)\n    }\n  },\n  methods: {\n    update: debounce(function (e) {\n      this.input = e.target.value\n    }, 100)\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/markdown/App/style.css\n================================================\nbody {\n  margin: 0;\n}\n\n.editor {\n  height: 100vh;\n  display: flex;\n}\n\n.input,\n.output {\n  overflow: auto;\n  width: 50%;\n  height: 100%;\n  box-sizing: border-box;\n  padding: 0 20px;\n}\n\n.input {\n  border: none;\n  border-right: 1px solid #ccc;\n  resize: none;\n  outline: none;\n  background-color: #f6f6f6;\n  font-size: 14px;\n  font-family: 'Monaco', courier, monospace;\n  padding: 20px;\n}\n\ncode {\n  color: #f66;\n}\n\n\n\n================================================\nFILE: src/examples/src/markdown/App/template.html\n================================================\n<div class=\"editor\">\n  <textarea class=\"input\" :value=\"input\" @input=\"update\"></textarea>\n  <div class=\"output\" v-html=\"output\"></div>\n</div>\n\n\n\n================================================\nFILE: src/examples/src/modal/description.txt\n================================================\n可定制插槽和 CSS 过渡效果的模态框组件。\n\n\n================================================\nFILE: src/examples/src/modal/App/composition.js\n================================================\nimport Modal from './Modal.vue'\nimport { ref } from 'vue'\n\nexport default {\n  components: {\n    Modal\n  },\n  setup() {\n    const showModal = ref(false)\n\n    return {\n      showModal\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/modal/App/options.js\n================================================\nimport Modal from './Modal.vue'\n\nexport default {\n  components: {\n    Modal\n  },\n  data() {\n    return {\n      showModal: false\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/modal/App/template.html\n================================================\n<button id=\"show-modal\" @click=\"showModal = true\">Show Modal</button>\n\n<Teleport to=\"body\">\n  <!-- 使用这个 modal 组件，传入 prop -->\n  <modal :show=\"showModal\" @close=\"showModal = false\">\n    <template #header>\n      <h3>Custom Header</h3>\n    </template>\n  </modal>\n</Teleport>\n\n\n\n================================================\nFILE: src/examples/src/modal/Modal/composition.js\n================================================\nexport default {\n  props: {\n    show: Boolean\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/modal/Modal/options.js\n================================================\nexport default {\n  props: {\n    show: Boolean\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/modal/Modal/style.css\n================================================\n.modal-mask {\n  position: fixed;\n  z-index: 9998;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.5);\n  display: flex;\n  transition: opacity 0.3s ease;\n}\n\n.modal-container {\n  width: 300px;\n  margin: auto;\n  padding: 20px 30px;\n  background-color: #fff;\n  border-radius: 2px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.33);\n  transition: all 0.3s ease;\n}\n\n.modal-header h3 {\n  margin-top: 0;\n  color: #42b983;\n}\n\n.modal-body {\n  margin: 20px 0;\n}\n\n.modal-default-button {\n  float: right;\n}\n\n/*\n * 对于 transition=\"modal\" 的元素来说\n * 当通过 Vue.js 切换它们的可见性时\n * 以下样式会被自动应用。\n *\n * 你可以简单地通过编辑这些样式\n * 来体验该模态框的过渡效果。\n */\n\n.modal-enter-from {\n  opacity: 0;\n}\n\n.modal-leave-to {\n  opacity: 0;\n}\n\n.modal-enter-from .modal-container,\n.modal-leave-to .modal-container {\n  -webkit-transform: scale(1.1);\n  transform: scale(1.1);\n}\n\n\n\n================================================\nFILE: src/examples/src/modal/Modal/template.html\n================================================\n<Transition name=\"modal\">\n  <div v-if=\"show\" class=\"modal-mask\">\n    <div class=\"modal-container\">\n      <div class=\"modal-header\">\n        <slot name=\"header\">default header</slot>\n      </div>\n\n      <div class=\"modal-body\">\n        <slot name=\"body\">default body</slot>\n      </div>\n\n      <div class=\"modal-footer\">\n        <slot name=\"footer\">\n          default footer\n          <button\n            class=\"modal-default-button\"\n            @click=\"$emit('close')\"\n          >OK</button>\n        </slot>\n      </div>\n    </div>\n  </div>\n</Transition>\n\n\n\n================================================\nFILE: src/examples/src/simple-component/description.txt\n================================================\n这里展示了最简单的组件，它接收一个 prop 并渲染出来。\n在指南页面了解更多关于组件的内容！\n\n\n================================================\nFILE: src/examples/src/simple-component/App/composition.js\n================================================\nimport { ref } from 'vue'\nimport TodoItem from './TodoItem.vue'\n\nexport default {\n  components: {\n    TodoItem\n  },\n  setup() {\n    const groceryList = ref([\n      { id: 0, text: 'Vegetables' },\n      { id: 1, text: 'Cheese' },\n      { id: 2, text: 'Whatever else humans are supposed to eat' }\n    ])\n\n    return {\n      groceryList\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/simple-component/App/options.js\n================================================\nimport TodoItem from './TodoItem.vue'\n\nexport default {\n  components: {\n    TodoItem\n  },\n  data() {\n    return {\n      groceryList: [\n        { id: 0, text: 'Vegetables' },\n        { id: 1, text: 'Cheese' },\n        { id: 2, text: 'Whatever else humans are supposed to eat' }\n      ]\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/simple-component/App/template.html\n================================================\n<ol>\n  <!--\n    我们给每个 todo 项提供它所表示的 todo 对象，\n    以便能够动态展示内容。\n    同时还需要给每个组件提供一个“key”，\n    这在指南的 v-for 部分有详细解释。\n  -->\n  <TodoItem\n    v-for=\"item in groceryList\"\n    :todo=\"item\"\n    :key=\"item.id\"\n  ></TodoItem>\n</ol>\n\n\n================================================\nFILE: src/examples/src/simple-component/TodoItem/composition.js\n================================================\nexport default {\n  props: {\n    todo: Object\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/simple-component/TodoItem/options.js\n================================================\nexport default {\n  props: {\n    todo: Object\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/simple-component/TodoItem/template.html\n================================================\n<li>{{ todo.text }}</li>\n\n\n================================================\nFILE: src/examples/src/svg/description.txt\n================================================\n一个 SVG 图像\n\n\n\n================================================\nFILE: src/examples/src/svg/util.js\n================================================\nexport function valueToPoint(value, index, total) {\n  const x = 0\n  const y = -value * 0.8\n  const angle = ((Math.PI * 2) / total) * index\n  const cos = Math.cos(angle)\n  const sin = Math.sin(angle)\n  const tx = x * cos - y * sin + 100\n  const ty = x * sin + y * cos + 100\n  return {\n    x: tx,\n    y: ty\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/svg/App/composition.js\n================================================\nimport PolyGraph from './PolyGraph.vue'\nimport { ref, reactive } from 'vue'\n\nexport default {\n  components: {\n    PolyGraph\n  },\n  setup() {\n    const newLabel = ref('')\n    const stats = reactive([\n      { label: 'A', value: 100 },\n      { label: 'B', value: 100 },\n      { label: 'C', value: 100 },\n      { label: 'D', value: 100 },\n      { label: 'E', value: 100 },\n      { label: 'F', value: 100 }\n    ])\n\n    function add(e) {\n      e.preventDefault()\n      if (!newLabel.value) return\n      stats.push({\n        label: newLabel.value,\n        value: 100\n      })\n      newLabel.value = ''\n    }\n\n    function remove(stat) {\n      if (stats.length > 3) {\n        stats.splice(stats.indexOf(stat), 1)\n      } else {\n        alert(\"Can't delete more!\")\n      }\n    }\n\n    return {\n      newLabel,\n      stats,\n      add,\n      remove\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/svg/App/options.js\n================================================\nimport PolyGraph from './PolyGraph.vue'\n\nexport default {\n  components: {\n    PolyGraph\n  },\n  data: () => ({\n    newLabel: '',\n    stats: [\n      { label: 'A', value: 100 },\n      { label: 'B', value: 100 },\n      { label: 'C', value: 100 },\n      { label: 'D', value: 100 },\n      { label: 'E', value: 100 },\n      { label: 'F', value: 100 }\n    ]\n  }),\n  methods: {\n    add(e) {\n      e.preventDefault()\n      if (!this.newLabel) return\n      this.stats.push({\n        label: this.newLabel,\n        value: 100\n      })\n      this.newLabel = ''\n    },\n    remove(stat) {\n      if (this.stats.length > 3) {\n        this.stats.splice(this.stats.indexOf(stat), 1)\n      } else {\n        alert(\"Can't delete more!\")\n      }\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/svg/App/style.css\n================================================\npolygon {\n  fill: #42b983;\n  opacity: 0.75;\n}\n\ncircle {\n  fill: transparent;\n  stroke: #999;\n}\n\ntext {\n  font-size: 10px;\n  fill: #666;\n}\n\nlabel {\n  display: inline-block;\n  margin-left: 10px;\n  width: 20px;\n}\n\n#raw {\n  position: absolute;\n  top: 0;\n  left: 300px;\n}\n\n\n\n================================================\nFILE: src/examples/src/svg/App/template.html\n================================================\n<svg width=\"200\" height=\"200\">\n  <PolyGraph :stats=\"stats\"></PolyGraph>\n</svg>\n\n<!-- 控件 -->\n<div v-for=\"stat in stats\">\n  <label>{{stat.label}}</label>\n  <input type=\"range\" v-model=\"stat.value\" min=\"0\" max=\"100\">\n  <span>{{stat.value}}</span>\n  <button @click=\"remove(stat)\" class=\"remove\">X</button>\n</div>\n\n<form id=\"add\">\n  <input name=\"newlabel\" v-model=\"newLabel\">\n  <button @click=\"add\">Add a Stat</button>\n</form>\n\n<pre id=\"raw\">{{ stats }}</pre>\n\n\n\n================================================\nFILE: src/examples/src/svg/AxisLabel/composition.js\n================================================\nimport { computed } from 'vue'\nimport { valueToPoint } from './util.js'\n\nexport default {\n  props: {\n    stat: Object,\n    index: Number,\n    total: Number\n  },\n  setup(props) {\n    const point = computed(() =>\n      valueToPoint(+props.stat.value + 10, props.index, props.total)\n    )\n\n    return {\n      point\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/svg/AxisLabel/options.js\n================================================\nimport { valueToPoint } from './util.js'\n\nexport default {\n  props: {\n    stat: Object,\n    index: Number,\n    total: Number\n  },\n  computed: {\n    point: function () {\n      return valueToPoint(+this.stat.value + 10, this.index, this.total)\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/svg/AxisLabel/template.html\n================================================\n<text :x=\"point.x\" :y=\"point.y\">{{stat.label}}</text>\n\n\n\n================================================\nFILE: src/examples/src/svg/PolyGraph/composition.js\n================================================\nimport AxisLabel from './AxisLabel.vue'\nimport { computed } from 'vue'\nimport { valueToPoint } from './util.js'\n\nexport default {\n  components: {\n    AxisLabel\n  },\n  props: {\n    stats: Array\n  },\n  setup(props) {\n    const points = computed(() => {\n      const total = props.stats.length\n      return props.stats\n        .map((stat, i) => {\n          const { x, y } = valueToPoint(stat.value, i, total)\n          return `${x},${y}`\n        })\n        .join(' ')\n    })\n\n    return {\n      points\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/svg/PolyGraph/options.js\n================================================\nimport AxisLabel from './AxisLabel.vue'\nimport { valueToPoint } from './util.js'\n\nexport default {\n  components: {\n    AxisLabel\n  },\n  props: {\n    stats: Array\n  },\n  computed: {\n    // 一个用于多边形顶点的计算属性\n    points() {\n      const total = this.stats.length\n      return this.stats\n        .map((stat, i) => {\n          const { x, y } = valueToPoint(stat.value, i, total)\n          return `${x},${y}`\n        })\n        .join(' ')\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/svg/PolyGraph/template.html\n================================================\n<g>\n  <polygon :points=\"points\"></polygon>\n  <circle cx=\"100\" cy=\"100\" r=\"80\"></circle>\n  <axis-label\n    v-for=\"(stat, index) in stats\"\n    :stat=\"stat\"\n    :index=\"index\"\n    :total=\"stats.length\"\n  >\n  </axis-label>\n</g>\n\n\n\n================================================\nFILE: src/examples/src/temperature-converter/description.txt\n================================================\nhttps://eugenkiss.github.io/7guis/tasks/#temp\n\n\n================================================\nFILE: src/examples/src/temperature-converter/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const c = ref(0)\n    const f = ref(32)\n\n    function setC(e, v = +e.target.value) {\n      c.value = v\n      f.value = v * (9 / 5) + 32\n    }\n\n    function setF(e, v = +e.target.value) {\n      f.value = v\n      c.value = (v - 32) * (5 / 9)\n    }\n\n    return {\n      c,\n      f,\n      setC,\n      setF\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/temperature-converter/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      c: 0,\n      f: 32\n    }\n  },\n  methods: {\n    setC(e, c = +e.target.value) {\n      this.c = c\n      this.f = c * (9 / 5) + 32\n    },\n    setF(e, f = +e.target.value) {\n      this.f = f\n      this.c = (f - 32) * (5 / 9)\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/temperature-converter/App/template.html\n================================================\n<input type=\"number\" :value=\"c\" @change=\"setC\"> Celsius =\n<input type=\"number\" :value=\"f\" @change=\"setF\"> Fahrenheit\n\n\n\n================================================\nFILE: src/examples/src/timer/description.txt\n================================================\nhttps://eugenkiss.github.io/7guis/tasks/#timer\n\n\n================================================\nFILE: src/examples/src/timer/App/composition.js\n================================================\nimport { ref, onUnmounted, computed } from 'vue'\nexport default {\n  setup() {\n    const duration = ref(15 * 1000)\n    const elapsed = ref(0)\n\n    let lastTime\n    let handle\n\n    const update = () => {\n      elapsed.value = performance.now() - lastTime\n      if (elapsed.value >= duration.value) {\n        cancelAnimationFrame(handle)\n      } else {\n        handle = requestAnimationFrame(update)\n      }\n    }\n\n    const reset = () => {\n      elapsed.value = 0\n      lastTime = performance.now()\n      update()\n    }\n\n    const progressRate = computed(() =>\n      Math.min(elapsed.value / duration.value, 1)\n    )\n\n    reset()\n\n    onUnmounted(() => {\n      cancelAnimationFrame(handle)\n    })\n    return {\n      duration,\n      elapsed,\n      progressRate,\n      reset\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/timer/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      duration: 15 * 1000,\n      elapsed: 0\n    }\n  },\n  created() {\n    this.reset()\n  },\n  unmounted() {\n    cancelAnimationFrame(this.handle)\n  },\n  computed: {\n    progressRate() {\n      return Math.min(this.elapsed / this.duration, 1)\n    }\n  },\n  methods: {\n    update() {\n      this.elapsed = performance.now() - this.lastTime\n      if (this.elapsed >= this.duration) {\n        cancelAnimationFrame(this.handle)\n      } else {\n        this.handle = requestAnimationFrame(this.update)\n      }\n    },\n    reset() {\n      this.elapsed = 0\n      this.lastTime = performance.now()\n      this.update()\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/timer/App/style.css\n================================================\n.elapsed-container {\n  width: 300px;\n}\n\n.elapsed-bar {\n  background-color: red;\n  height: 10px;\n}\n\n\n================================================\nFILE: src/examples/src/timer/App/template.html\n================================================\n<label\n  >Elapsed Time: <progress :value=\"progressRate\"></progress\n></label>\n\n<div>{{ (elapsed / 1000).toFixed(1) }}s</div>\n\n<div>\n  Duration: <input type=\"range\" v-model=\"duration\" min=\"1\" max=\"30000\">\n  {{ (duration / 1000).toFixed(1) }}s\n</div>\n\n<button @click=\"reset\">Reset</button>\n\n\n================================================\nFILE: src/examples/src/tree/description.txt\n================================================\n一个可以递归渲染自己的嵌套树组件。\n你可以双击一个项目将其转变为一个文件夹。\n\n\n================================================\nFILE: src/examples/src/tree/App/composition.js\n================================================\nimport { ref } from 'vue'\nimport TreeItem from './TreeItem.vue'\n\nexport default {\n  components: {\n    TreeItem\n  },\n  setup() {\n    const treeData = ref({\n      name: 'My Tree',\n      children: [\n        { name: 'hello' },\n        { name: 'world' },\n        {\n          name: 'child folder',\n          children: [\n            {\n              name: 'child folder',\n              children: [{ name: 'hello' }, { name: 'world' }]\n            },\n            { name: 'hello' },\n            { name: 'world' },\n            {\n              name: 'child folder',\n              children: [{ name: 'hello' }, { name: 'world' }]\n            }\n          ]\n        }\n      ]\n    })\n\n    return {\n      treeData\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/tree/App/options.js\n================================================\nimport TreeItem from './TreeItem.vue'\n\nconst treeData = {\n  name: 'My Tree',\n  children: [\n    { name: 'hello' },\n    { name: 'wat' },\n    {\n      name: 'child folder',\n      children: [\n        {\n          name: 'child folder',\n          children: [{ name: 'hello' }, { name: 'wat' }]\n        },\n        { name: 'hello' },\n        { name: 'wat' },\n        {\n          name: 'child folder',\n          children: [{ name: 'hello' }, { name: 'wat' }]\n        }\n      ]\n    }\n  ]\n}\n\nexport default {\n  components: {\n    TreeItem\n  },\n  data() {\n    return {\n      treeData\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/tree/App/style.css\n================================================\n.item {\n  cursor: pointer;\n  line-height: 1.5;\n}\n.bold {\n  font-weight: bold;\n}\n\n\n================================================\nFILE: src/examples/src/tree/App/template.html\n================================================\n<ul>\n  <TreeItem class=\"item\" :model=\"treeData\"></TreeItem>\n</ul>\n\n\n\n================================================\nFILE: src/examples/src/tree/TreeItem/composition.js\n================================================\nimport { ref, computed } from 'vue'\n\nexport default {\n  name: 'TreeItem', // 在引用自身的时候是必须的\n  props: {\n    model: Object\n  },\n  setup(props) {\n    const isOpen = ref(false)\n    const isFolder = computed(() => {\n      return props.model.children && props.model.children.length\n    })\n\n    function toggle() {\n      isOpen.value = !isOpen.value\n    }\n\n    function changeType() {\n      if (!isFolder.value) {\n        props.model.children = []\n        addChild()\n        isOpen.value = true\n      }\n    }\n\n    function addChild() {\n      props.model.children.push({ name: 'new stuff' })\n    }\n\n    return {\n      isOpen,\n      isFolder,\n      toggle,\n      changeType,\n      addChild\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/tree/TreeItem/options.js\n================================================\nexport default {\n  name: 'TreeItem', // 在引用自身的时候是必须的\n  props: {\n    model: Object\n  },\n  data() {\n    return {\n      isOpen: false\n    }\n  },\n  computed: {\n    isFolder() {\n      return this.model.children && this.model.children.length\n    }\n  },\n  methods: {\n    toggle() {\n      if (this.isFolder) {\n        this.isOpen = !this.isOpen\n      }\n    },\n    changeType() {\n      if (!this.isFolder) {\n        this.model.children = []\n        this.addChild()\n        this.isOpen = true\n      }\n    },\n    addChild() {\n      this.model.children.push({\n        name: 'new stuff'\n      })\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/examples/src/tree/TreeItem/template.html\n================================================\n<li>\n  <div\n    :class=\"{ bold: isFolder }\"\n    @click=\"toggle\"\n    @dblclick=\"changeType\">\n    {{ model.name }}\n    <span v-if=\"isFolder\">[{{ isOpen ? '-' : '+' }}]</span>\n  </div>\n  <ul v-show=\"isOpen\" v-if=\"isFolder\">\n    <!--\n      一个可以通过其“name”选项递归渲染自己的组件，\n      (如果使用单文件组件，则从文件名推断)\n    -->\n    <TreeItem\n      class=\"item\"\n      v-for=\"model in model.children\"\n      :model=\"model\">\n    </TreeItem>\n    <li class=\"add\" @click=\"addChild\">+</li>\n  </ul>\n</li>\n\n\n================================================\nFILE: src/glossary/index.md\n================================================\n# 术语表 {#glossary}\n\n本术语表旨在为一些在讨论 Vue 时常用的技术术语的含义提供指导。其目的在于*描述*术语的常见用法，而不是*规定*它们必须如何使用。在不同的上下文中，一些术语的含义可能会有细微的差别。\n\n[[TOC]]\n\n## 异步组件 (async component) {#async-component}\n\n*异步组件*是为另一个组件提供的包装器，来让被包装的组件可以进行懒加载。这通常用作减少构建后的 `.js` 文件大小的一种方式，通过将它们拆分为较小的块来按需加载。\n\nVue Router 也有类似的功能，用于[路由懒加载](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html)，但这并不是通过 Vue 的异步组件功能实现的。\n\n详见：\n- [指南 - 异步组件](/guide/components/async.html)\n\n## 编译器宏 (compiler macro) {#compiler-macro}\n\n*编译器宏*是一种特殊的代码，由编译器处理并转换为其他东西。它们实际上是一种更巧妙的字符串替换形式。\n\nVue 的[单文件组件](#single-file-component)编译器支持各种宏，例如 `defineProps()`、`defineEmits()` 和 `defineExpose()`。这些宏有意设计得像是普通的 JavaScript 函数，以便它们可以利用 JavaScript / TypeScript 中的相同解析器和类型推断工具。然而，它们不是在浏览器中运行的实际函数。这些特殊字符串会被编译器检测到并替换为实际真正运行的 JavaScript 代码。\n\n宏在使用上有一些不适用于普通 JavaScript 代码的限制。例如，你可能认为 `const dp = defineProps` 会为 `defineProps` 创建一个别名，但实际上它会导致错误。相同的限制也存在于传入 `defineProps()` 的值，因为“参数”必须由编译器处理，而不是在运行时。\n\n详见：\n- [`<script setup>` - `defineProps()` & `defineEmits()`](/api/sfc-script-setup.html#defineprops-defineemits)\n- [`<script setup>` - `defineExpose()`](/api/sfc-script-setup.html#defineexpose)\n\n## 组件 (component) {#component}\n\n*组件*一词不是 Vue 独有的。它是许多 UI 框架都有的共同特性。它描述了 UI 的一部分，例如按钮或复选框。多个组件也可以组合成更大的组件。\n\n组件是 Vue 提供的将 UI 拆成较小部分的主要机制，既可以提高可维护性，也允许代码重用。\n\n一个 Vue 组件是一个对象。所有属性都是可选的，但是必须有用于组件渲染的模板或渲染函数二选一。例如，以下对象将是一个有效的组件：\n\n```js\nconst HelloWorldComponent = {\n  render() {\n    return 'Hello world!'\n  }\n}\n```\n\n在实践中，大多数 Vue 应用都是通过[单文件组件](#single-file-component) (`.vue` 文件) 编写的。虽然这些组件乍一看不是对象，但单文件组件编译器会将它们转换为用作文件默认导出的一个对象。从外部来看，`.vue` 文件只是导出一个组件对象的 ES 模块。\n\n组件对象的属性通常称为*选项*。这就是[选项式 API](#options-api) 得名的原因。\n\n组件的选项将定义如何创建该组件的实例。组件在概念上类似于类，尽管 Vue 并不使用实际的 JavaScript 类来定义它们。\n\n组件这个词也可以更宽泛地用来指代组件实例。\n\n详见：\n- [指南 - 组件基础](/guide/essentials/component-basics.html)\n\n“组件”一词还出现在其他几个术语中：\n- [异步组件](#async-component)\n- [动态组件](#dynamic-component)\n- [函数式组件](#functional-component)\n- [Web Component](#web-component)\n\n## 组合式函数 (composable) {#composable}\n\n*组合式函数*一词描述了 Vue 中的一种常见用法。它不是 Vue 的一个单独的特性，而是一种使用框架的[组合式 API](#composition-api) 的方式。\n\n* 组合式函数是一个函数。\n* 组合式函数用于封装和重用有状态的逻辑。\n* 函数名通常以 `use` 开头，以便让其他开发者知道它是一个组合式函数。\n* 函数通常在组件的 `setup()` 函数 (或等效的 `<script setup>` 块) 的同步执行期间调用。这将组合式函数的调用与当前组件的上下文绑定，例如通过调用 `provide()`、`inject()` 或 `onMounted()`。\n* 通常来说，组合式函数返回的是一个普通对象，而不是一个响应式对象。这个对象通常包含 `ref` 和函数，并且预期在调用它的代码中进行解构。\n\n与许多模式一样，对于特定代码是否符合上述定义可能会有一些争议。并非所有的 JavaScript 工具函数都是组合式函数。如果一个函数没有使用组合式 API，那么它可能不是一个组合式函数。如果它不期望在 `setup()` 的同步执行期间被调用，那么它可能不是一个组合式函数。组合式函数专门用于封装有状态的逻辑，它们不仅仅是函数的命名约定。\n\n参考[指南 - 组合式函数](/guide/reusability/composables.html)获取更多关于如何编写组合式函数的细节。\n\n## 组合式 API (Composition API) {#composition-api}\n\n*组合式 API* 是 Vue 中的一组用于编写组件和组合式函数的函数。\n\n该词也用于描述用于编写组件的两种主要风格之一，另一种是[选项式 API](#options-api)。通过组合式 API 编写的组件使用 `<script setup>` 或显式的 `setup()` 函数。\n\n参考[组合式 API 常见问答](/guide/extras/composition-api-faq)获取更多细节。\n\n## 自定义元素 (custom element) {#custom-element}\n\n*自定义元素*是现代 Web 浏览器中实现的 [Web Components](#web-component) 标准的一个特性。它指的是在 HTML 标记中使用自定义 HTML 元素，以在页面的该位置加入一个 Web Component 的能力。\n\nVue 对渲染自定义元素有内置的支持，并允许它们直接在 Vue 组件模板中使用。\n\n自定义元素不应该与在 Vue 组件的模板中包含另一个 Vue 组件的能力混淆。自定义元素是用于创建 Web Components 的，而不是 Vue 组件。\n\n详见：\n- [Vue 与 Web Components](/guide/extras/web-components.html)\n\n## 指令 (directive) {#directive}\n\n*指令*一词指的是以 `v-` 前缀开头的模板属性，或者它们的等效简写。\n\n内置的指令包括 `v-if`、`v-for`、`v-bind`、`v-on` 和 `v-slot`。\n\nVue 也支持创建自定义指令，尽管它们通常只用作操作 DOM 节点的“逃生舱”。自定义指令通常不能用来重新创建内置指令的功能。\n\n详见：\n- [指南 - 模板语法 - 指令](/guide/essentials/template-syntax.html#directives)\n- [指南 - 自定义指令](/guide/reusability/custom-directives.html)\n\n## 动态组件 (dynamic component) {#dynamic-component}\n\n*动态组件*一词用于描述需要动态选择要渲染的子组件的情况。这通常是通过 `<component :is=\"type\">` 来实现的。\n\n动态组件不是一种特殊类型的组件。任何组件都可以用作动态组件。动态指的是组件的选择，而不是组件本身。\n\n详见：\n- [指南 - 组件基础 - 动态组件](/guide/essentials/component-basics.html#dynamic-components)\n\n## 作用 (effect) {#effect}\n\n见[响应式作用](#reactive-effect)和[副作用](#side-effect)。\n\n## 事件 (event) {#event}\n\n通过事件在程序的不同部分之间进行通信在许多不同领域编程实践中都是很常见的。在 Vue 中，这个术语通常被用于原生 HTML 元素事件和 Vue 组件事件。`v-on` 指令用于在模板中监听这两种类型的事件。\n\n详见：\n- [指南 - 事件处理](/guide/essentials/event-handling.html)\n- [指南 - 组件事件](/guide/components/events.html)\n\n## 片段 (fragment) {#fragment}\n\n*片段*一词指的是一种特殊类型的 [VNode](#vnode)，它用作其他 VNode 的父节点，但它本身不渲染任何元素。\n\n该名称来自于一个类似概念：原生 DOM API 中的 [`DocumentFragment`](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment)。\n\n片段用于支持具有多个根节点的组件。虽然这样的组件表面上有多个根节点，但背后还是有一个单一的片段根节点作为这些表面上“根”节点的父节点。\n\n片段也作为包装多个动态节点的一种方式被用于模板编译器，例如通过 `v-for` 或 `v-if` 创建的节点。这允许我们向 [VDOM](#virtual-dom) 补丁算法传递额外的提示。这些大部分都是在内部处理的，但你可能会直接遇到的一种情况是在 `<template>` 标签上使用 `v-for` 的 `key`。在此，`key` 会作为 [prop](#prop) 添加到片段的 VNode。\n\n片段节点当前在 DOM 上被渲染为了空文本节点，但这只是一个实现细节。当你使用 `$el` 或尝试通过浏览器内置的 API 遍历 DOM 时，可能会意外地遇到这些文本节点。\n\n## 函数式组件 (functional component) {#functional-component}\n\n组件的定义通常是一个包含选项的对象。如果使用 `<script setup>` 的话它可能看起来不是这样，但是从 `.vue` 文件导出的组件仍然是一个对象。\n\n*函数式组件*是组件的一种替代形式，它使用函数来声明。该函数充当组件的[渲染函数](#render-function)。\n\n函数式组件无法拥有任何自己的状态。它也不会经历通常的组件生命周期，因此无法使用生命周期钩子。这使得它们比正常的有状态组件要稍微轻一些。\n\n详见：\n- [指南 - 渲染函数 & JSX - 函数式组件](/guide/extras/render-function.html#functional-components)\n\n## 变量提升 (hoisting) {#hoisting}\n\n*变量提升*一词用于描述在一段代码到达之前就运行。执行被“提升”到一个较早的点。\n\nJavaScript 对某些结构使用了变量提升，例如 `var`、`import` 和函数声明。\n\n在 Vue 上下文中，模板编译器应用了*变量提升*来提高性能。在将模板转换为渲染函数时，一些静态内容会被提升到组件作用域之外。这些静态内容被描述为“被提升的”，因为它们是在组件创建之前，在其外面创建的。\n\n## 缓存静态内容 (cache-static) {#cache-static}\n\n*缓存*用于描述对经常访问的数据进行临时存储，以提高性能。\n\nVue 的模板编译器会识别静态 VNodes，在首次渲染时会将其缓存起来，并在后续的重新渲染中使用缓存的 VNodes。\n\n详见：\n- [指南 - 渲染机制 - 缓存静态内容](/guide/extras/rendering-mechanism.html#cache-static)\n\n## DOM 内模板 (in-DOM template) {#in-dom-template}\n\n指定组件模板的方式有很多。在大多数情况下，模板是以字符串的形式提供的。\n\n*DOM 内模板*一词指的是以 DOM 节点而非字符串形式提供模板的场景。然后 Vue 将通过 `innerHTML` 将 DOM 节点转换为模板字符串。\n\n通常来说，内联 DOM 模板是直接在页面的 HTML 中编写的 HTML 标记。然后浏览器将其解析为 DOM 节点，Vue 再使用这些节点来读取 `innerHTML`。\n\n详见：\n- [指南 - 创建一个应用 - DOM 中的根组件模板](/guide/essentials/application.html#in-dom-root-component-template)\n- [指南 - 组件基础 - DOM 内模板解析注意事项](/guide/essentials/component-basics.html#in-dom-template-parsing-caveats)\n- [渲染选项 - template](/api/options-rendering.html#template)\n\n## 注入 (inject) {#inject}\n\n见[提供 / 注入](#provide-inject)。\n\n## 生命周期钩子 (lifecycle hooks) {#lifecycle-hooks}\n\nVue 组件实例会经历一个生命周期。例如，它会被创建、挂载、更新和卸载。\n\n*生命周期钩子*是监听这些生命周期事件的一种方式。\n\n在选项式 API 中，每个钩子都作为单独的选项提供，例如 `mounted`。而组合式 API 则使用函数，例如 `onMounted()`。\n\n详见：\n- [指南 - 生命周期钩子](/guide/essentials/lifecycle.html)\n\n## 宏 (macro) {#macro}\n\n见[编译器宏](#compiler-macro)。\n\n## 具名插槽 (named slot) {#named-slot}\n\n组件可以有通过名称进行区分的多个插槽。除了默认插槽之外的插槽被称为*具名插槽*。\n\n详见：\n- [指南 - 插槽 - 具名插槽](/guide/components/slots.html#named-slots)\n\n## 选项式 API (Options API) {#options-api}\n\nVue 组件是通过对象定义的。这些组件对象的属性被称为*选项*。\n\n组件可以用两种风格编写。一种风格将[组合式 API](#composition-api) 与 `setup` (通过 `setup()` 选项或 `<script setup>`) 结合使用。另一种风格几乎不直接使用组合式 API，而是使用各种组件选项来达到类似的效果。以这种方式使用的组件选项被称为*选项式 API*。\n\n选项式 API 包括 `data()`、`computed`、`methods` 和 `created()` 等选项。\n\n某些选项，例如 `props`、`emits` 和 `inheritAttrs`，可以用于任意一套 API 编写组件。由于它们是组件选项，因此可以被认为是选项式 API 的一部分。但是，由于这些选项也与 `setup()` 结合使用，因此通常更适合将它们视为两套组件风格之间共享的选项。\n\n`setup()` 函数本身是一个组件选项，因此它*可以*被描述为选项式 API 的一部分。但是，这不是“选项式 API”这个术语的常见用法。相反，`setup()` 函数被认为是组合式 API 的一部分。\n\n## 插件 (plugin) {#plugin}\n\n*插件*一词可以在各种上下文中使用，但是在 Vue 中它有一个特定的概念，即插件是向应用程序添加功能的一种方式。\n\n调用 `app.use(plugin)` 可以将插件添加到应用中。插件本身可以是一个函数，也可以是一个带有 `install` 函数的对象。该函数会被传入应用实例，然后执行任何所需的操作。\n\n详见：\n- [指南 - 插件](/guide/reusability/plugins.html)\n\n## Prop {#prop}\n\n*Prop* 一词在 Vue 中有三种常见用法：\n\n* 组件 prop\n* VNode prop\n* 插槽 prop\n\n大多数情况下，prop 是指*组件 prop*。这些 prop 由组件通过 `defineProps()` 或 `props` 选项显式定义。\n\n*VNode prop* 一词指的是作为第二个参数传入 `h()` 的对象的属性。这些属性可以包括组件 prop，也可以包括组件事件、DOM 事件、DOM attribute 和 DOM property。通常只有在使用渲染函数直接操作 VNode 时才会用到 VNode prop。\n\n*插槽 prop* 是传递给作用域插槽的属性。\n\n在所有情况下，prop 都是从其他地方传递过来的属性。\n\n虽然 prop 源自单词 *properties*，但在 Vue 的上下文中，术语 prop 具有更加特定的含义。你应该避免将其用作 properties 的缩写。\n\n详见：\n- [指南 - Props](/guide/components/props.html)\n- [指南 - 渲染函数 & JSX](/guide/extras/render-function.html)\n- [指南 - 插槽 - 作用域插槽](/guide/components/slots.html#scoped-slots)\n\n## 提供 / 注入 (provide / inject) {#provide-inject}\n\n`provide` 和 `inject` 是一种组件间通信的形式。\n\n当组件*提供*一个值时，该组件的所有后代组件都可以选择使用 `inject` 来获取该值。与 prop 不同，提供值的组件不知道哪些组件正在接收该值。\n\n`provide` 和 `inject` 有时用于避免 *prop 逐级透传*。它们也可以作为组件与其插槽内容进行隐式通信的一种方式。\n\n`provide` 也可以在应用级别使用，使得该值对该应用中的所有组件都可用。\n\n详见：\n- [指南 - 依赖注入](/guide/components/provide-inject.html)\n\n## 响应式作用 (reactive effect) {#reactive-effect}\n\n*响应式作用*是 Vue 响应性系统的一部分。它指的是跟踪函数的依赖关系，并在它们的值发生变化时重新运行该函数的过程。\n\n`watchEffect()` 是最直接的创建作用的方式。Vue 内部的其他各个部分也会使用作用。例如：组件渲染更新、`computed()` 和 `watch()`。\n\nVue 只能在响应式作用内部跟踪响应式依赖关系。如果在响应式作用之外读取属性的值，它将“丢失”响应性，因为 Vue 不知道在该属性发生变化后应该做什么。\n\n这个术语源自“副作用”。调用作用函数是属性值被更改的副作用。\n\n详见：\n- [指南 - 深入响应式系统](/guide/extras/reactivity-in-depth.html)\n\n## 响应性 (reactivity) {#reactivity}\n\n通常来说，*响应性*是指在数据变化时自动执行操作的能力。例如，当数据值变化时更新 DOM，或进行网络请求。\n\n在 Vue 上下文中，响应性用于描述一组功能。这些功能组合在一起形成一个*响应性系统*，并通过[响应性 API](#reactivity-api) 暴露出来。\n\n实现一个响应性系统的方式有很多种。例如，可以通过代码的静态分析来确定其依赖关系。但是，Vue 没有采用这种形式的响应性系统。\n\n取而代之的是，Vue 的响应性系统在运行时跟踪属性的访问。它通过结合 Proxy 包装器和 [getter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description)/[setter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set#description) 函数来实现。\n\n详见：\n- [指南 - 响应式基础](/guide/essentials/reactivity-fundamentals.html)\n- [指南 - 深入响应式系统](/guide/extras/reactivity-in-depth.html)\n\n## 响应性 API (Reactivity API) {#reactivity-api}\n\n*响应性 API* 是一组与[响应性](#reactivity)相关的核心 Vue 函数。这些函数可以独立于组件使用。包括 `ref()`、`reactive()`、`computed()`、`watch()` 和 `watchEffect()` 等。\n\n响应性 API 是组合式 API 的一个子集。\n\n详见：\n- [响应性 API：核心](/api/reactivity-core.html)\n- [响应性 API：工具](/api/reactivity-utilities.html)\n- [响应性 API：进阶](/api/reactivity-advanced.html)\n\n## ref {#ref}\n\n> 该条目是关于 `ref` 在响应性中的用法。对于模板中使用的 `ref` attribute，请参考[模板 ref](#template-ref)。\n\n`ref` 是 Vue 响应性系统的一部分。它是一个具有单个响应式属性 (称为 `value`) 的对象。\n\nRef 有多种不同的类型。例如，可以使用 `ref()`、`shallowRef()`、`computed()` 和 `customRef()` 来创建 ref。函数 `isRef()` 可以用来检查一个对象是否是 ref，`isReadonly()` 可以用来检查 ref 是否允许被直接重新赋值。\n\n详见：\n- [指南 - 响应式基础](/guide/essentials/reactivity-fundamentals.html)\n- [响应性 API：核心](/api/reactivity-core.html)\n- [响应性 API：工具](/api/reactivity-utilities.html)\n- [响应性 API：进阶](/api/reactivity-advanced.html)\n\n## 渲染函数 (render function) {#render-function}\n\n*渲染函数*是组件的一部分，它在渲染期间生成 VNode。模板会被编译成渲染函数。\n\n详见：\n- [指南 - 渲染函数 & JSX](/guide/extras/render-function.html)\n\n## 调度器 (scheduler) {#scheduler}\n\n*调度器*是 Vue 内部的一部分，它控制着[响应式作用](#reactive-effect)运行的时机。\n\n当响应式状态发生变化时，Vue 不会立即触发渲染更新。取而代之的是，它会通过队列实现批处理。这确保了即使对底层数据进行了多次更改，组件也只重新渲染一次。\n\n[侦听器](/guide/essentials/watchers.html)也使用了调度器队列进行批处理。具有 `flush: 'pre'` (默认值) 的侦听器将在组件渲染之前运行，而具有 `flush: 'post'` 的侦听器将在组件渲染之后运行。\n\n调度器中的任务还用于执行各种其他内部任务，例如触发一些[生命周期钩子](#lifecycle-hooks)和更新[模板 ref](#template-ref)。\n\n## 作用域插槽 (scoped slot) {#scoped-slot}\n\n*作用域插槽*是指接收 [prop](#prop) 的[插槽](#slot)。\n\n过去，Vue 在作用域插槽和非作用域插槽之间有很大的区别。在某种程度上，它们可以被视为被统一在一个公共的模板语法背后的两个不同的功能。\n\n在 Vue 3 中，插槽 API 被简化为使所有插槽都像作用域插槽一样。然而，作用域插槽和非作用域插槽的使用场景通常不一样，因此该术语仍被用于特指具有 prop 的插槽。\n\n传递给插槽的 prop 只能在父模板中负责定义该插槽内容的指定区域中使用。该模板区域的行为类似于 prop 的变量作用域，因此称为“作用域插槽”。\n\n详见：\n- [指南 - 插槽 - 作用域插槽](/guide/components/slots.html#scoped-slots)\n\n## SFC {#sfc}\n\n见[单文件组件](#single-file-component)。\n\n## 副作用 (side effect) {#side-effect}\n\n*副作用*一词并非 Vue 特有。它用于描述超出其局部作用域的操作或函数。\n\n举个例子，在 `user.name = null` 这样设置属性的上下文中，我们可以预期 `user.name` 的值会被更改。如果它还做了其他事情，比如触发 Vue 的响应性系统，那么这就被描述为副作用。这就是 Vue 中的[响应式 effect](#reactive-effect) 一词的起源。\n\n当描述一个函数具有副作用时，这意味着该函数除了返回一个值之外，还执行了某种在函数外可观察到的操作。这可能意味着它更新了状态中的值，或者触发了网络请求。\n\n该术语通常用于描述渲染或计算属性。最佳实践是渲染不应该有副作用。同样，计算属性的 getter 函数也不应该有副作用。\n\n## 单文件组件 (Single-File Component) {#single-file-component}\n\n*单文件组件* (SFC) 一词指的是常用于 Vue 组件的 `.vue` 文件格式。\n\n参考：\n- [指南 - 单文件组件](/guide/scaling-up/sfc.html)\n- [单文件组件语法定义](/api/sfc-spec.html)\n\n## 插槽 (slot) {#slot}\n\n插槽用于向子组件传递内容。和 prop 用于传递数据不同，插槽用于传递更丰富的内容，包括 HTML 元素和其他 Vue 组件。\n\n详见：\n- [指南 - 插槽](/guide/components/slots.html)\n\n## 模板 ref (template ref) {#template-ref}\n\n*模板 ref* 一词指的是在模板中的标签上使用 `ref` 属性。组件渲染后，该属性用于将相应的属性填充为模板中的标签对应的 HTML 元素或组件实例。\n\n如果你使用的是选项式 API，那么 ref 会通过 `$refs` 对象的属性暴露出来。\n\n通过组合式 API，模板 ref 会填充一个与之同名的[响应式 ref](#ref)。\n\n模板 ref 不应该与 Vue 响应性系统中的响应式 ref 混淆。\n\n详见：\n- [指南 - Template Refs](/guide/essentials/template-refs.html)\n\n## VDOM {#vdom}\n\n参考[虚拟 DOM](#virtual-dom)。\n\n## 虚拟 DOM (virtual DOM) {#virtual-dom}\n\n*虚拟 DOM* (VDOM) 一词并非 Vue 独有。它是多个 web 框架用于管理 UI 更新的常用方法。\n\n浏览器使用节点树来表示页面的当前状态。该树及用于与之交互的 JavaScript API 称为*文档对象模型*或 *DOM*。\n\n更新 DOM 是一个主要的性能瓶颈。虚拟 DOM 提供了一种管理 DOM 的策略。\n\n与直接创建 DOM 节点不同，Vue 组件会生成它们想要的 DOM 节点的描述。这些描述符是普通的 JavaScript 对象，称为 VNode (虚拟 DOM 节点)。创建 VNode 的成本相对较低。\n\n每次组件重新渲染时，都会将新的 VNode 树与先前的 VNode 树进行比较，然后将它们之间的差异应用于真实 DOM。如果没有任何更改，则不需要修改 DOM。\n\nVue 使用了一种混合方法，我们称之为[带编译时信息的虚拟 DOM](/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom)。Vue 的模板编译器能够根据对模板的静态分析添加性能优化。Vue 不会在运行时对组件的新旧 VNode 树进行完整的对比，而是可以利用编译器提取的信息，将树的对比减少到实际可能发生变化的部分。\n\n详见：\n- [指南 - 渲染机制](/guide/extras/rendering-mechanism.html)\n- [指南 - 渲染函数 & JSX](/guide/extras/render-function.html)\n\n## VNode {#vnode}\n\n*VNode* 即*虚拟 DOM 节点*。它们可以使用 [`h()`](/api/render-function.html#h) 函数创建。\n\n详见[虚拟 DOM](#virtual-dom)。\n\n## Web Component {#web-component}\n\n*Web Component* 标准是现代 Web 浏览器中实现的一组功能。\n\nVue 组件不是 Web 组件，但是可以通过 `defineCustomElement()` 从 Vue 组件创建[自定义元素](#custom-element)。Vue 还支持在 Vue 组件内部使用自定义元素。\n\n详见：\n- [指南 - Vue 和 Web Components](/guide/extras/web-components.html)\n\n\n\n================================================\nFILE: src/guide/introduction.md\n================================================\n---\nfooter: false\n---\n\n# 简介 {#introduction}\n\n:::info 你正在阅读的是 Vue 3 的文档！\n\n- Vue 2 已于 **2023 年 12 月 31 日**停止维护。详见 [Vue 2 终止支持 (EOL)](https://v2.cn.vuejs.org/eol/)。\n- 想从 Vue 2 升级？请参考[迁移指南](https://v3-migration.vuejs.org/)。\n:::\n\n<style src=\"@theme/styles/vue-mastery.css\"></style>\n<div class=\"vue-mastery-link\">\n  <a href=\"https://www.vuemastery.com/courses/\" target=\"_blank\">\n    <div class=\"banner-wrapper\">\n      <img class=\"banner\" alt=\"Vue Mastery banner\" width=\"96px\" height=\"56px\" src=\"https://storage.googleapis.com/vue-mastery.appspot.com/flamelink/media/vuemastery-graphical-link-96x56.png\" />\n    </div>\n    <p class=\"description\">在 <span>VueMastery</span> 上观看视频课程学习 Vue</p>\n    <div class=\"logo-wrapper\">\n        <img alt=\"Vue Mastery Logo\" width=\"25px\" src=\"https://storage.googleapis.com/vue-mastery.appspot.com/flamelink/media/vue-mastery-logo.png\" />\n    </div>\n  </a>\n</div>\n\n## 什么是 Vue？ {#what-is-vue}\n\nVue (发音为 /vjuː/，类似 **view**) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。\n\n下面是一个最基本的示例：\n\n<div class=\"options-api\">\n\n```js\nimport { createApp } from 'vue'\n\ncreateApp({\n  data() {\n    return {\n      count: 0\n    }\n  }\n}).mount('#app')\n```\n\n</div>\n<div class=\"composition-api\">\n\n```js\nimport { createApp, ref } from 'vue'\n\ncreateApp({\n  setup() {\n    return {\n      count: ref(0)\n    }\n  }\n}).mount('#app')\n```\n\n</div>\n\n```vue-html\n<div id=\"app\">\n  <button @click=\"count++\">\n    Count is: {{ count }}\n  </button>\n</div>\n```\n\n**结果展示**\n\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\n</script>\n\n<div class=\"demo\">\n  <button @click=\"count++\">\n    Count is: {{ count }}\n  </button>\n</div>\n\n上面的示例展示了 Vue 的两个核心功能：\n\n- **声明式渲染**：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。\n\n- **响应性**：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。\n\n你可能已经有了些疑问——先别急，在后续的文档中我们会详细介绍每一个细节。现在，请继续看下去，以确保你对 Vue 作为一个框架到底提供了什么有一个宏观的了解。\n\n:::tip 预备知识\n文档接下来的内容会假设你对 HTML、CSS 和 JavaScript 已经基本熟悉。如果你对前端开发完全陌生，最好不要直接从一个框架开始进行入门学习——最好是掌握了基础知识再回到这里。如有需要，你可以通过这些 [JavaScript](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript)、[HTML](https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML) 和 [CSS](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps) 概述来检验你的知识水平。如果之前有其他框架的经验会很有帮助，但也不是必须的。\n:::\n\n## 渐进式框架 {#the-progressive-framework}\n\nVue 是一个框架，也是一个生态。其功能覆盖了大部分前端开发常见的需求。但 Web 世界是十分多样化的，不同的开发者在 Web 上构建的东西可能在形式和规模上会有很大的不同。考虑到这一点，Vue 的设计非常注重灵活性和“可以被逐步集成”这个特点。根据你的需求场景，你可以用不同的方式使用 Vue：\n\n- 无需构建步骤，渐进式增强静态的 HTML\n- 在任何页面中作为 Web Components 嵌入\n- 单页应用 (SPA)\n- 全栈 / 服务端渲染 (SSR)\n- Jamstack / 静态站点生成 (SSG)\n- 开发桌面端、移动端、WebGL，甚至是命令行终端中的界面\n\n如果你是初学者，可能会觉得这些概念有些复杂。别担心！理解教程和指南的内容只需要具备基础的 HTML 和 JavaScript 知识。即使你不是这些方面的专家，也能够跟得上。\n\n如果你是有经验的开发者，希望了解如何以最合适的方式在项目中引入 Vue，或者是对上述的这些概念感到好奇，我们在[使用 Vue 的多种方式](/guide/extras/ways-of-using-vue)中讨论了有关它们的更多细节。\n\n无论再怎么灵活，Vue 的核心知识在所有这些用例中都是通用的。即使你现在只是一个初学者，随着你的不断成长，到未来有能力实现更复杂的项目时，这一路上获得的知识依然会适用。如果你已经是一个老手，你可以根据实际场景来选择使用 Vue 的最佳方式，在各种场景下都可以保持同样的开发效率。这就是为什么我们将 Vue 称为“渐进式框架”：它是一个可以与你共同成长、适应你不同需求的框架。\n\n## 单文件组件 {#single-file-components}\n\n在大多数启用了构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为**单文件组件** (也被称为 `*.vue` 文件，英文 Single-File Components，缩写为 **SFC**)。顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。下面我们将用单文件组件的格式重写上面的计数器示例：\n\n<div class=\"options-api\">\n\n```vue\n<script>\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\">Count is: {{ count }}</button>\n</template>\n\n<style scoped>\nbutton {\n  font-weight: bold;\n}\n</style>\n```\n\n</div>\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">Count is: {{ count }}</button>\n</template>\n\n<style scoped>\nbutton {\n  font-weight: bold;\n}\n</style>\n```\n\n</div>\n\n单文件组件是 Vue 的标志性功能。如果你的用例需要进行构建，我们推荐用它来编写 Vue 组件。你可以在后续相关章节里了解更多关于[单文件组件的用法及用途](/guide/scaling-up/sfc)。但你暂时只需要知道 Vue 会帮忙处理所有这些构建工具的配置就好。\n\n## API 风格 {#api-styles}\n\nVue 的组件可以按两种不同的风格书写：**选项式 API** 和**组合式 API**。\n\n### 选项式 API (Options API) {#options-api}\n\n使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 `data`、`methods` 和 `mounted`。选项所定义的属性都会暴露在函数内部的 `this` 上，它会指向当前的组件实例。\n\n```vue\n<script>\nexport default {\n  // data() 返回的属性将会成为响应式的状态\n  // 并且暴露在 `this` 上\n  data() {\n    return {\n      count: 0\n    }\n  },\n\n  // methods 是一些用来更改状态与触发更新的函数\n  // 它们可以在模板中作为事件处理器绑定\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n\n  // 生命周期钩子会在组件生命周期的各个不同阶段被调用\n  // 例如这个函数就会在组件挂载完成后被调用\n  mounted() {\n    console.log(`The initial count is ${this.count}.`)\n  }\n}\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNptkMFqxCAQhl9lkB522ZL0HNKlpa/Qo4e1ZpLIGhUdl5bgu9es2eSyIMio833zO7NP56pbRNawNkivHJ25wV9nPUGHvYiaYOYGoK7Bo5CkbgiBBOFy2AkSh2N5APmeojePCkDaaKiBt1KnZUuv3Ky0PppMsyYAjYJgigu0oEGYDsirYUAP0WULhqVrQhptF5qHQhnpcUJD+wyQaSpUd/Xp9NysVY/yT2qE0dprIS/vsds5Mg9mNVbaDofL94jZpUgJXUKBCvAy76ZUXY53CTd5tfX2k7kgnJzOCXIF0P5EImvgQ2olr++cbRE4O3+t6JxvXj0ptXVpye1tvbFY+ge/NJZt)\n\n### 组合式 API (Composition API) {#composition-api}\n\n\n通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与 [`<script setup>`](/api/sfc-script-setup) 搭配使用。这个 `setup` attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，`<script setup>` 中的导入和顶层变量/函数都能够在模板中直接使用。\n\n下面是使用了组合式 API 与 `<script setup>` 改造后和上面的模板完全一样的组件：\n\n```vue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// 响应式状态\nconst count = ref(0)\n\n// 用来修改状态、触发更新的函数\nfunction increment() {\n  count.value++\n}\n\n// 生命周期钩子\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpNkMFqwzAQRH9lMYU4pNg9Bye09NxbjzrEVda2iLwS0spQjP69a+yYHnRYad7MaOfiw/tqSliciybqYDxDRE7+qsiM3gWGGQJ2r+DoyyVivEOGLrgRDkIdFCmqa1G0ms2EELllVKQdRQa9AHBZ+PLtuEm7RCKVd+ChZRjTQqwctHQHDqbvMUDyd7mKip4AGNIBRyQujzArgtW/mlqb8HRSlLcEazrUv9oiDM49xGGvXgp5uT5his5iZV1f3r4HFHvDprVbaxPhZf4XkKub/CDLaep1T7IhGRhHb6WoTADNT2KWpu/aGv24qGKvrIrr5+Z7hnneQnJu6hURvKl3ryL/ARrVkuI=)\n\n### 该选哪一个？{#which-to-choose}\n\n两种 API 风格都能够覆盖大部分的应用场景。它们只是同一个底层系统所提供的两套不同的接口。实际上，选项式 API 是在组合式 API 的基础上实现的！关于 Vue 的基础概念和知识在它们之间都是通用的。\n\n选项式 API 以“组件实例”的概念为中心 (即上述例子中的 `this`)，对于有面向对象语言背景的用户来说，这通常与基于类的心智模型更为一致。同时，它将响应性相关的细节抽象出来，并强制按照选项来组织代码，从而对初学者而言更为友好。\n\n组合式 API 的核心思想是直接在函数作用域内定义响应式状态变量，并将从多个函数中得到的状态组合起来处理复杂问题。这种形式更加自由，也需要你对 Vue 的响应式系统有更深的理解才能高效使用。相应的，它的灵活性也使得组织和重用逻辑的模式变得更加强大。\n\n在[组合式 API FAQ](/guide/extras/composition-api-faq) 章节中，你可以了解更多关于这两种 API 风格的对比以及组合式 API 所带来的潜在收益。\n\n如果你是使用 Vue 的新手，这里是我们的大致建议：\n\n- 在学习的过程中，推荐采用更易于自己理解的风格。再强调一下，大部分的核心概念在这两种风格之间都是通用的。熟悉了一种风格以后，你也能够很快地理解另一种风格。\n\n- 在生产项目中：\n\n  - 当你不需要使用构建工具，或者打算主要在低复杂度的场景中使用 Vue，例如渐进增强的应用场景，推荐采用选项式 API。\n\n  - 当你打算用 Vue 构建完整的单页应用，推荐采用组合式 API + 单文件组件。\n\n在学习阶段，你不必只固守一种风格。在接下来的文档中我们会为你提供一系列两种风格的代码供你参考，你可以随时通过左上角的 **API 风格偏好**来做切换。\n\n## 还有其他问题？ {#still-got-questions}\n\n请查看我们的 [FAQ](/about/faq)。\n\n## 选择你的学习路径 {#pick-your-learning-path}\n\n不同的开发者有不同的学习方式。尽管在可能的情况下，我们推荐你通读所有内容，但你还是可以自由地选择一种自己喜欢的学习路径！\n\n<div class=\"vt-box-container next-steps\">\n  <a class=\"vt-box\" href=\"/tutorial/\">\n    <p class=\"next-steps-link\">尝试互动教程</p>\n    <p class=\"next-steps-caption\">适合喜欢边动手边学的读者。</p>\n  </a>\n  <a class=\"vt-box\" href=\"/guide/quick-start.html\">\n    <p class=\"next-steps-link\">继续阅读该指南</p>\n    <p class=\"next-steps-caption\">该指南会带你深入了解框架所有方面的细节。</p>\n  </a>\n  <a class=\"vt-box\" href=\"/examples/\">\n    <p class=\"next-steps-link\">查看示例</p>\n    <p class=\"next-steps-caption\">浏览核心功能和常见用户界面的示例。</p>\n  </a>\n</div>\n\n\n\n================================================\nFILE: src/guide/quick-start.md\n================================================\n---\nfooter: false\n---\n\n<script setup>\nimport { VTCodeGroup, VTCodeGroupTab } from '@vue/theme'\n</script>\n\n# 快速上手 {#quick-start}\n\n## 线上尝试 Vue {#try-vue-online}\n\n- 想要快速体验 Vue，你可以直接试试我们的[演练场](https://play.vuejs.org/#eNo9jcEKwjAMhl/lt5fpQYfXUQfefAMvvRQbddC1pUuHUPrudg4HIcmXjyRZXEM4zYlEJ+T0iEPgXjn6BB8Zhp46WUZWDjCa9f6w9kAkTtH9CRinV4fmRtZ63H20Ztesqiylphqy3R5UYBqD1UyVAPk+9zkvV1CKbCv9poMLiTEfR2/IXpSoXomqZLtti/IFwVtA9A==)。\n\n- 如果你更喜欢不用任何构建的原始 HTML，可以使用 [JSFiddle](https://jsfiddle.net/yyx990803/2ke1ab0z/) 入门。\n\n- 如果你已经比较熟悉 Node.js 和构建工具等概念，还可以直接在浏览器中打开 [StackBlitz](https://vite.new/vue) 来尝试完整的构建设置。\n\n- 要了解推荐的设置流程，请观看这个互动式 [Scrimba](http://scrimba.com/links/vue-quickstart) 教程，它将向你展示如何运行、编辑和部署你的第一个 Vue 应用程序。\n\n## 创建一个 Vue 应用 {#creating-a-vue-application}\n\n:::tip 前提条件\n\n- 熟悉命令行\n- 已安装 `^20.19.0 || >=22.12.0` 版本的 [Node.js](https://nodejs.org/)\n:::\n\n在本节中，我们将介绍如何在本地搭建 Vue [单页应用](/guide/extras/ways-of-using-vue#single-page-application-spa)。创建的项目将使用基于 [Vite](https://vitejs.dev) 的构建设置，并允许我们使用 Vue 的[单文件组件](/guide/scaling-up/sfc) (SFC)。\n\n确保你安装了最新版本的 [Node.js](https://nodejs.org/)，并且你的当前工作目录正是打算创建项目的目录。在命令行中运行以下命令 (不要带上 `$` 符号)：\n\n::: code-group\n\n```sh [npm]\n$ npm create vue@latest\n```\n\n```sh [pnpm]\n$ pnpm create vue@latest\n```\n\n```sh [yarn]\n# For Yarn (v1+)\n$ yarn create vue\n\n# For Yarn Modern (v2+)\n$ yarn create vue@latest\n  \n# For Yarn ^v4.11\n$ yarn dlx create-vue@latest\n```\n\n```sh [bun]\n$ bun create vue@latest\n```\n:::\n\n这一指令将会安装并执行 [create-vue](https://github.com/vuejs/create-vue)，它是 Vue 官方的项目脚手架工具。你将会看到一些诸如 TypeScript 和测试支持之类的可选功能提示：\n\n<div class=\"language-sh\"><pre><code><span style=\"color:var(--vt-c-green);\">✔</span> <span style=\"color:#A6ACCD;\">Project name: <span style=\"color:#888;\">… <span style=\"color:#89DDFF;\">&lt;</span><span style=\"color:#888;\">your-project-name</span><span style=\"color:#89DDFF;\">&gt;</span></span></span>\n<span style=\"color:var(--vt-c-green);\">✔</span> <span style=\"color:#A6ACCD;\">Add TypeScript? <span style=\"color:#888;\">… <span style=\"color:#89DDFF;text-decoration:underline\">No</span> / Yes</span></span>\n<span style=\"color:var(--vt-c-green);\">✔</span> <span style=\"color:#A6ACCD;\">Add JSX Support? <span style=\"color:#888;\">… <span style=\"color:#89DDFF;text-decoration:underline\">No</span> / Yes</span></span>\n<span style=\"color:var(--vt-c-green);\">✔</span> <span style=\"color:#A6ACCD;\">Add Vue Router for Single Page Application development? <span style=\"color:#888;\">… <span style=\"color:#89DDFF;text-decoration:underline\">No</span> / Yes</span></span>\n<span style=\"color:var(--vt-c-green);\">✔</span> <span style=\"color:#A6ACCD;\">Add Pinia for state management? <span style=\"color:#888;\">… <span style=\"color:#89DDFF;text-decoration:underline\">No</span> / Yes</span></span>\n<span style=\"color:var(--vt-c-green);\">✔</span> <span style=\"color:#A6ACCD;\">Add Vitest for Unit testing? <span style=\"color:#888;\">… <span style=\"color:#89DDFF;text-decoration:underline\">No</span> / Yes</span></span>\n<span style=\"color:var(--vt-c-green);\">✔</span> <span style=\"color:#A6ACCD;\">Add an End-to-End Testing Solution? <span style=\"color:#888;\">… <span style=\"color:#89DDFF;text-decoration:underline\">No</span> / Cypress / Nightwatch / Playwright</span></span>\n<span style=\"color:var(--vt-c-green);\">✔</span> <span style=\"color:#A6ACCD;\">Add ESLint for code quality? <span style=\"color:#888;\">… No / <span style=\"color:#89DDFF;text-decoration:underline\">Yes</span></span></span>\n<span style=\"color:var(--vt-c-green);\">✔</span> <span style=\"color:#A6ACCD;\">Add Prettier for code formatting? <span style=\"color:#888;\">… <span style=\"color:#89DDFF;text-decoration:underline\">No</span> / Yes</span></span>\n<span style=\"color:var(--vt-c-green);\">✔</span> <span style=\"color:#A6ACCD;\">Add Vue DevTools 7 extension for debugging? (experimental) <span style=\"color:#888;\">… <span style=\"color:#89DDFF;text-decoration:underline\">No</span> / Yes</span></span>\n<span></span>\n<span style=\"color:#A6ACCD;\">Scaffolding project in ./<span style=\"color:#89DDFF;\">&lt;</span><span style=\"color:#888;\">your-project-name</span><span style=\"color:#89DDFF;\">&gt;</span>...</span>\n<span style=\"color:#A6ACCD;\">Done.</span></code></pre></div>\n\n如果不确定是否要开启某个功能，你可以直接按下回车键选择 `No`。在项目被创建后，通过以下步骤安装依赖并启动开发服务器：\n\n::: code-group\n\n```sh-vue [npm]\n$ cd {{'<your-project-name>'}}\n$ npm install\n$ npm run dev\n```\n\n```sh-vue [pnpm]\n$ cd {{'<your-project-name>'}}\n$ pnpm install\n$ pnpm run dev\n```\n\n```sh-vue [yarn]\n$ cd {{'<your-project-name>'}}\n$ yarn\n$ yarn dev\n```\n\n```sh-vue [bun]\n$ cd {{'<your-project-name>'}}\n$ bun install\n$ bun run dev\n```\n\n:::\n\n\n你现在应该已经运行起来了你的第一个 Vue 项目！请注意，生成的项目中的示例组件使用的是[组合式 API](/guide/introduction#composition-api) 和 `<script setup>`，而非[选项式 API](/guide/introduction#options-api)。下面是一些补充提示：\n\n- 推荐的 IDE 配置是 [Visual Studio Code](https://code.visualstudio.com/) + [Vue - Official 扩展](https://marketplace.visualstudio.com/items?itemName=Vue.volar)。如果使用其他编辑器，参考 [IDE 支持章节](/guide/scaling-up/tooling#ide-support)。\n- 更多工具细节，包括与后端框架的整合，我们会在[工具链指南](/guide/scaling-up/tooling)进行讨论。\n- 要了解构建工具 Vite 更多背后的细节，请查看 [Vite 文档](https://cn.vitejs.dev)。\n- 如果你选择使用 TypeScript，请阅读 [TypeScript 使用指南](typescript/overview)。\n\n当你准备将应用发布到生产环境时，请运行：\n\n::: code-group\n\n```sh [npm]\n$ npm run build\n```\n\n```sh [pnpm]\n$ pnpm run build\n```\n\n```sh [yarn]\n$ yarn build\n```\n\n```sh [bun]\n$ bun run build\n```\n\n:::\n\n\n此命令会在 `./dist` 文件夹中为你的应用创建一个生产环境的构建版本。关于将应用上线生产环境的更多内容，请阅读[生产环境部署指南](/guide/best-practices/production-deployment)。\n\n[下一步>](#next-steps)\n\n## 通过 CDN 使用 Vue {#using-vue-from-cdn}\n\n你可以借助 script 标签直接通过 CDN 来使用 Vue：\n\n```html\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n```\n\n这里我们使用了 [unpkg](https://unpkg.com/)，但你也可以使用任何提供 npm 包服务的 CDN，例如 [jsdelivr](https://www.jsdelivr.com/package/npm/vue) 或 [cdnjs](https://cdnjs.com/libraries/vue)。当然，你也可以下载此文件并自行提供服务。\n\n通过 CDN 使用 Vue 时，不涉及“构建步骤”。这使得设置更加简单，并且可以用于增强静态的 HTML 或与后端框架集成。但是，你将无法使用单文件组件 (SFC) 语法。\n\n### 使用全局构建版本 {#using-the-global-build}\n\n上面的链接使用了*全局构建版本*的 Vue，该版本的所有顶层 API 都以属性的形式暴露在了全局的 `Vue` 对象上。这里有一个使用全局构建版本的例子：\n\n<div class=\"options-api\">\n\n```html\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n\n<div id=\"app\">{{ message }}</div>\n\n<script>\n  const { createApp } = Vue\n  \n  createApp({\n    data() {\n      return {\n        message: 'Hello Vue!'\n      }\n    }\n  }).mount('#app')\n</script>\n```\n\n[CodePen 示例 >](https://codepen.io/vuejs-examples/pen/QWJwJLp)\n\n</div>\n\n<div class=\"composition-api\">\n\n```html\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n\n<div id=\"app\">{{ message }}</div>\n\n<script>\n  const { createApp, ref } = Vue\n\n  createApp({\n    setup() {\n      const message = ref('Hello vue!')\n      return {\n        message\n      }\n    }\n  }).mount('#app')\n</script>\n```\n\n[CodePen 示例 >](https://codepen.io/vuejs-examples/pen/eYQpQEG)\n\n:::tip\n本指南中许多关于组合式 API 的例子将使用 `<script setup>` 语法，这需要构建工具。如果你打算在没有构建步骤的情况下使用组合式 API，请参考 [`setup()` 选项](/api/composition-api-setup)的用法。\n:::\n\n</div>\n\n### 使用 ES 模块构建版本 {#using-the-es-module-build}\n\n在本文档的其余部分我们使用的主要是 [ES 模块](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules)语法。现代浏览器大多都已原生支持 ES 模块。因此我们可以像这样通过 CDN 以及原生 ES 模块使用 Vue：\n\n<div class=\"options-api\">\n\n```html{3,4}\n<div id=\"app\">{{ message }}</div>\n\n<script type=\"module\">\n  import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'\n  \n  createApp({\n    data() {\n      return {\n        message: 'Hello Vue!'\n      }\n    }\n  }).mount('#app')\n</script>\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n```html{3,4}\n<div id=\"app\">{{ message }}</div>\n\n<script type=\"module\">\n  import { createApp, ref } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'\n\n  createApp({\n    setup() {\n      const message = ref('Hello Vue!')\n      return {\n        message\n      }\n    }\n  }).mount('#app')\n</script>\n```\n\n</div>\n\n注意我们使用了 `<script type=\"module\">`，且导入的 CDN URL 指向的是 Vue 的 **ES 模块构建版本**。\n\n<div class=\"options-api\">\n\n[CodePen 示例 >](https://codepen.io/vuejs-examples/pen/VwVYVZO)\n\n</div>\n<div class=\"composition-api\">\n\n[CodePen 示例 >](https://codepen.io/vuejs-examples/pen/MWzazEv)\n\n</div>\n\n### 启用 Import maps {#enabling-import-maps}\n\n在上面的示例中，我们使用了完整的 CDN URL 来导入，但在文档的其余部分中，你将看到如下代码：\n\n```js\nimport { createApp } from 'vue'\n```\n\n我们可以使用[导入映射表 (Import Maps)](https://caniuse.com/import-maps) 来告诉浏览器如何定位到导入的 `vue`：\n\n<div class=\"options-api\">\n\n```html{1-7,12}\n<script type=\"importmap\">\n  {\n    \"imports\": {\n      \"vue\": \"https://unpkg.com/vue@3/dist/vue.esm-browser.js\"\n    }\n  }\n</script>\n\n<div id=\"app\">{{ message }}</div>\n\n<script type=\"module\">\n  import { createApp } from 'vue'\n\n  createApp({\n    data() {\n      return {\n        message: 'Hello Vue!'\n      }\n    }\n  }).mount('#app')\n</script>\n```\n\n[CodePen 示例 >](https://codepen.io/vuejs-examples/pen/wvQKQyM)\n\n</div>\n\n<div class=\"composition-api\">\n\n```html{1-7,12}\n<script type=\"importmap\">\n  {\n    \"imports\": {\n      \"vue\": \"https://unpkg.com/vue@3/dist/vue.esm-browser.js\"\n    }\n  }\n</script>\n\n<div id=\"app\">{{ message }}</div>\n\n<script type=\"module\">\n  import { createApp, ref } from 'vue'\n\n  createApp({\n    setup() {\n      const message = ref('Hello Vue!')\n      return {\n        message\n      }\n    }\n  }).mount('#app')\n</script>\n```\n\n[CodePen 示例 >](https://codepen.io/vuejs-examples/pen/YzRyRYM)\n\n</div>\n\n你也可以在映射表中添加其他的依赖——但请务必确保你使用的是该库的 ES 模块版本。\n\n:::tip 导入映射表的浏览器支持情况\n导入映射表是一个相对较新的浏览器功能。请确保使用其[支持范围](https://caniuse.com/import-maps)内的浏览器。请注意，只有 Safari 16.4 以上版本支持。\n:::\n\n:::warning 生产环境中的注意事项\n到目前为止示例中使用的都是 Vue 的开发构建版本——如果你打算在生产中通过 CDN 使用 Vue，请务必查看[生产环境部署指南](/guide/best-practices/production-deployment#without-build-tools)。\n\n虽然 Vue 可以不依赖构建系统使用，但也可以考虑使用 [`vuejs/petite-vue`](https://github.com/vuejs/petite-vue) 这个替代方案，以更好地适配可能在 [`jquery/jquery`](https://github.com/jquery/jquery) (过去) 或 [`alpinejs/alpine`](https://github.com/alpinejs/alpine) (现在) 的上下文中使用的情况。\n:::\n\n### 拆分模块 {#splitting-up-the-modules}\n\n随着对这份指南的逐步深入，我们可能需要将代码分割成单独的 JavaScript 文件，以便更容易管理。例如：\n\n```html [index.html]\n<div id=\"app\"></div>\n\n<script type=\"module\">\n  import { createApp } from 'vue'\n  import MyComponent from './my-component.js'\n\n  createApp(MyComponent).mount('#app')\n</script>\n```\n\n<div class=\"options-api\">\n\n```js [my-component.js]\nexport default {\n  data() {\n    return { count: 0 }\n  },\n  template: `<div>Count is: {{ count }}</div>`\n}\n```\n\n</div>\n<div class=\"composition-api\">\n\n```js [my-component.js]\nimport { ref } from 'vue'\nexport default {\n  setup() {\n    const count = ref(0)\n    return { count }\n  },\n  template: `<div>Count is: {{ count }}</div>`\n}\n```\n\n</div>\n\n如果直接在浏览器中打开了上面的 `index.html`，你会发现它抛出了一个错误，因为 ES 模块不能通过 `file://` 协议工作，也即是当你打开一个本地文件时浏览器使用的协议。\n\n由于安全原因，ES 模块只能通过 `http://` 协议工作，也即是浏览器在打开网页时使用的协议。为了使 ES 模块在我们的本地机器上工作，我们需要使用本地的 HTTP 服务器，通过 `http://` 协议来提供 `index.html`。\n\n要启动一个本地的 HTTP 服务器，请先安装 [Node.js](https://nodejs.org/zh/)，然后通过命令行在 HTML 文件所在文件夹下运行 `npx serve`。你也可以使用其他任何可以基于正确的 MIME 类型服务静态文件的 HTTP 服务器。\n\n可能你也注意到了，这里导入的组件模板是内联的 JavaScript 字符串。如果你正在使用 VS Code，你可以安装 [es6-string-html](https://marketplace.visualstudio.com/items?itemName=Tobermory.es6-string-html) 扩展，然后在字符串前加上一个前缀注释 `/*html*/` 以高亮语法。\n\n## 下一步 {#next-steps}\n\n如果你尚未阅读[简介](/guide/introduction)，我们强烈推荐你在移步到后续文档之前返回去阅读一下。\n\n<div class=\"vt-box-container next-steps\">\n  <a class=\"vt-box\" href=\"/guide/essentials/application.html\">\n    <p class=\"next-steps-link\">继续阅读该指南</p>\n    <p class=\"next-steps-caption\">该指南会带你深入了解框架所有方面的细节。</p>\n  </a>\n  <a class=\"vt-box\" href=\"/tutorial/\">\n    <p class=\"next-steps-link\">尝试互动教程</p>\n    <p class=\"next-steps-caption\">适合喜欢边动手边学的读者。</p>\n  </a>\n  <a class=\"vt-box\" href=\"/examples/\">\n    <p class=\"next-steps-link\">查看示例</p>\n    <p class=\"next-steps-caption\">浏览核心功能和常见用户界面的示例。</p>\n  </a>\n</div>\n\n\n\n================================================\nFILE: src/guide/best-practices/accessibility.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/best-practices/performance.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/best-practices/production-deployment.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/best-practices/security.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/built-ins/keep-alive.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/built-ins/suspense.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/built-ins/teleport.md\n================================================\n# Teleport {#teleport}\n\n`<Teleport>` 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。\n\n## 基本用法 {#basic-usage}\n\n有时我们可能会遇到这样的场景：一个组件模板的一部分在逻辑上从属于该组件，但从整个应用视图的角度来看，它在 DOM 中应该被渲染在其他地方，甚至在整个 Vue 应用外部。\n\n这类场景最常见的例子就是全屏的模态框。理想情况下，我们希望触发模态框的按钮和模态框本身的代码是在同一个单文件组件中，因为它们都与组件的开关状态有关。但这意味着该模态框将与按钮一起渲染在应用 DOM 结构里很深的地方。这会导致该模态框的 CSS 布局代码很难写。\n\n试想下面这样的 HTML 结构：\n\n```vue-html\n<div class=\"outer\">\n  <h3>Tooltips with Vue 3 Teleport</h3>\n  <div>\n    <MyModal />\n  </div>\n</div>\n```\n\n接下来我们来看看 `<MyModal>` 的实现：\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst open = ref(false)\n</script>\n\n<template>\n  <button @click=\"open = true\">Open Modal</button>\n\n  <div v-if=\"open\" class=\"modal\">\n    <p>Hello from the modal!</p>\n    <button @click=\"open = false\">Close</button>\n  </div>\n</template>\n\n<style scoped>\n.modal {\n  position: fixed;\n  z-index: 999;\n  top: 20%;\n  left: 50%;\n  width: 300px;\n  margin-left: -150px;\n}\n</style>\n```\n\n</div>\n<div class=\"options-api\">\n\n```vue\n<script>\nexport default {\n  data() {\n    return {\n      open: false\n    }\n  }\n}\n</script>\n\n<template>\n  <button @click=\"open = true\">Open Modal</button>\n\n  <div v-if=\"open\" class=\"modal\">\n    <p>Hello from the modal!</p>\n    <button @click=\"open = false\">Close</button>\n  </div>\n</template>\n\n<style scoped>\n.modal {\n  position: fixed;\n  z-index: 999;\n  top: 20%;\n  left: 50%;\n  width: 300px;\n  margin-left: -150px;\n}\n</style>\n```\n\n</div>\n\n这个组件中有一个 `<button>` 按钮来触发打开模态框，和一个 class 名为 `.modal` 的 `<div>`，它包含了模态框的内容和一个用来关闭的按钮。\n\n当在初始 HTML 结构中使用这个组件时，会有一些潜在的问题：\n\n- `position: fixed` 能够相对于浏览器窗口放置有一个条件，那就是不能有任何祖先元素设置了 `transform`、`perspective` 或者 `filter` 样式属性。也就是说如果我们想要用 CSS `transform` 为祖先节点 `<div class=\"outer\">` 设置动画，就会不小心破坏模态框的布局！\n\n- 这个模态框的 `z-index` 受限于它的容器元素。如果有其他元素与 `<div class=\"outer\">` 重叠并有更高的 `z-index`，则它会覆盖住我们的模态框。\n\n`<Teleport>` 提供了一个更简单的方式来解决此类问题，让我们不需要再顾虑 DOM 结构的问题。让我们用 `<Teleport>` 改写一下 `<MyModal>`：\n\n```vue-html{3,8}\n<button @click=\"open = true\">Open Modal</button>\n\n<Teleport to=\"body\">\n  <div v-if=\"open\" class=\"modal\">\n    <p>Hello from the modal!</p>\n    <button @click=\"open = false\">Close</button>\n  </div>\n</Teleport>\n```\n\n`<Teleport>` 接收一个 `to` prop 来指定传送的目标。`to` 的值可以是一个 CSS 选择器字符串，也可以是一个 DOM 元素对象。这段代码的作用就是告诉 Vue“把以下模板片段**传送到 `body`** 标签下”。\n\n你可以点击下面这个按钮，然后通过浏览器的开发者工具，在 `<body>` 标签下找到模态框元素：\n\n<script setup>\nimport { ref } from 'vue'\nconst open = ref(false)\n</script>\n\n<div class=\"demo\">\n  <button @click=\"open = true\">Open Modal</button>\n  <ClientOnly>\n    <Teleport to=\"body\">\n      <div v-if=\"open\" class=\"demo modal-demo\">\n        <p style=\"margin-bottom:20px\">Hello from the modal!</p>\n        <button @click=\"open = false\">Close</button>\n      </div>\n    </Teleport>\n  </ClientOnly>\n</div>\n\n<style>\n.modal-demo {\n  position: fixed;\n  z-index: 999;\n  top: 20%;\n  left: 50%;\n  width: 300px;\n  margin-left: -150px;\n  background-color: var(--vt-c-bg);\n  padding: 30px;\n  border-radius: 8px;\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);\n}\n</style>\n\n我们也可以将 `<Teleport>` 和 [`<Transition>`](./transition) 结合使用来创建一个带动画的模态框。你可以看看[这个示例](/examples/#modal)。\n\n:::tip\n`<Teleport>` 挂载时，传送的 `to` 目标必须已经存在于 DOM 中。理想情况下，这应该是整个 Vue 应用 DOM 树外部的一个元素。如果目标元素也是由 Vue 渲染的，你需要确保在挂载 `<Teleport>` 之前先挂载该元素。\n:::\n\n## 搭配组件使用 {#using-with-components}\n\n`<Teleport>` 只改变了渲染的 DOM 结构，它不会影响组件间的逻辑关系。也就是说，如果 `<Teleport>` 包含了一个组件，那么该组件始终和这个使用了 `<Teleport>` 的组件保持逻辑上的父子关系。传入的 props 和触发的事件也会照常工作。\n\n这也意味着来自父组件的注入也会按预期工作，子组件将在 Vue Devtools 中嵌套在父级组件下面，而不是放在实际内容移动到的地方。\n\n## 禁用 Teleport {#disabling-teleport}\n\n在某些场景下可能需要视情况禁用 `<Teleport>`。举例来说，我们想要在桌面端将一个组件当做浮层来渲染，但在移动端则当作行内组件。我们可以通过对 `<Teleport>` 动态地传入一个 `disabled` prop 来处理这两种不同情况：\n\n```vue-html\n<Teleport :disabled=\"isMobile\">\n  ...\n</Teleport>\n```\n\n然后我们可以动态地更新 `isMobile`。\n\n## 多个 Teleport 共享目标 {#multiple-teleports-on-the-same-target}\n\n一个可重用的 `<Modal>` 组件可能同时存在多个实例。对于此类场景，多个 `<Teleport>` 组件可以将其内容挂载在同一个目标元素上，而顺序就是简单的顺次追加，后挂载的将排在目标元素下更后面的位置上，但都在目标元素中。\n\n比如下面这样的用例：\n\n```vue-html\n<Teleport to=\"#modals\">\n  <div>A</div>\n</Teleport>\n<Teleport to=\"#modals\">\n  <div>B</div>\n</Teleport>\n```\n\n渲染的结果为：\n\n```html\n<div id=\"modals\">\n  <div>A</div>\n  <div>B</div>\n</div>\n```\n\n## 延迟解析的 Teleport <sup class=\"vt-badge\" data-text=\"3.5+\" /> {#deferred-teleport}\n\n在 Vue 3.5 及更高版本中，我们可以使用 `defer` prop 推迟 Teleport 的目标解析，直到应用的其他部分挂载。这允许 Teleport 将由 Vue 渲染且位于组件树之后部分的容器元素作为目标：\n\n```vue-html\n<Teleport defer to=\"#late-div\">...</Teleport>\n\n<!-- 稍后出现于模板中的某处 -->\n<div id=\"late-div\"></div>\n```\n\n请注意，目标元素必须与 Teleport 在同一个挂载/更新周期内渲染，即如果 `<div>` 在一秒后才挂载，Teleport 仍然会报错。延迟 Teleport 的原理与 `mounted` 生命周期钩子类似。\n\n---\n\n**参考**\n\n- [`<Teleport>` API 参考](/api/built-in-components#teleport)\n- [在 SSR 中处理 Teleports](/guide/scaling-up/ssr#teleports)\n\n\n\n================================================\nFILE: src/guide/built-ins/transition-group.md\n================================================\n<script setup>\nimport ListBasic from './transition-demos/ListBasic.vue'\nimport ListMove from './transition-demos/ListMove.vue'\nimport ListStagger from './transition-demos/ListStagger.vue'\n</script>\n\n# TransitionGroup {#transitiongroup}\n\n`<TransitionGroup>` 是一个内置组件，用于对 `v-for` 列表中的元素或组件的插入、移除和顺序改变添加动画效果。\n\n## 和 `<Transition>` 的区别 {#differences-from-transition}\n\n`<TransitionGroup>` 支持和 `<Transition>` 基本相同的 props、CSS 过渡 class 和 JavaScript 钩子监听器，但有以下几点区别：\n\n- 默认情况下，它不会渲染一个容器元素。但你可以通过传入 `tag` prop 来指定一个元素作为容器元素来渲染。\n\n- [过渡模式](./transition#transition-modes)在这里不可用，因为我们不再是在互斥的元素之间进行切换。\n\n- 列表中的每个元素都**必须**有一个独一无二的 `key` attribute。\n\n- CSS 过渡 class 会被应用在列表内的元素上，**而不是**容器元素上。\n\n:::tip\n当在 [DOM 内模板](/guide/essentials/component-basics#in-dom-template-parsing-caveats)中使用时，组件名需要写为 `<transition-group>`。\n:::\n\n## 进入 / 离开动画 {#enter-leave-transitions}\n\n这里是 `<TransitionGroup>` 对一个 `v-for` 列表添加进入 / 离开动画的示例：\n\n```vue-html\n<TransitionGroup name=\"list\" tag=\"ul\">\n  <li v-for=\"item in items\" :key=\"item\">\n    {{ item }}\n  </li>\n</TransitionGroup>\n```\n\n```css\n.list-enter-active,\n.list-leave-active {\n  transition: all 0.5s ease;\n}\n.list-enter-from,\n.list-leave-to {\n  opacity: 0;\n  transform: translateX(30px);\n}\n```\n\n<ListBasic />\n\n## 移动动画 {#move-transitions}\n\n上面的示例有一些明显的缺陷：当某一项被插入或移除时，它周围的元素会立即发生“跳跃”而不是平稳地移动。我们可以通过添加一些额外的 CSS 规则来解决这个问题：\n\n```css{1,13-17}\n.list-move, /* 对移动中的元素应用的过渡 */\n.list-enter-active,\n.list-leave-active {\n  transition: all 0.5s ease;\n}\n\n.list-enter-from,\n.list-leave-to {\n  opacity: 0;\n  transform: translateX(30px);\n}\n\n/* 确保将离开的元素从布局流中删除\n  以便能够正确地计算移动的动画。 */\n.list-leave-active {\n  position: absolute;\n}\n```\n\n现在它看起来好多了，甚至对整个列表执行洗牌的动画也都非常流畅：\n\n<ListMove />\n\n[完整的示例](/examples/#list-transition)\n\n### 自定义过渡组 class {#custom-transitiongroup-classes}\n\n你还可以通过向 `<TransitionGroup>` 传递 `moveClass` prop 为移动元素指定自定义过渡 class，类似于[自定义过渡 class](/guide/built-ins/transition.html#custom-transition-classes)。\n\n## 渐进延迟列表动画 {#staggering-list-transitions}\n\n通过在 JavaScript 钩子中读取元素的 data attribute，我们可以实现带渐进延迟的列表动画。首先，我们把每一个元素的索引渲染为该元素上的一个 data attribute：\n\n```vue-html{11}\n<TransitionGroup\n  tag=\"ul\"\n  :css=\"false\"\n  @before-enter=\"onBeforeEnter\"\n  @enter=\"onEnter\"\n  @leave=\"onLeave\"\n>\n  <li\n    v-for=\"(item, index) in computedList\"\n    :key=\"item.msg\"\n    :data-index=\"index\"\n  >\n    {{ item.msg }}\n  </li>\n</TransitionGroup>\n```\n\n接着，在 JavaScript 钩子中，我们基于当前元素的 data attribute 对该元素的进场动画添加一个延迟。以下是一个基于 [GSAP library](https://gsap.com/) 的动画示例：\n\n```js{5}\nfunction onEnter(el, done) {\n  gsap.to(el, {\n    opacity: 1,\n    height: '1.6em',\n    delay: el.dataset.index * 0.15,\n    onComplete: done\n  })\n}\n```\n\n<ListStagger />\n\n<div class=\"composition-api\">\n\n[在演练场中查看完整示例](https://play.vuejs.org/#eNqlVMuu0zAQ/ZVRNklRm7QLWETtBW4FSFCxYkdYmGSSmjp28KNQVfl3xk7SFyvEponPGc+cOTPNOXrbdenRYZRHa1Nq3lkwaF33VEjedkpbOIPGeg6lajtnsYIeaq1aiOlSfAlqDOtG3L8SUchSSWNBcPrZwNdCAqVqTZND/KxdibBDjKGf3xIfWXngCNs9k4/Udu/KA3xWWnPz1zW0sOOP6CcnG3jv9ImIQn67SvrpUJ9IE/WVxPHsSkw97gbN0zFJZrB5grNPrskcLUNXac2FRZ0k3GIbIvxLSsVTq3bqF+otM5jMUi5L4So0SSicHplwOKOyfShdO1lariQo+Yy10vhO+qwoZkNFFKmxJ4Gp6ljJrRe+vMP3yJu910swNXqXcco1h0pJHDP6CZHEAAcAYMydwypYCDAkJRdX6Sts4xGtUDAKotIVs9Scpd4q/A0vYJmuXo5BSm7JOIEW81DVo77VR207ZEf8F23LB23T+X9VrbNh82nn6UAz7ASzSCeANZe0AnBctIqqbIoojLCIIBvoL5pJw31DH7Ry3VDKsoYinSii4ZyXxhBQM2Fwwt58D7NeoB8QkXfDvwRd2XtceOsCHkwc8KCINAk+vADJppQUFjZ0DsGVGT3uFn1KSjoPeKLoaYtvCO/rIlz3vH9O5FiU/nXny/pDT6YGKZngg0/Zg1GErrMbp6N5NHxJFi3N/4dRkj5IYf5ULxCmiPJpI4rIr4kHimhvbWfyLHOyOzQpNZZ57jXNy4nRGFLTR/0fWBqe7w==)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中查看完整示例](https://play.vuejs.org/#eNqtVE2P0zAQ/SujXNqgNmkPcIjaBbYCJKg4cSMcTDJNTB07+KNsVfW/M3aabNpyQltViT1vPPP8Zian6H3bJgeHURatTKF5ax9yyZtWaQuVYS3stGpg4peTXOayUNJYEJwea/ieS4ATNKbKYPKoXYGwRZzAeTYGPrNizxE2NZO30KZ2xR6+Kq25uTuGFrb81vrFyQo+On0kIJc/PCV8CmxL3DEnLJy8e8ksm8bdGkCjdVr2O4DfDvWRgtGN/JYC0SOkKVTTOotl1jv3hi3d+DngENILkey4sKinU26xiWH9AH6REN/Eqq36g3rDDE7jhMtCuBLN1NbcJIFEHN9RaNDWqjQDAyUfcac0fpA+CYoRCRSJsUeBiWpZwe2RSrK4w2rkVe2rdYG6LD5uH3EGpZI4iuurTdwDNBjpRJclg+UlhP914UnMZfIGm8kIKVEwciYivhoGLQlQ4hO8gkWyfD1yVHJDKgu0mAUmPXLuxRkYb5Ed8H8YL/7BeGx7Oa6hkLmk/yodBoo21BKtYBZpB7DikroKDvNGUeZ1HoVmyCNIO/ibZtJwy5X8pJVru9CWVeTpRB51+6wwhgw7Jgz2tnc/Q6/M0ZeWwKvmGZye0Wu78PIGexC6swdGxEnw/q6HOYUkt9DwMwhKxfS6GpY+KPHc45G8+6EYAV7reTjucf/uwUtSmvvTME1wDuISlVTwTqf0RiiyrtKR0tEs6r5l84b645dRkr5zoT8oXwBMHg2Tlke+jbwhj2prW5OlqZPtvkroYqnH3lK9nLgI46scnf8Cn22kBA==)\n\n</div>\n\n---\n\n**参考**\n\n- [`<TransitionGroup>` API 参考](/api/built-in-components#transitiongroup)\n\n\n\n================================================\nFILE: src/guide/built-ins/transition.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/built-ins/keep-alive-demos/CompA.vue\n================================================\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\n</script>\n\n<template>\n  <p>Current component: A</p>\n  <span style=\"margin-right: 20px\">Count: {{ count }}</span>\n  <button @click=\"count++\">+</button>\n</template>\n\n\n\n================================================\nFILE: src/guide/built-ins/keep-alive-demos/CompB.vue\n================================================\n<script setup>\nimport { ref } from 'vue'\nconst msg = ref('')\n</script>\n\n<template>\n  <p>Current component: B</p>\n  <span style=\"margin-right: 20px\">Message is: {{ msg }}</span>\n  <input v-model=\"msg\">\n</template>\n\n\n\n================================================\nFILE: src/guide/built-ins/keep-alive-demos/SwitchComponent.vue\n================================================\n<script setup>\nimport { shallowRef } from 'vue'\nimport CompA from './CompA.vue'\nimport CompB from './CompB.vue'\n\nconst current = shallowRef(CompA)\n\ndefineProps({ useKeepAlive: Boolean })\n</script>\n\n<template>\n  <div class=\"demo\">\n    <label><input type=\"radio\" v-model=\"current\" :value=\"CompA\" /> A</label>\n    <label><input type=\"radio\" v-model=\"current\" :value=\"CompB\" /> B</label>\n    <template v-if=\"useKeepAlive\">\n      <KeepAlive>\n        <component :is=\"current\"></component>\n      </KeepAlive>\n    </template>\n    <template v-else>\n      <component :is=\"current\"></component>\n    </template>\n  </div>\n</template>\n\n\n================================================\nFILE: src/guide/built-ins/transition-demos/Basic.vue\n================================================\n<script setup>\nimport { ref } from 'vue'\nconst show = ref(true)\n</script>\n\n<template>\n  <div class=\"demo\">\n    <button @click=\"show = !show\">Toggle</button>\n    <Transition name=\"fade\">\n      <p style=\"margin-top: 20px\" v-if=\"show\">hello</p>\n    </Transition>\n  </div>\n</template>\n\n<style>\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity 0.5s ease;\n}\n\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/built-ins/transition-demos/BetweenComponents.vue\n================================================\n<script setup>\nimport { h, ref } from 'vue'\n\nconst CompA = () => h('div', 'Component A')\nconst CompB = () => h('div', 'Component B')\n\nconst activeComponent = ref(CompA)\n</script>\n\n<template>\n  <div class=\"demo\">\n    <label>\n      <input type=\"radio\" v-model=\"activeComponent\" :value=\"CompA\" /> A\n    </label>\n    <label>\n      <input type=\"radio\" v-model=\"activeComponent\" :value=\"CompB\" /> B\n    </label>\n    <Transition name=\"fade\" mode=\"out-in\">\n      <component :is=\"activeComponent\"></component>\n    </Transition>\n  </div>\n</template>\n\n\n\n================================================\nFILE: src/guide/built-ins/transition-demos/BetweenElements.vue\n================================================\n<script setup>\nimport { ref } from 'vue'\n\ndefineProps(['mode'])\n\nconst docState = ref('saved')\n</script>\n\n<template>\n  <div class=\"demo transition-demo\">\n    <span style=\"margin-right: 20px\">Click to cycle through states: </span>\n    <div class=\"btn-container\">\n      <Transition name=\"slide-up\" :mode=\"mode\">\n        <button v-if=\"docState === 'saved'\" @click=\"docState = 'edited'\">\n          Edit\n        </button>\n        <button v-else-if=\"docState === 'edited'\" @click=\"docState = 'editing'\">\n          Save\n        </button>\n        <button v-else-if=\"docState === 'editing'\" @click=\"docState = 'saved'\">\n          Cancel\n        </button>\n      </Transition>\n    </div>\n  </div>\n</template>\n\n<style>\n.transition-demo {\n  display: flex;\n  align-items: center;\n}\n\n.transition-demo .btn-container {\n  display: inline-block;\n  position: relative;\n  height: 36px;\n}\n\n.transition-demo button {\n  position: absolute;\n  min-width: 60px;\n}\n\n.transition-demo button + button {\n  margin: 0;\n}\n\n.transition-demo .slide-up-enter-active,\n.transition-demo .slide-up-leave-active {\n  transition: all 0.25s ease-out;\n}\n\n.slide-up-enter-from {\n  opacity: 0;\n  transform: translateY(30px);\n}\n\n.slide-up-leave-to {\n  opacity: 0;\n  transform: translateY(-30px);\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/built-ins/transition-demos/CssAnimation.vue\n================================================\n<script setup>\nimport { ref } from 'vue'\nconst show = ref(true)\n</script>\n\n<template>\n  <div class=\"demo\">\n    <button @click=\"show = !show\">Toggle</button>\n    <Transition name=\"bounce\">\n      <p v-if=\"show\" style=\"margin-top: 20px; text-align: center\">\n        Hello here is some bouncy text!\n      </p>\n    </Transition>\n  </div>\n</template>\n\n<style>\n.bounce-enter-active {\n  animation: bounce-in 0.5s;\n}\n.bounce-leave-active {\n  animation: bounce-in 0.5s reverse;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.25);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/built-ins/transition-demos/JsHooks.vue\n================================================\n<script setup>\nimport { ref } from 'vue'\nimport gsap from 'gsap'\n\nconst show = ref(true)\n\nfunction onBeforeEnter(el) {\n  gsap.set(el, {\n    scaleX: 0.25,\n    scaleY: 0.25,\n    opacity: 1\n  })\n}\n\nfunction onEnter(el, done) {\n  gsap.to(el, {\n    duration: 1,\n    scaleX: 1,\n    scaleY: 1,\n    ease: 'elastic.inOut(2.5, 1)',\n    onComplete: done\n  })\n}\n\nfunction onLeave(el, done) {\n  gsap.to(el, {\n    duration: 0.7,\n    scaleX: 1,\n    scaleY: 1,\n    x: 300,\n    ease: 'elastic.inOut(2.5, 1)'\n  })\n  gsap.to(el, {\n    duration: 0.2,\n    delay: 0.5,\n    opacity: 0,\n    onComplete: done\n  })\n}\n</script>\n\n<template>\n  <div class=\"demo\">\n    <button @click=\"show = !show\">Toggle</button>\n\n    <Transition\n      @before-enter=\"onBeforeEnter\"\n      @enter=\"onEnter\"\n      @leave=\"onLeave\"\n      :css=\"false\"\n    >\n      <div class=\"gsap-box\" v-if=\"show\"></div>\n    </Transition>\n  </div>\n</template>\n\n<style>\n.gsap-box {\n  background: var(--vt-c-green);\n  margin-top: 20px;\n  width: 30px;\n  height: 30px;\n  border-radius: 50%;\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/built-ins/transition-demos/ListBasic.vue\n================================================\n<script setup>\nimport { reactive } from 'vue'\n\nconst items = reactive([1, 2, 3, 4, 5])\nlet nextNum = items.length + 1\n\nfunction add() {\n  items.splice(randomIndex(), 0, nextNum++)\n}\n\nfunction remove() {\n  items.splice(randomIndex(), 1)\n}\n\nfunction randomIndex() {\n  return Math.floor(Math.random() * items.length)\n}\n</script>\n\n<template>\n  <div class=\"demo\">\n    <button @click=\"add\">在任意位置添加一项</button>\n    <button @click=\"remove\">移除任意位置上的一项</button>\n    <TransitionGroup name=\"list\" tag=\"ul\" style=\"margin-top: 20px\">\n      <li v-for=\"item in items\" :key=\"item\">\n        {{ item }}\n      </li>\n    </TransitionGroup>\n  </div>\n</template>\n\n<style>\n.list-enter-active,\n.list-leave-active {\n  transition: all 0.5s ease;\n}\n.list-enter-from,\n.list-leave-to {\n  opacity: 0;\n  transform: translateX(30px);\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/built-ins/transition-demos/ListMove.vue\n================================================\n<script setup>\nimport { ref } from 'vue'\nconst items = ref([1, 2, 3, 4, 5])\nlet nextNum = items.value.length + 1\n\nfunction add() {\n  items.value.splice(randomIndex(), 0, nextNum++)\n}\n\nfunction remove() {\n  items.value.splice(randomIndex(), 1)\n}\n\nfunction randomIndex() {\n  return Math.floor(Math.random() * items.value.length)\n}\n\nfunction shuffle(array) {\n  let currentIndex = array.length\n  let randomIndex\n  while (currentIndex != 0) {\n    randomIndex = Math.floor(Math.random() * currentIndex)\n    currentIndex--\n    ;[array[currentIndex], array[randomIndex]] = [\n      array[randomIndex],\n      array[currentIndex]\n    ]\n  }\n  return array\n}\n</script>\n\n<template>\n  <div class=\"demo\">\n    <button @click=\"add\">Add</button>\n    <button @click=\"remove\">Remove</button>\n    <button @click=\"shuffle(items)\">Shuffle</button>\n    <TransitionGroup name=\"list2\" tag=\"ul\" style=\"margin-top: 20px\">\n      <li class=\"list-item\" v-for=\"item in items\" :key=\"item\">\n        {{ item }}\n      </li>\n    </TransitionGroup>\n  </div>\n</template>\n\n<style>\n.list2-move, /* apply transition to moving elements */\n.list2-enter-active,\n.list2-leave-active {\n  transition: all 0.5s ease;\n}\n\n.list2-enter-from,\n.list2-leave-to {\n  opacity: 0;\n  transform: translateX(30px);\n}\n\n/* ensure leaving items are taken out of layout flow so that moving\n   animations can be calculated correctly. */\n.list2-leave-active {\n  position: absolute !important;\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/built-ins/transition-demos/ListStagger.vue\n================================================\n<script setup>\nimport { ref, computed } from 'vue'\nimport gsap from 'gsap'\n\nconst list = [\n  { msg: 'Bruce Lee' },\n  { msg: 'Jackie Chan' },\n  { msg: 'Chuck Norris' },\n  { msg: 'Jet Li' },\n  { msg: 'Kung Fury' }\n]\n\nconst query = ref('')\n\nconst computedList = computed(() => {\n  return list.filter((item) => item.msg.toLowerCase().includes(query.value.toLowerCase()))\n})\n\nfunction onBeforeEnter(el) {\n  el.style.opacity = 0\n  el.style.height = 0\n}\n\nfunction onEnter(el, done) {\n  gsap.to(el, {\n    opacity: 1,\n    height: '1.6em',\n    delay: el.dataset.index * 0.15,\n    onComplete: done\n  })\n}\n\nfunction onLeave(el, done) {\n  gsap.to(el, {\n    opacity: 0,\n    height: 0,\n    delay: el.dataset.index * 0.15,\n    onComplete: done\n  })\n}\n</script>\n\n<template>\n  <div class=\"demo\" style=\"height: 265px\">\n    <input v-model=\"query\" style=\"margin-bottom: 20px\" />\n    <TransitionGroup\n      tag=\"ul\"\n      :css=\"false\"\n      @before-enter=\"onBeforeEnter\"\n      @enter=\"onEnter\"\n      @leave=\"onLeave\"\n    >\n      <li\n        v-for=\"(item, index) in computedList\"\n        :key=\"item.msg\"\n        :data-index=\"index\"\n      >\n        {{ item.msg }}\n      </li>\n    </TransitionGroup>\n  </div>\n</template>\n\n\n\n================================================\nFILE: src/guide/built-ins/transition-demos/NestedTransitions.vue\n================================================\n<script setup>\nimport { ref } from 'vue'\nconst show = ref(true)\n</script>\n\n<template>\n  <div class=\"demo\">\n    <button @click=\"show = !show\" style=\"margin-bottom: 20px\">Toggle</button>\n    <Transition duration=\"550\" name=\"nested\">\n      <div v-if=\"show\" class=\"transition-demo-outer\">\n        <div class=\"transition-demo-inner\">Hello</div>\n      </div>\n    </Transition>\n  </div>\n</template>\n\n<style>\n.transition-demo-outer,\n.transition-demo-inner {\n  background: #eee;\n  padding: 30px;\n  min-height: 100px;\n}\n\n.transition-demo-inner {\n  background: #ccc;\n  color: rgb(33, 53, 71);\n}\n\n.nested-enter-active,\n.nested-leave-active {\n  transition: all 0.3s ease-in-out;\n}\n/* delay leave of parent element */\n.nested-leave-active {\n  transition-delay: 0.25s;\n}\n\n.nested-enter-from,\n.nested-leave-to {\n  transform: translateY(30px);\n  opacity: 0;\n}\n\n/* we can also transition nested elements using nested selectors */\n.nested-enter-active .transition-demo-inner,\n.nested-leave-active .transition-demo-inner {\n  transition: all 0.3s ease-in-out;\n}\n/* delay enter of nested element */\n.nested-enter-active .transition-demo-inner {\n  transition-delay: 0.25s;\n}\n\n.nested-enter-from .transition-demo-inner,\n.nested-leave-to .transition-demo-inner {\n  transform: translateX(30px);\n  /*\n  \tHack around a Chrome 96 bug in handling nested opacity transitions.\n    This is not needed in other browsers or Chrome 99+ where the bug\n    has been fixed.\n  */\n  opacity: 0.001;\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/built-ins/transition-demos/SlideFade.vue\n================================================\n<script setup>\nimport { ref } from 'vue'\nconst show = ref(true)\n</script>\n\n<template>\n  <div class=\"demo\">\n    <button @click=\"show = !show\">Toggle Slide + Fade</button>\n    <Transition name=\"slide-fade\">\n      <p style=\"margin-top: 20px\" v-if=\"show\">hello</p>\n    </Transition>\n  </div>\n</template>\n\n<style>\n.slide-fade-enter-active {\n  transition: all 0.3s ease-out;\n}\n\n.slide-fade-leave-active {\n  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);\n}\n\n.slide-fade-enter-from,\n.slide-fade-leave-to {\n  transform: translateX(20px);\n  opacity: 0;\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/components/async.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/components/attrs.md\n================================================\n---\noutline: deep\n---\n\n# 透传 Attributes {#fallthrough-attributes}\n\n> 此章节假设你已经看过了[组件基础](/guide/essentials/component-basics)。若你还不了解组件是什么，请先阅读该章节。\n\n## Attributes 继承 {#attribute-inheritance}\n\n“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 [props](./props) 或 [emits](./events#defining-custom-events) 的 attribute 或者 `v-on` 事件监听器。最常见的例子就是 `class`、`style` 和 `id`。\n\n当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上。举例来说，假如我们有一个 `<MyButton>` 组件，它的模板长这样：\n\n```vue-html\n<!-- <MyButton> 的模板 -->\n<button>Click Me</button>\n```\n\n一个父组件使用了这个组件，并且传入了 `class`：\n\n```vue-html\n<MyButton class=\"large\" />\n```\n\n最后渲染出的 DOM 结果是：\n\n```html\n<button class=\"large\">Click Me</button>\n```\n\n这里，`<MyButton>` 并没有将 `class` 声明为一个它所接受的 prop，所以 `class` 被视作透传 attribute，自动透传到了 `<MyButton>` 的根元素上。\n\n### 对 `class` 和 `style` 的合并 {#class-and-style-merging}\n\n如果一个子组件的根元素已经有了 `class` 或 `style` attribute，它会和从父组件上继承的值合并。如果我们将之前的 `<MyButton>` 组件的模板改成这样：\n\n```vue-html\n<!-- <MyButton> 的模板 -->\n<button class=\"btn\">Click Me</button>\n```\n\n则最后渲染出的 DOM 结果会变成：\n\n```html\n<button class=\"btn large\">Click Me</button>\n```\n\n### `v-on` 监听器继承 {#v-on-listener-inheritance}\n\n同样的规则也适用于 `v-on` 事件监听器：\n\n```vue-html\n<MyButton @click=\"onClick\" />\n```\n\n`click` 监听器会被添加到 `<MyButton>` 的根元素，即那个原生的 `<button>` 元素之上。当原生的 `<button>` 被点击，会触发父组件的 `onClick` 方法。同样的，如果原生 `button` 元素自身也通过 `v-on` 绑定了一个事件监听器，则这个监听器和从父组件继承的监听器都会被触发。\n\n### 深层组件继承 {#nested-component-inheritance}\n\n有些情况下一个组件会在根节点上渲染另一个组件。例如，我们重构一下 `<MyButton>`，让它在根节点上渲染 `<BaseButton>`：\n\n```vue-html\n<!-- <MyButton/> 的模板，只是渲染另一个组件 -->\n<BaseButton />\n```\n\n此时 `<MyButton>` 接收的透传 attribute 会直接继续传给 `<BaseButton>`。\n\n请注意：\n\n1. 透传的 attribute 不会包含 `<MyButton>` 上声明过的 props 或是针对 `emits` 声明事件的 `v-on` 侦听函数，换句话说，声明过的 props 和侦听函数被 `<MyButton>`“消费”了。\n\n2. 透传的 attribute 若符合声明，也可以作为 props 传入 `<BaseButton>`。\n\n## 禁用 Attributes 继承 {#disabling-attribute-inheritance}\n\n如果你**不想要**一个组件自动地继承 attribute，你可以在组件选项中设置 `inheritAttrs: false`。\n\n<div class=\"composition-api\">\n\n 从 3.3 开始你也可以直接在 `<script setup>` 中使用 [`defineOptions`](/api/sfc-script-setup#defineoptions)：\n\n```vue\n<script setup>\ndefineOptions({\n  inheritAttrs: false\n})\n// ...setup 逻辑\n</script>\n```\n\n</div>\n\n最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 `inheritAttrs` 选项为 `false`，你可以完全控制透传进来的 attribute 被如何使用。\n\n这些透传进来的 attribute 可以在模板的表达式中直接用 `$attrs` 访问到。\n\n```vue-html\n<span>Fallthrough attribute: {{ $attrs }}</span>\n```\n\n这个 `$attrs` 对象包含了除组件所声明的 `props` 和 `emits` 之外的所有其他 attribute，例如 `class`，`style`，`v-on` 监听器等等。\n\n有几点需要注意：\n\n- 和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 `foo-bar` 这样的一个 attribute 需要通过 `$attrs['foo-bar']` 来访问。\n\n- 像 `@click` 这样的一个 `v-on` 事件监听器将在此对象下被暴露为一个函数 `$attrs.onClick`。\n\n现在我们要再次使用一下[之前小节](#attribute-inheritance)中的 `<MyButton>` 组件例子。有时候我们可能为了样式，需要在 `<button>` 元素外包装一层 `<div>`：\n\n```vue-html\n<div class=\"btn-wrapper\">\n  <button class=\"btn\">Click Me</button>\n</div>\n```\n\n我们想要所有像 `class` 和 `v-on` 监听器这样的透传 attribute 都应用在内部的 `<button>` 上而不是外层的 `<div>` 上。我们可以通过设定 `inheritAttrs: false` 和使用 `v-bind=\"$attrs\"` 来实现：\n\n```vue-html{2}\n<div class=\"btn-wrapper\">\n  <button class=\"btn\" v-bind=\"$attrs\">Click Me</button>\n</div>\n```\n\n小提示：[没有参数的 `v-bind`](/guide/essentials/template-syntax#dynamically-binding-multiple-attributes) 会将一个对象的所有属性都作为 attribute 应用到目标元素上。\n\n## 多根节点的 Attributes 继承 {#attribute-inheritance-on-multiple-root-nodes}\n\n和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 `$attrs` 没有被显式绑定，将会抛出一个运行时警告。\n\n```vue-html\n<CustomLayout id=\"custom-layout\" @click=\"changeValue\" />\n```\n\n如果 `<CustomLayout>` 有下面这样的多根节点模板，由于 Vue 不知道要将 attribute 透传到哪里，所以会抛出一个警告。\n\n```vue-html\n<header>...</header>\n<main>...</main>\n<footer>...</footer>\n```\n\n如果 `$attrs` 被显式绑定，则不会有警告：\n\n```vue-html{2}\n<header>...</header>\n<main v-bind=\"$attrs\">...</main>\n<footer>...</footer>\n```\n\n## 在 JavaScript 中访问透传 Attributes {#accessing-fallthrough-attributes-in-javascript}\n\n<div class=\"composition-api\">\n\n如果需要，你可以在 `<script setup>` 中使用 `useAttrs()` API 来访问一个组件的所有透传 attribute：\n\n```vue\n<script setup>\nimport { useAttrs } from 'vue'\n\nconst attrs = useAttrs()\n</script>\n```\n\n如果没有使用 `<script setup>`，`attrs` 会作为 `setup()` 上下文对象的一个属性暴露：\n\n```js\nexport default {\n  setup(props, ctx) {\n    // 透传 attribute 被暴露为 ctx.attrs\n    console.log(ctx.attrs)\n  }\n}\n```\n\n需要注意的是，虽然这里的 `attrs` 对象总是反映为最新的透传 attribute，但它并不是响应式的 (考虑到性能因素)。你不能通过侦听器去监听它的变化。如果你需要响应性，可以使用 prop。或者你也可以使用 `onUpdated()` 使得在每次更新时结合最新的 `attrs` 执行副作用。\n\n</div>\n\n<div class=\"options-api\">\n\n如果需要，你可以通过 `$attrs` 这个实例属性来访问组件的所有透传 attribute：\n\n```js\nexport default {\n  created() {\n    console.log(this.$attrs)\n  }\n}\n```\n\n</div>\n\n\n\n================================================\nFILE: src/guide/components/events.md\n================================================\n<script setup>\nimport { onMounted } from 'vue'\n\nif (typeof window !== 'undefined') {\n  const hash = window.location.hash\n\n  // The docs for v-model used to be part of this page. Attempt to redirect outdated links.\n  if ([\n    '#usage-with-v-model',\n    '#v-model-arguments',\n    '#multiple-v-model-bindings',\n    '#handling-v-model-modifiers'\n  ].includes(hash)) {\n    onMounted(() => {\n      window.location = './v-model.html' + hash\n    })\n  }\n}\n</script>\n\n# 组件事件 {#component-events}\n\n> 此章节假设你已经看过了[组件基础](/guide/essentials/component-basics)。若你还不了解组件是什么，请先阅读该章节。\n\n## 触发与监听事件 {#emitting-and-listening-to-events}\n\n在组件的模板表达式中，可以直接使用 `$emit` 方法触发自定义事件 (例如：在 `v-on` 的处理函数中)：\n\n```vue-html\n<!-- MyComponent -->\n<button @click=\"$emit('someEvent')\">Click Me</button>\n```\n\n<div class=\"options-api\">\n\n`$emit()` 方法在组件实例上也同样以 `this.$emit()` 的形式可用：\n\n```js\nexport default {\n  methods: {\n    submit() {\n      this.$emit('someEvent')\n    }\n  }\n}\n```\n\n</div>\n\n父组件可以通过 `v-on` (缩写为 `@`) 来监听事件：\n\n```vue-html\n<MyComponent @some-event=\"callback\" />\n```\n\n同样，组件的事件监听器也支持 `.once` 修饰符：\n\n```vue-html\n<MyComponent @some-event.once=\"callback\" />\n```\n\n像组件与 prop 一样，事件的名字也提供了自动的格式转换。注意这里我们触发了一个以 camelCase 形式命名的事件，但在父组件中可以使用 kebab-case 形式来监听。与 [prop 大小写格式](/guide/components/props#prop-name-casing)一样，在模板中我们也推荐使用 kebab-case 形式来编写监听器。\n\n:::tip\n和原生 DOM 事件不一样，组件触发的事件**没有冒泡机制**。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的事件总线，或是使用一个[全局状态管理方案](/guide/scaling-up/state-management)。\n:::\n\n## 事件参数 {#event-arguments}\n\n有时候我们会需要在触发事件时附带一个特定的值。举例来说，我们想要 `<BlogPost>` 组件来管理文本会缩放得多大。在这个场景下，我们可以给 `$emit` 提供一个额外的参数：\n\n```vue-html\n<button @click=\"$emit('increaseBy', 1)\">\n  Increase by 1\n</button>\n```\n\n然后我们在父组件中监听事件，我们可以先简单写一个内联的箭头函数作为监听器，此函数会接收到事件附带的参数：\n\n```vue-html\n<MyButton @increase-by=\"(n) => count += n\" />\n```\n\n或者，也可以用一个组件方法来作为事件处理函数：\n\n```vue-html\n<MyButton @increase-by=\"increaseCount\" />\n```\n\n该方法也会接收到事件所传递的参数：\n\n<div class=\"options-api\">\n\n```js\nmethods: {\n  increaseCount(n) {\n    this.count += n\n  }\n}\n```\n\n</div>\n<div class=\"composition-api\">\n\n```js\nfunction increaseCount(n) {\n  count.value += n\n}\n```\n\n</div>\n\n:::tip\n所有传入 `$emit()` 的额外参数都会被直接传向监听器。举例来说，`$emit('foo', 1, 2, 3)` 触发后，监听器函数将会收到这三个参数值。\n:::\n\n## 声明触发的事件 {#declaring-emitted-events}\n\n组件可以显式地通过 <span class=\"composition-api\">[`defineEmits()`](/api/sfc-script-setup#defineprops-defineemits) 宏</span><span class=\"options-api\">[`emits`](/api/options-state#emits) 选项</span>来声明它要触发的事件：\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\ndefineEmits(['inFocus', 'submit'])\n</script>\n```\n\n我们在 `<template>` 中使用的 `$emit` 方法不能在组件的 `<script setup>` 部分中使用，但 `defineEmits()` 会返回一个相同作用的函数供我们使用：\n\n```vue\n<script setup>\nconst emit = defineEmits(['inFocus', 'submit'])\n\nfunction buttonClick() {\n  emit('submit')\n}\n</script>\n```\n\n`defineEmits()` 宏**不能**在子函数中使用。如上所示，它必须直接放置在 `<script setup>` 的顶级作用域下。\n\n如果你显式地使用了 `setup` 函数而不是 `<script setup>`，则事件需要通过 [`emits`](/api/options-state#emits) 选项来定义，`emit` 函数也被暴露在 `setup()` 的上下文对象上：\n\n```js\nexport default {\n  emits: ['inFocus', 'submit'],\n  setup(props, ctx) {\n    ctx.emit('submit')\n  }\n}\n```\n\n与 `setup()` 上下文对象中的其他属性一样，`emit` 可以安全地被解构：\n\n```js\nexport default {\n  emits: ['inFocus', 'submit'],\n  setup(props, { emit }) {\n    emit('submit')\n  }\n}\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  emits: ['inFocus', 'submit']\n}\n```\n\n</div>\n\n这个 `emits` 选项和 `defineEmits()` 宏还支持对象语法。通过 TypeScript 为参数指定类型，它允许我们对触发事件的参数进行验证：\n\n<div class=\"composition-api\">\n\n```vue\n<script setup lang=\"ts\">\nconst emit = defineEmits({\n  submit(payload: { email: string, password: string }) {\n    // 通过返回值为 `true` 还是为 `false` 来判断\n    // 验证是否通过\n  }\n})\n</script>\n```\n\n如果你正在搭配 TypeScript 使用 `<script setup>`，也可以使用纯类型标注来声明触发的事件：\n\n```vue\n<script setup lang=\"ts\">\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n</script>\n```\n\nTypeScript 用户请参考：[如何为组件所抛出事件标注类型](/guide/typescript/composition-api#typing-component-emits) <sup class=\"vt-badge ts\" />\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  emits: {\n    submit(payload: { email: string, password: string }) {\n      // 通过返回值为 `true` 还是为 `false` 来判断\n      // 验证是否通过\n    }\n  }\n}\n```\n\nTypeScript 用户请参考：[如何为组件所抛出的事件标注类型](/guide/typescript/options-api#typing-component-emits)。<sup class=\"vt-badge ts\" />\n\n</div>\n\n尽管事件声明是可选的，我们还是推荐你完整地声明所有要触发的事件，以此在代码中作为文档记录组件的用法。同时，事件声明能让 Vue 更好地将事件和[透传 attribute](/guide/components/attrs#v-on-listener-inheritance) 作出区分，从而避免一些由第三方代码触发的自定义 DOM 事件所导致的边界情况。\n\n:::tip\n如果一个原生事件的名字 (例如 `click`) 被定义在 `emits` 选项中，则监听器只会监听组件触发的 `click` 事件而不会再响应原生的 `click` 事件。\n:::\n\n## 事件校验 {#events-validation}\n\n和对 props 添加类型校验的方式类似，所有触发的事件也可以使用对象形式来描述。\n\n要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 <span class=\"options-api\">`this.$emit`</span><span class=\"composition-api\">`emit`</span> 的内容，返回一个布尔值来表明事件是否合法。\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nconst emit = defineEmits({\n  // 没有校验\n  click: null,\n\n  // 校验 submit 事件\n  submit: ({ email, password }) => {\n    if (email && password) {\n      return true\n    } else {\n      console.warn('Invalid submit event payload!')\n      return false\n    }\n  }\n})\n\nfunction submitForm(email, password) {\n  emit('submit', { email, password })\n}\n</script>\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  emits: {\n    // 没有校验\n    click: null,\n\n    // 校验 submit 事件\n    submit: ({ email, password }) => {\n      if (email && password) {\n        return true\n      } else {\n        console.warn('Invalid submit event payload!')\n        return false\n      }\n    }\n  },\n  methods: {\n    submitForm(email, password) {\n      this.$emit('submit', { email, password })\n    }\n  }\n}\n```\n\n</div>\n\n\n\n================================================\nFILE: src/guide/components/props.md\n================================================\n# Props {#props}\n\n> 此章节假设你已经看过了[组件基础](/guide/essentials/component-basics)。若你还不了解组件是什么，请先阅读该章节。\n\n<!--<div class=\"options-api\">\n  <VueSchoolLink href=\"https://vueschool.io/lessons/vue-3-reusable-components-with-props\" title=\"Free Vue.js Props Lesson\"/>\n</div>-->\n\n## Props 声明 {#props-declaration}\n\n一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute (关于透传 attribute，我们会在[专门的章节](/guide/components/attrs)中讨论)。\n\n<div class=\"composition-api\">\n\n在使用 `<script setup>` 的单文件组件中，props 可以使用 `defineProps()` 宏来声明：\n\n```vue\n<script setup>\nconst props = defineProps(['foo'])\n\nconsole.log(props.foo)\n</script>\n```\n\n在没有使用 `<script setup>` 的组件中，props 可以使用 [`props`](/api/options-state#props) 选项来声明：\n\n```js\nexport default {\n  props: ['foo'],\n  setup(props) {\n    // setup() 接收 props 作为第一个参数\n    console.log(props.foo)\n  }\n}\n```\n\n注意传递给 `defineProps()` 的参数和提供给 `props` 选项的值是相同的，两种声明方式背后其实使用的都是 props 选项。\n\n</div>\n\n<div class=\"options-api\">\n\nprops 需要使用 [`props`](/api/options-state#props) 选项来定义：\n\n```js\nexport default {\n  props: ['foo'],\n  created() {\n    // props 会暴露到 `this` 上\n    console.log(this.foo)\n  }\n}\n```\n\n</div>\n\n除了使用字符串数组来声明 props 外，还可以使用对象的形式：\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}\n```\n\n</div>\n<div class=\"composition-api\">\n\n```js\n// 使用 <script setup>\ndefineProps({\n  title: String,\n  likes: Number\n})\n```\n\n```js\n// 非 <script setup>\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}\n```\n\n</div>\n\n对于以对象形式声明的每个属性，key 是 prop 的名称，而值则是该 prop 预期类型的构造函数。比如，如果要求一个 prop 的值是 `number` 类型，则可使用 `Number` 构造函数作为其声明的值。\n\n对象形式的 props 声明不仅可以一定程度上作为组件的文档，而且如果其他开发者在使用你的组件时传递了错误的类型，也会在浏览器控制台中抛出警告。我们将在本章节稍后进一步讨论有关 [prop 校验](#prop-validation)的更多细节。\n\n<div class=\"options-api\">\n\nTypeScript 用户请参考：[为组件 Props 标注类型](/guide/typescript/options-api#typing-component-props) <sup class=\"vt-badge ts\" />\n\n</div>\n\n<div class=\"composition-api\">\n\n如果你正在搭配 TypeScript 使用 `<script setup>`，也可以使用类型标注来声明 props：\n\n```vue\n<script setup lang=\"ts\">\ndefineProps<{\n  title?: string\n  likes?: number\n}>()\n</script>\n```\n\n更多关于基于类型的声明的细节请参考[组件 props 类型标注](/guide/typescript/composition-api#typing-component-props)。<sup class=\"vt-badge ts\" />\n\n</div>\n\n<div class=\"composition-api\">\n\n## 响应式 Props 解构 <sup class=\"vt-badge\" data-text=\"3.5+\" /> \\*\\* {#reactive-props-destructure}\n\nVue 的响应系统基于属性访问跟踪状态的使用情况。例如，在计算属性或侦听器中访问 `props.foo` 时，`foo` 属性将被跟踪为依赖项。\n\n因此，在以下代码的情况下：\n\n```js\nconst { foo } = defineProps(['foo'])\n\nwatchEffect(() => {\n  // 在 3.5 之前只运行一次\n  // 在 3.5+ 中在 \"foo\" prop 变化时重新执行\n  console.log(foo)\n})\n```\n\n在 3.4 及以下版本，`foo` 是一个实际的常量，永远不会改变。在 3.5 及以上版本，当在同一个 `<script setup>` 代码块中访问由 `defineProps` 解构的变量时，Vue 编译器会自动在前面添加 `props.`。因此，上面的代码等同于以下代码：\n\n```js {5}\nconst props = defineProps(['foo'])\n\nwatchEffect(() => {\n  // `foo` 由编译器转换为 `props.foo`\n  console.log(props.foo)\n})\n```\n\n此外，你可以使用 JavaScript 原生的默认值语法声明 props 默认值。这在使用基于类型的 props 声明时特别有用。\n\n```ts\nconst { foo = 'hello' } = defineProps<{ foo?: string }>()\n```\n\n如果你希望在 IDE 中在解构的 props 和普通变量之间有更多视觉上的区分，Vue 的 VSCode 扩展提供了一个设置来启用解构 props 的内联提示。\n\n### 将解构的 props 传递到函数中 {#passing-destructured-props-into-functions}\n\n当我们将解构的 prop 传递到函数中时，例如：\n\n```js\nconst { foo } = defineProps(['foo'])\n\nwatch(foo, /* ... */)\n```\n\n这并不会按预期工作，因为它等价于 `watch(props.foo, ...)`——我们给 `watch` 传递的是一个值而不是响应式数据源。实际上，Vue 的编译器会捕捉这种情况并发出警告。\n\n与使用 `watch(() => props.foo, ...)` 来侦听普通 prop 类似，我们也可以通过将其包装在 getter 中来侦听解构的 prop：\n\n```js\nwatch(() => foo, /* ... */)\n```\n\n此外，当我们需要传递解构的 prop 到外部函数中并保持响应性时，这是推荐做法：\n\n```js\nuseComposable(() => foo)\n```\n\n外部函数可以调用 getter (或使用 [toValue](/api/reactivity-utilities.html#tovalue) 进行规范化) 来追踪提供的 prop 变更。例如，在计算属性或侦听器的 getter 中。\n\n</div>\n\n## 传递 prop 的细节 {#prop-passing-details}\n\n### Prop 名字格式 {#prop-name-casing}\n\n如果一个 prop 的名字很长，应使用 camelCase 形式，因为它们是合法的 JavaScript 标识符，可以直接在模板的表达式中使用，也可以避免在作为属性 key 名时必须加上引号。\n\n<div class=\"composition-api\">\n\n```js\ndefineProps({\n  greetingMessage: String\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    greetingMessage: String\n  }\n}\n```\n\n</div>\n\n```vue-html\n<span>{{ greetingMessage }}</span>\n```\n\n虽然理论上你也可以在向子组件传递 props 时使用 camelCase 形式 (使用 [DOM 内模板](/guide/essentials/component-basics#in-dom-template-parsing-caveats)时例外)，但实际上为了和 HTML attribute 对齐，我们通常会将其写为 kebab-case 形式：\n\n```vue-html\n<MyComponent greeting-message=\"hello\" />\n```\n\n对于组件名我们推荐使用 [PascalCase](/guide/components/registration#component-name-casing)，因为这提高了模板的可读性，能帮助我们区分 Vue 组件和原生 HTML 元素。然而对于传递 props 来说，使用 camelCase 并没有太多优势，因此我们推荐更贴近 HTML 的书写风格。\n\n### 静态 vs. 动态 Props {#static-vs-dynamic-props}\n\n至此，你已经见过了很多像这样的静态值形式的 props：\n\n```vue-html\n<BlogPost title=\"My journey with Vue\" />\n```\n\n相应地，还有使用 `v-bind` 或缩写 `:` 来进行动态绑定的 props：\n\n```vue-html\n<!-- 根据一个变量的值动态传入 -->\n<BlogPost :title=\"post.title\" />\n\n<!-- 根据一个更复杂表达式的值动态传入 -->\n<BlogPost :title=\"post.title + ' by ' + post.author.name\" />\n```\n\n### 传递不同的值类型 {#passing-different-value-types}\n\n在上述的两个例子中，我们只传入了字符串值，但实际上**任何**类型的值都可以作为 props 的值被传递。\n\n#### Number {#number}\n\n```vue-html\n<!-- 虽然 `42` 是个常量，我们还是需要使用 v-bind -->\n<!-- 因为这是一个 JavaScript 表达式而不是一个字符串 -->\n<BlogPost :likes=\"42\" />\n\n<!-- 根据一个变量的值动态传入 -->\n<BlogPost :likes=\"post.likes\" />\n```\n\n#### Boolean {#boolean}\n\n```vue-html\n<!-- 仅写上 prop 但不传值，会隐式转换为 `true` -->\n<BlogPost is-published />\n\n<!-- 虽然 `false` 是静态的值，我们还是需要使用 v-bind -->\n<!-- 因为这是一个 JavaScript 表达式而不是一个字符串 -->\n<BlogPost :is-published=\"false\" />\n\n<!-- 根据一个变量的值动态传入 -->\n<BlogPost :is-published=\"post.isPublished\" />\n```\n\n#### Array {#array}\n\n```vue-html\n<!-- 虽然这个数组是个常量，我们还是需要使用 v-bind -->\n<!-- 因为这是一个 JavaScript 表达式而不是一个字符串 -->\n<BlogPost :comment-ids=\"[234, 266, 273]\" />\n\n<!-- 根据一个变量的值动态传入 -->\n<BlogPost :comment-ids=\"post.commentIds\" />\n```\n\n#### Object {#object}\n\n```vue-html\n<!-- 虽然这个对象字面量是个常量，我们还是需要使用 v-bind -->\n<!-- 因为这是一个 JavaScript 表达式而不是一个字符串 -->\n<BlogPost\n  :author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n />\n\n<!-- 根据一个变量的值动态传入 -->\n<BlogPost :author=\"post.author\" />\n```\n\n### 使用一个对象绑定多个 prop {#binding-multiple-properties-using-an-object}\n\n如果你想要将一个对象的所有属性都当作 props 传入，你可以使用[没有参数的 `v-bind`](/guide/essentials/template-syntax#dynamically-binding-multiple-attributes)，即只使用 `v-bind` 而非 `:prop-name`。例如，这里有一个 `post` 对象：\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  data() {\n    return {\n      post: {\n        id: 1,\n        title: 'My Journey with Vue'\n      }\n    }\n  }\n}\n```\n\n</div>\n<div class=\"composition-api\">\n\n```js\nconst post = {\n  id: 1,\n  title: 'My Journey with Vue'\n}\n```\n\n</div>\n\n以及下面的模板：\n\n```vue-html\n<BlogPost v-bind=\"post\" />\n```\n\n而这实际上等价于：\n\n```vue-html\n<BlogPost :id=\"post.id\" :title=\"post.title\" />\n```\n\n## 单向数据流 {#one-way-data-flow}\n\n所有的 props 都遵循着**单向绑定**原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。\n\n另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你**不应该**在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告：\n\n<div class=\"composition-api\">\n\n```js\nconst props = defineProps(['foo'])\n\n// ❌ 警告！prop 是只读的！\nprops.foo = 'bar'\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: ['foo'],\n  created() {\n    // ❌ 警告！prop 是只读的！\n    this.foo = 'bar'\n  }\n}\n```\n\n</div>\n\n导致你想要更改一个 prop 的需求通常来源于以下两种场景：\n\n1. **prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性**。在这种情况下，最好是新定义一个局部数据属性，从 props 上获取初始值即可：\n\n   <div class=\"composition-api\">\n\n   ```js\n   const props = defineProps(['initialCounter'])\n\n   // 计数器只是将 props.initialCounter 作为初始值\n   // 像下面这样做就使 prop 和后续更新无关了\n   const counter = ref(props.initialCounter)\n   ```\n\n   </div>\n   <div class=\"options-api\">\n\n   ```js\n   export default {\n     props: ['initialCounter'],\n     data() {\n       return {\n         // 计数器只是将 this.initialCounter 作为初始值\n         // 像下面这样做就使 prop 和后续更新无关了\n         counter: this.initialCounter\n       }\n     }\n   }\n   ```\n\n   </div>\n\n2. **需要对传入的 prop 值做进一步的转换**。在这种情况中，最好是基于该 prop 值定义一个计算属性：\n\n   <div class=\"composition-api\">\n\n   ```js\n   const props = defineProps(['size'])\n\n   // 该 prop 变更时计算属性也会自动更新\n   const normalizedSize = computed(() => props.size.trim().toLowerCase())\n   ```\n\n   </div>\n   <div class=\"options-api\">\n\n   ```js\n   export default {\n     props: ['size'],\n     computed: {\n       // 该 prop 变更时计算属性也会自动更新\n       normalizedSize() {\n         return this.size.trim().toLowerCase()\n       }\n     }\n   }\n   ```\n\n   </div>\n\n### 更改对象 / 数组类型的 props {#mutating-object-array-props}\n\n当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然**可以**更改对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，对 Vue 来说，阻止这种更改需要付出的代价异常昂贵。\n\n这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。在大多数场景下，子组件应该[抛出一个事件](/guide/components/events)来通知父组件做出改变。\n\n## Prop 校验 {#prop-validation}\n\nVue 组件可以更细致地声明对传入的 props 的校验要求。比如我们上面已经看到过的类型声明，如果传入的值不满足类型要求，Vue 会在浏览器控制台中抛出警告来提醒使用者。这在开发给其他开发者使用的组件时非常有用。\n\n要声明对 props 的校验，你可以向 <span class=\"composition-api\">`defineProps()` 宏</span><span class=\"options-api\">`props` 选项</span>提供一个带有 props 校验选项的对象，例如：\n\n<div class=\"composition-api\">\n\n```js\ndefineProps({\n  // 基础类型检查\n  // (给出 `null` 和 `undefined` 值则会跳过任何类型检查)\n  propA: Number,\n  // 多种可能的类型\n  propB: [String, Number],\n  // 必传，且为 String 类型\n  propC: {\n    type: String,\n    required: true\n  },\n  // 必传但可为 null 的字符串\n  propD: {\n    type: [String, null],\n    required: true\n  },\n  // Number 类型的默认值\n  propE: {\n    type: Number,\n    default: 100\n  },\n  // 对象类型的默认值\n  propF: {\n    type: Object,\n    // 对象或数组的默认值\n    // 必须从一个工厂函数返回。\n    // 该函数接收组件所接收到的原始 prop 作为参数。\n    default(rawProps) {\n      return { message: 'hello' }\n    }\n  },\n  // 自定义类型校验函数\n  // 在 3.4+ 中完整的 props 作为第二个参数传入\n  propG: {\n    validator(value, props) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // 函数类型的默认值\n  propH: {\n    type: Function,\n    // 不像对象或数组的默认，这不是一个\n    // 工厂函数。这会是一个用来作为默认值的函数\n    default() {\n      return 'Default function'\n    }\n  }\n})\n```\n\n:::tip\n`defineProps()` 宏中的参数**不可以访问 `<script setup>` 中定义的其他变量**，因为在编译时整个表达式都会被移到外部的函数中。\n:::\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    // 基础类型检查\n    // (给出 `null` 和 `undefined` 值则会跳过任何类型检查)\n    propA: Number,\n    // 多种可能的类型\n    propB: [String, Number],\n    // 必传，且为 String 类型\n    propC: {\n      type: String,\n      required: true\n    },\n    // 必传但可为 null 的字符串\n    propD: {\n      type: [String, null],\n      required: true\n    },\n    // Number 类型的默认值\n    propE: {\n      type: Number,\n      default: 100\n    },\n    // 对象类型的默认值\n    propF: {\n      type: Object,\n      // 对象或者数组应当用工厂函数返回。\n      // 工厂函数会收到组件所接收的原始 props\n      // 作为参数\n      default(rawProps) {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义类型校验函数\n    // 在 3.4+ 中完整的 props 作为第二个参数传入\n    propG: {\n      validator(value, props) {\n        // The value must match one of these strings\n        return ['success', 'warning', 'danger'].includes(value)\n      }\n    },\n    // 函数类型的默认值\n    propH: {\n      type: Function,\n      // 不像对象或数组的默认，这不是一个\n      // 工厂函数。这会是一个用来作为默认值的函数\n      default() {\n        return 'Default function'\n      }\n    }\n  }\n}\n```\n\n</div>\n\n一些补充细节：\n\n- 所有 prop 默认都是可选的，除非声明了 `required: true`。\n\n- 除 `Boolean` 外的未传递的可选 prop 将会有一个默认值 `undefined`。\n\n- `Boolean` 类型的未传递 prop 将被转换为 `false`。这可以通过为它设置 `default` 来更改——例如：设置为 `default: undefined` 将与非布尔类型的 prop 的行为保持一致。\n\n- 如果声明了 `default` 值，那么在 prop 的值被解析为 `undefined` 时，无论 prop 是未被传递还是显式指明的 `undefined`，都会改为 `default` 值。\n\n当 prop 的校验失败后，Vue 会抛出一个控制台警告 (在开发模式下)。\n\n<div class=\"composition-api\">\n\n如果使用了[基于类型的 prop 声明](/api/sfc-script-setup#type-only-props-emit-declarations) <sup class=\"vt-badge ts\" />，Vue 会尽最大努力在运行时按照 prop 的类型标注进行编译。举例来说，`defineProps<{ msg: string }>` 会被编译为 `{ msg: { type: String, required: true }}`。\n\n</div>\n<div class=\"options-api\">\n\n::: tip 注意\n注意 prop 的校验是在组件实例被创建**之前**，所以实例的属性 (比如 `data`、`computed` 等) 将在 `default` 或 `validator` 函数中不可用。\n:::\n\n</div>\n\n### 运行时类型检查 {#runtime-type-checks}\n\n校验选项中的 `type` 可以是下列这些原生构造函数：\n\n- `String`\n- `Number`\n- `Boolean`\n- `Array`\n- `Object`\n- `Date`\n- `Function`\n- `Symbol`\n- `Error`\n\n另外，`type` 也可以是自定义的类或构造函数，Vue 将会通过 `instanceof` 来检查类型是否匹配。例如下面这个类：\n\n```js\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n  }\n}\n```\n\n你可以将其作为一个 prop 的类型：\n\n<div class=\"composition-api\">\n\n```js\ndefineProps({\n  author: Person\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    author: Person\n  }\n}\n```\n\n</div>\n\nVue 会通过 `instanceof Person` 来校验 `author` prop 的值是否是 `Person` 类的一个实例。\n\n### 可为 null 的类型 {#nullable-type}\n\n如果该类型是必传但可为 null 的，你可以用一个包含 `null` 的数组语法：\n\n<div class=\"composition-api\">\n\n```js\ndefineProps({\n  id: {\n    type: [String, null],\n    required: true\n  }\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    id: {\n      type: [String, null],\n      required: true\n    }\n  }\n}\n```\n\n</div>\n\n注意如果 `type` 仅为 `null` 而非使用数组语法，它将允许任何类型。\n\n## Boolean 类型转换 {#boolean-casting}\n\n为了更贴近原生 boolean attributes 的行为，声明为 `Boolean` 类型的 props 有特别的类型转换规则。以带有如下声明的 `<MyComponent>` 组件为例：\n\n<div class=\"composition-api\">\n\n```js\ndefineProps({\n  disabled: Boolean\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  props: {\n    disabled: Boolean\n  }\n}\n```\n\n</div>\n\n该组件可以被这样使用：\n\n```vue-html\n<!-- 等同于传入 :disabled=\"true\" -->\n<MyComponent disabled />\n\n<!-- 等同于传入 :disabled=\"false\" -->\n<MyComponent />\n```\n\n当一个 prop 被声明为允许多种类型时，`Boolean` 的转换规则也将被应用。然而，当同时允许 `String` 和 `Boolean` 时，有一种边缘情况——只有当 `Boolean` 出现在 `String` 之前时，`Boolean` 转换规则才适用：\n\n<div class=\"composition-api\">\n\n```js\n// disabled 将被转换为 true\ndefineProps({\n  disabled: [Boolean, Number]\n})\n\n// disabled 将被转换为 true\ndefineProps({\n  disabled: [Boolean, String]\n})\n\n// disabled 将被转换为 true\ndefineProps({\n  disabled: [Number, Boolean]\n})\n\n// disabled 将被解析为空字符串 (disabled=\"\")\ndefineProps({\n  disabled: [String, Boolean]\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\n// disabled 将被转换为 true\nexport default {\n  props: {\n    disabled: [Boolean, Number]\n  }\n}\n\n// disabled 将被转换为 true\nexport default {\n  props: {\n    disabled: [Boolean, String]\n  }\n}\n\n// disabled 将被转换为 true\nexport default {\n  props: {\n    disabled: [Number, Boolean]\n  }\n}\n\n// disabled 将被解析为空字符串 (disabled=\"\")\nexport default {\n  props: {\n    disabled: [String, Boolean]\n  }\n}\n```\n\n</div>\n\n\n\n================================================\nFILE: src/guide/components/provide-inject.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/components/registration.md\n================================================\n# 组件注册 {#component-registration}\n\n> 此章节假设你已经看过了[组件基础](/guide/essentials/component-basics)。若你还不了解组件是什么，请先阅读该章节。\n\n<VueSchoolLink href=\"https://vueschool.io/lessons/vue-3-global-vs-local-vue-components\" title=\"免费的 Vue.js 组件注册课程\"/>\n\n一个 Vue 组件在使用前需要先被“注册”，这样 Vue 才能在渲染模板时找到其对应的实现。组件注册有两种方式：全局注册和局部注册。\n\n## 全局注册 {#global-registration}\n\n我们可以使用 [Vue 应用实例](/guide/essentials/application)的 `.component()` 方法，让组件在当前 Vue 应用中全局可用。\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n\napp.component(\n  // 注册的名字\n  'MyComponent',\n  // 组件的实现\n  {\n    /* ... */\n  }\n)\n```\n\n如果使用单文件组件，你可以注册被导入的 `.vue` 文件：\n\n```js\nimport MyComponent from './App.vue'\n\napp.component('MyComponent', MyComponent)\n```\n\n`.component()` 方法可以被链式调用：\n\n```js\napp\n  .component('ComponentA', ComponentA)\n  .component('ComponentB', ComponentB)\n  .component('ComponentC', ComponentC)\n```\n\n全局注册的组件可以在此应用的任意组件的模板中使用：\n\n```vue-html\n<!-- 这在当前应用的任意组件中都可用 -->\n<ComponentA/>\n<ComponentB/>\n<ComponentC/>\n```\n\n所有的子组件也可以使用全局注册的组件，这意味着这三个组件也都可以在*彼此内部*使用。\n\n## 局部注册 {#local-registration}\n\n全局注册虽然很方便，但有以下几个问题：\n\n1. 全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。\n\n2. 全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。\n\n相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。\n\n<div class=\"composition-api\">\n\n在使用 `<script setup>` 的单文件组件中，导入的组件可以直接在模板中使用，无需注册：\n\n```vue\n<script setup>\nimport ComponentA from './ComponentA.vue'\n</script>\n\n<template>\n  <ComponentA />\n</template>\n```\n\n如果没有使用 `<script setup>`，则需要使用 `components` 选项来显式注册：\n\n```js\nimport ComponentA from './ComponentA.js'\n\nexport default {\n  components: {\n    ComponentA\n  },\n  setup() {\n    // ...\n  }\n}\n```\n\n</div>\n<div class=\"options-api\">\n\n局部注册需要使用 `components` 选项：\n\n```vue\n<script>\nimport ComponentA from './ComponentA.vue'\n\nexport default {\n  components: {\n    ComponentA\n  }\n}\n</script>\n\n<template>\n  <ComponentA />\n</template>\n```\n\n</div>\n\n对于每个 `components` 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于：\n\n```js\nexport default {\n  components: {\n    ComponentA: ComponentA\n  }\n  // ...\n}\n```\n\n请注意：**局部注册的组件在后代组件中<i>不</i>可用**。在这个例子中，`ComponentA` 注册后仅在当前组件可用，而在任何的子组件或更深层的子组件中都不可用。\n\n## 组件名格式 {#component-name-casing}\n\n在整个指引中，我们都使用 PascalCase 作为组件名的注册格式，这是因为：\n\n1. PascalCase 是合法的 JavaScript 标识符。这使得在 JavaScript 中导入和注册组件都很容易，同时 IDE 也能提供较好的自动补全。\n\n2. `<PascalCase />` 在模板中更明显地表明了这是一个 Vue 组件，而不是原生 HTML 元素。同时也能够将 Vue 组件和自定义元素 (web components) 区分开来。\n\n在单文件组件和内联字符串模板中，我们都推荐这样做。但是，PascalCase 的标签名在 DOM 内模板中是不可用的，详情参见 [DOM 内模板解析注意事项](/guide/essentials/component-basics#in-dom-template-parsing-caveats)。\n\n为了方便，Vue 支持将模板中使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 `MyComponent` 为名注册的组件，在模板 (或由 Vue 渲染的 HTML 元素) 中可以通过 `<MyComponent>` 或 `<my-component>` 引用。这让我们能够使用同样的 JavaScript 组件注册代码来配合不同来源的模板。\n\n\n\n================================================\nFILE: src/guide/components/slots.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/components/v-model.md\n================================================\n# 组件 v-model {#component-v-model}\n\n<ScrimbaLink href=\"https://scrimba.com/links/vue-component-v-model\" title=\"Free Vue.js Component v-model Lesson\" type=\"scrimba\">\n  观看 Scrimba 的互动视频课程\n</ScrimbaLink>\n\n## 基本用法 {#basic-usage}\n\n`v-model` 可以在组件上使用以实现双向绑定。\n\n<div class=\"composition-api\">\n\n从 Vue 3.4 开始，推荐的实现方式是使用 [`defineModel()`](/api/sfc-script-setup#definemodel) 宏：\n\n```vue [Child.vue]\n<script setup>\nconst model = defineModel()\n\nfunction update() {\n  model.value++\n}\n</script>\n\n<template>\n  <div>Parent bound v-model is: {{ model }}</div>\n  <button @click=\"update\">Increment</button>\n</template>\n```\n\n父组件可以用 `v-model` 绑定一个值：\n\n```vue-html [Parent.vue]\n<Child v-model=\"countModel\" />\n```\n\n`defineModel()` 返回的值是一个 ref。它可以像其他 ref 一样被访问以及修改，不过它能起到在父组件和当前变量之间的双向绑定的作用：\n\n- 它的 `.value` 和父组件的 `v-model` 的值同步；\n- 当它被子组件变更了，会触发父组件绑定的值一起更新。\n\n这意味着你也可以用 `v-model` 把这个 ref 绑定到一个原生 input 元素上，在提供相同的 `v-model` 用法的同时轻松包装原生 input 元素：\n\n```vue\n<script setup>\nconst model = defineModel()\n</script>\n\n<template>\n  <input v-model=\"model\" />\n</template>\n```\n\n[演练场示例](https://play.vuejs.org/#eNqFUtFKwzAU/ZWYl06YLbK30Q10DFSYigq+5KW0t11mmoQknZPSf/cm3eqEsT0l555zuefmpKV3WsfbBuiUpjY3XDtiwTV6ziSvtTKOLNZcFKQ0qiZRnATkG6JB0BIDJen2kp5iMlfSOlLbisw8P4oeQAhFPpURxVV0zWSa9PNwEgIHtRaZA0SEpOvbeduG5q5LE0Sh2jvZ3tSqADFjFHlGSYJkmhz10zF1FseXvIo3VklcrfX9jOaq1lyAedGOoz1GpyQwnsvQ3fdTqDnTwPhQz9eQf52ob+zO1xh9NWDBbIHRgXOZqcD19PL9GXZ4H0h03whUnyHfwCrReI+97L6RBdo+0gW3j+H9uaw+7HLnQNrDUt6oV3ZBzyhmsjiz+p/dSTwJfUx2+IpD1ic+xz5enwQGXEDJJaw8Gl2I1upMzlc/hEvdOBR6SNKAjqP1J6P/o6XdL11L5h4=)\n\n### 底层机制 {#under-the-hood}\n\n`defineModel` 是一个便利宏。编译器将其展开为以下内容：\n\n- 一个名为 `modelValue` 的 prop，本地 ref 的值与其同步；\n- 一个名为 `update:modelValue` 的事件，当本地 ref 的值发生变更时触发。\n\n在 3.4 版本之前，你一般会按照如下的方式来实现上述相同的子组件：\n\n```vue [Child.vue]\n<script setup>\nconst props = defineProps(['modelValue'])\nconst emit = defineEmits(['update:modelValue'])\n</script>\n\n<template>\n  <input\n    :value=\"props.modelValue\"\n    @input=\"emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n然后，父组件中的 `v-model=\"foo\"` 将被编译为：\n\n```vue-html [Parent.vue]\n<Child\n  :modelValue=\"foo\"\n  @update:modelValue=\"$event => (foo = $event)\"\n/>\n```\n\n如你所见，这显得冗长得多。然而，这样写有助于理解其底层机制。\n\n因为 `defineModel` 声明了一个 prop，你可以通过给 `defineModel` 传递选项，来声明底层 prop 的选项：\n\n```js\n// 使 v-model 必填\nconst model = defineModel({ required: true })\n\n// 提供一个默认值\nconst model = defineModel({ default: 0 })\n```\n\n:::warning\n如果为 `defineModel` prop 设置了一个 `default` 值且父组件没有为该 prop 提供任何值，会导致父组件与子组件之间不同步。在下面的示例中，父组件的 `myRef` 是 undefined，而子组件的 `model` 是 1：\n\n```vue [Child.vue]\n<script setup>\nconst model = defineModel({ default: 1 })\n</script>\n```\n\n```vue [Parent.vue]\n<script setup>\nconst myRef = ref()\n</script>\n\n<template>\n  <Child v-model=\"myRef\"></Child>\n</template>\n```\n\n:::\n\n</div>\n\n<div class=\"options-api\">\n\n首先让我们回忆一下 `v-model` 在原生元素上的用法：\n\n```vue-html\n<input v-model=\"searchText\" />\n```\n\n在代码背后，模板编译器会对 `v-model` 进行更冗长的等价展开。因此上面的代码其实等价于下面这段：\n\n```vue-html\n<input\n  :value=\"searchText\"\n  @input=\"searchText = $event.target.value\"\n/>\n```\n\n而当使用在一个组件上时，`v-model` 会被展开为如下的形式：\n\n```vue-html\n<CustomInput\n  :model-value=\"searchText\"\n  @update:model-value=\"newValue => searchText = newValue\"\n/>\n```\n\n要让这个例子实际工作起来，`<CustomInput>` 组件内部需要做两件事：\n\n1. 将内部原生 `<input>` 元素的 `value` attribute 绑定到 `modelValue` prop\n2. 当原生的 `input` 事件触发时，触发一个携带了新值的 `update:modelValue` 自定义事件\n\n这里是相应的代码：\n\n```vue [CustomInput.vue]\n<script>\nexport default {\n  props: ['modelValue'],\n  emits: ['update:modelValue']\n}\n</script>\n\n<template>\n  <input\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n现在 `v-model` 可以在这个组件上正常工作了：\n\n```vue-html\n<CustomInput v-model=\"searchText\" />\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqFkctqwzAQRX9lEAEn4Np744aWrvoD3URdiHiSGvRCHpmC8b93JDfGKYGCkJjXvTrSJF69r8aIohHtcA69p6O0vfEuELzFgZx5tz4SXIIzUFT1JpfGCmmlxe/c3uFFRU0wSQtwdqxh0dLQwHSnNJep3ilS+8PSCxCQYrC3CMDgMKgrNlB8odaOXVJ2TgdvvNp6vSwHhMZrRcgRQLs1G5+M61A/S/ErKQXUR5immwXMWW1VEKX4g3j3Mo9QfXCeKU9FtvpQmp/lM0Oi6RP/qYieebHZNvyL0acLLODNmGYSxCogxVJ6yW1c2iWz/QOnEnY48kdUpMIVGSllD8t8zVZb+PkHqPG4iw==)\n\n另一种在组件内实现 `v-model` 的方式是使用一个可写的，同时具有 getter 和 setter 的 `computed` 属性。`get` 方法需返回 `modelValue` prop，而 `set` 方法需触发相应的事件：\n\n```vue [CustomInput.vue]\n<script>\nexport default {\n  props: ['modelValue'],\n  emits: ['update:modelValue'],\n  computed: {\n    value: {\n      get() {\n        return this.modelValue\n      },\n      set(value) {\n        this.$emit('update:modelValue', value)\n      }\n    }\n  }\n}\n</script>\n\n<template>\n  <input v-model=\"value\" />\n</template>\n```\n\n</div>\n\n## `v-model` 的参数 {#v-model-arguments}\n\n组件上的 `v-model` 也可以接受一个参数：\n\n```vue-html\n<MyComponent v-model:title=\"bookTitle\" />\n```\n\n<div class=\"composition-api\">\n\n在子组件中，我们可以通过将字符串作为第一个参数传递给 `defineModel()` 来支持相应的参数：\n\n```vue [MyComponent.vue]\n<script setup>\nconst title = defineModel('title')\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"title\" />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqFklFPwjAUhf9K05dhgiyGNzJI1PCgCWqUx77McQeFrW3aOxxZ9t+9LTAXA/q2nnN6+t12Db83ZrSvgE944jIrDTIHWJmZULI02iJrmIWctSy3umQRRaPOWhweNX0pUHiyR3FP870UZkyoTCuH7FPr3VJiAWzqSwfR/rbUKyhYatdV6VugTktTQHQjVBIfeYiEFgikpwi0YizZ3M2aplfXtklMWvD6UKf+CfrUVPBuh+AspngSd718yH+hX7iS4xihjUZYQS4VLPwJgyiI/3FLZSrafzAeBqFG4jgxeuEqGTo6OZfr0dZpRVxNuFWeEa4swL4alEQm+IQFx3tpUeiv56ChrWB41rMNZLsL+tbVXhP8zYIDuyeQzkN6HyBWb88/XgJ3ZxJ95bH/MN/B6aLyjMfYQ6VWhN3LBdqn8FdJtV66eY2g3HkoD+qTbcgLTo/jX+ra6D+449E47BOq5e039mr+gA==)\n\n如果需要额外的 prop 选项，应该在 model 名称之后传递：\n\n```js\nconst title = defineModel('title', { required: true })\n```\n\n<details>\n<summary>3.4 之前的用法</summary>\n\n```vue [MyComponent.vue]\n<script setup>\ndefineProps({\n  title: {\n    required: true\n  }\n})\ndefineEmits(['update:title'])\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"title\"\n    @input=\"$emit('update:title', $event.target.value)\"\n  />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9kE1rwzAMhv+KMIW00DXsGtKyMXYc7D7vEBplM8QfOHJoCfnvk+1QsjJ2svVKevRKk3h27jAGFJWoh7NXjmBACu4kjdLOeoIJPHYwQ+ethoJLi1vq7fpi+WfQ0JI+lCstcrkYQJqzNQMBKeoRjhG4LcYHbVvsofFfQUcCXhrteix20tRl9sIuOCBkvSHkCKD+fjxN04Ka57rkOOlrMwu7SlVHKdIrBZRcWpc3ntiLO7t/nKHFThl899YN248ikYpP9pj1V60o6sG1TMwDU/q/FZRxgeIPgK4uGcQLSZGlamz6sHKd1afUxOoGeeT298A9bHCMKxBfE3mTSNjl1vud5x8qNa76)\n\n</details>\n</div>\n<div class=\"options-api\">\n\n在这种情况下，子组件应该使用 `title` prop 和 `update:title` 事件来更新父组件的值，而非默认的 `modelValue` prop 和 `update:modelValue` 事件：\n\n```vue [MyComponent.vue]\n<script>\nexport default {\n  props: ['title'],\n  emits: ['update:title']\n}\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"title\"\n    @input=\"$emit('update:title', $event.target.value)\"\n  />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqFUNFqwzAM/BVhCm6ha9hryMrGnvcFdR9Mo26B2DGuHFJC/n2yvZakDAohtuTTne5G8eHcrg8oSlFdTr5xtFe2Ma7zBF/Xz45vFi3B2XcG5K6Y9eKYVFZZHBK8xrMOLcGoLMDphrqUMC6Ypm18rzXp9SZjATxS8PZWAVBDLZYg+xfT1diC9t/BxGEctHFtlI2wKR78468q7ttzQcgoTcgVQPXzuh/HzAnTVBVcp/58qz+lMqHelEinElAwtCrufGIrHhJYBPdfEs53jkM4yEQpj8k+miYmc5DBcRKYZeXxqZXGukDZPF1dWhQHUiK3yl63YbZ97r6nIe6uoup6KbmFFfbRCnHGyI4iwyaPPnqffgGMlsEM)\n\n</div>\n\n## 多个 `v-model` 绑定 {#multiple-v-model-bindings}\n\n利用刚才在 [`v-model` 的参数](#v-model-arguments)小节中学到的指定参数与事件名的技巧，我们可以在单个组件实例上创建多个 `v-model` 双向绑定。\n\n组件上的每一个 `v-model` 都会同步不同的 prop，而无需额外的选项：\n\n```vue-html\n<UserName\n  v-model:first-name=\"first\"\n  v-model:last-name=\"last\"\n/>\n```\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nconst firstName = defineModel('firstName')\nconst lastName = defineModel('lastName')\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"firstName\" />\n  <input type=\"text\" v-model=\"lastName\" />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqFkstuwjAQRX/F8iZUAqKKHQpIfbAoUmnVx86bKEzANLEt26FUkf+9Y4MDSAg2UWbu9fjckVv6oNRw2wAd08wUmitLDNhGTZngtZLakpZoKIkjpZY1SdCadNK3Ab3IazhowzQ2/ES0MVFIYSwpucbvxA/qJXO5FsldlKr8qDxL8EKW7kEQAQsLtapyC1gRkq3vp217mOccwf8wwLksRSlYIoMvCNkOarmEahyODAT2J4yGgtFzhx8UDf5/r6c4NEs7CNqnpxkvbO0kcVjNhCyh5AJe/SW9pBPOV3DJGvu3dsKFaiyxf8qTW9gheQwVs4Z90BDm5oF47cF/Ht4aZC75argxUmD61g9ktJC14hXoN2U5ZmJ0TILitbyq5O889KxuoB/7xRqKnwv9jdn5HqPvGnDVWwTpNJvrFSCul2efi4DeiRigqdB9RfwAI6vGM+5tj41YIvaJL9C+hOfNxerLzHYWhImhPKh3uuBnFJ/A05XoR9zRcBTOMeGo+wcs+yse)\n\n<details>\n<summary>3.4 之前的用法</summary>\n\n```vue\n<script setup>\ndefineProps({\n  firstName: String,\n  lastName: String\n})\n\ndefineEmits(['update:firstName', 'update:lastName'])\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"firstName\"\n    @input=\"$emit('update:firstName', $event.target.value)\"\n  />\n  <input\n    type=\"text\"\n    :value=\"lastName\"\n    @input=\"$emit('update:lastName', $event.target.value)\"\n  />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqNUc1qwzAMfhVjCk6hTdg1pGWD7bLDGIydlh1Cq7SGxDaOEjaC332yU6cdFNpLsPRJ348y8idj0qEHnvOi21lpkHWAvdmWSrZGW2Qjs1Azx2qrWyZoVMzQZwf2rWrhhKVZbHhGGivVTqsOWS0tfTeeKBGv+qjEMkJNdUaeNXigyCYjZIEKhNY0FQJVjBXHh+04nvicY/QOBM4VGUFhJHrwBWPDutV7aPKwslbU35Q8FCX/P+GJ4oB/T3hGpEU2m+ArfpnxytX2UEsF71abLhk9QxDzCzn7QCvVYeW7XuGyWSpH0eP6SyuxS75Eb/akOpn302LFYi8SiO8bJ5PK9DhFxV/j0yH8zOnzoWr6+SbhbifkMSwSsgByk1zzsoABFKZY2QNgGpiW57Pdrx2z3JCeI99Svvxh7g8muf2x)\n\n</details>\n</div>\n<div class=\"options-api\">\n\n```vue\n<script>\nexport default {\n  props: {\n    firstName: String,\n    lastName: String\n  },\n  emits: ['update:firstName', 'update:lastName']\n}\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"firstName\"\n    @input=\"$emit('update:firstName', $event.target.value)\"\n  />\n  <input\n    type=\"text\"\n    :value=\"lastName\"\n    @input=\"$emit('update:lastName', $event.target.value)\"\n  />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqNkk1rg0AQhv/KIAETSJRexYYWeuqhl9JTt4clmSSC7i7rKCnif+/ObtYkELAiujPzztejQ/JqTNZ3mBRJ2e5sZWgrVNUYbQm+WrQfskE4WN1AmuXRwQmpUELh2Qv3eJBdTTAIBbDTLluhoraA4VpjXHNwL0kuV0EIYJE6q6IFcKhsSwWk7/qkUq/nq5be+aa5JztGfrmHu8t8GtoZhI2pJaGzAMrT03YYQk0YR3BnruSOZe5CXhKnC3X7TaP3WBc+ZaOc/1kk3hDJvYILRQGfQzx3Rct8GiJZJ7fA7gg/AmesNszMrUIXFpxbwCfZSh09D0Hc7tbN6sAWm4qZf6edcZgxrMHSdA3RF7PTn1l8lTIdhbXp1/CmhOeJRNHLupv4eIaXyItPdJEFD7R8NM0Ce/d/ZCTtESnzlVZXhP/vHbeZaT0tPdf59uONfx7mDVM=)\n\n</div>\n\n## 处理 `v-model` 修饰符 {#handling-v-model-modifiers}\n\n在学习输入绑定时，我们知道了 `v-model` 有一些[内置的修饰符](/guide/essentials/forms#modifiers)，例如 `.trim`，`.number` 和 `.lazy`。在某些场景下，你可能想要一个自定义组件的 `v-model` 支持自定义的修饰符。\n\n我们来创建一个自定义的修饰符 `capitalize`，它会自动将 `v-model` 绑定输入的字符串值第一个字母转为大写：\n\n```vue-html\n<MyComponent v-model.capitalize=\"myText\" />\n```\n\n<div class=\"composition-api\">\n\n通过像这样解构 `defineModel()` 的返回值，可以在子组件中访问添加到组件 `v-model` 的修饰符：\n\n```vue{4}\n<script setup>\nconst [model, modifiers] = defineModel()\n\nconsole.log(modifiers) // { capitalize: true }\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"model\" />\n</template>\n```\n\n为了能够基于修饰符选择性地调节值的读取和写入方式，我们可以给 `defineModel()` 传入 `get` 和 `set` 这两个选项。这两个选项在从模型引用中读取或设置值时会接收到当前的值，并且它们都应该返回一个经过处理的新值。下面是一个例子，展示了如何利用 `set` 选项来应用 `capitalize` (首字母大写) 修饰符：\n\n```vue{4-6}\n<script setup>\nconst [model, modifiers] = defineModel({\n  set(value) {\n    if (modifiers.capitalize) {\n      return value.charAt(0).toUpperCase() + value.slice(1)\n    }\n    return value\n  }\n})\n</script>\n\n<template>\n  <input type=\"text\" v-model=\"model\" />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9UsFu2zAM/RVClzhY5mzoLUgHdEUPG9Bt2LLTtIPh0Ik6WRIkKksa5N9LybFrFG1OkvgeyccnHsWNc+UuoliIZai9cgQBKbpP0qjWWU9wBI8NnKDxtoUJUycDdH+4tXwzaOgMl/NRLNVlMoA0tTWBoD2scE9wnSoWk8lUmuW8a8rt+EHYOl0R8gtgtVUBlHGRoK6cokqrRwxAW4RGea6mkQg9HGwEboZ+kbKWY027961doy6f86+l6ERIAXNus5wPPcVMvNB+yZOaiZFw/cKYftI/ufEM+FCNQh/+8tRrbJTB+4QUxySWqxa7SkecQn4DqAaKIWekeyAAe0fRG8h5Zb2t/A0VH6Yl2d/Oob+tAhZTeHfGg1Y1Fh/Z6ZR66o5xhRTh8OnyXyy7f6CDSw5S59/Z3WRpOl91lAL70ahN+RCsYT/zFFIk95RG/92RYr+kWPTzSVFpbf9/zTHyEWd9vN5i/e+V+EPYp5gUPzwG9DuUYsCo8htkrQm++/Ut6x5AVh01sy+APzFYHZPGjvY5mjXLHvGy2i95K5TZrMLdntCEfqgkNDuc+VLwkqQNe2v0Z7lX5VX/M+L0BFEuPdc=)\n\n<details>\n<summary>3.4 之前的用法</summary>\n\n```vue{11-13}\n<script setup>\nconst props = defineProps({\n  modelValue: String,\n  modelModifiers: { default: () => ({}) }\n})\n\nconst emit = defineEmits(['update:modelValue'])\n\nfunction emitValue(e) {\n  let value = e.target.value\n  if (props.modelModifiers.capitalize) {\n    value = value.charAt(0).toUpperCase() + value.slice(1)\n  }\n  emit('update:modelValue', value)\n}\n</script>\n\n<template>\n  <input type=\"text\" :value=\"props.modelValue\" @input=\"emitValue\" />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9Us1Og0AQfpUJF5ZYqV4JNTaNxyYmVi/igdCh3QR2N7tDIza8u7NLpdU0nmB+v5/ZY7Q0Jj10GGVR7iorDYFD6sxDoWRrtCU4gsUaBqitbiHm1ngqrfuV5j+Fik7ldH6R83u5GaBQlVaOoO03+Emw8BtFHCeFyucjKMNxQNiapiTkCGCzlw6kMh1BVRpJZSO/0AEe0Pa0l2oHve6AYdBmvj+/ZHO4bfUWm/Q8uSiiEb6IYM4A+XxCi2bRH9ZX3BgVGKuNYwFbrKXCZx+Jo0cPcG9l02EGL2SZ3mxKr/VW1hKty9hMniy7hjIQCSweQByHBIZCDWzGDwi20ps0Yjxx4MR73Jktc83OOPFHGKk7VZHUKkyFgsAEAqcG2Qif4WWYUml3yOp8wldlDSLISX+TvPDstAemLeGbVvvSLkncJSnpV2PQrkqHLOfmVHeNrFDcMz3w0iBQE1cUzMYBbuS2f55CPj4D6o0/I41HzMKsP+u0kLOPoZWzkx1X7j18A8s0DEY=)\n\n</details>\n</div>\n\n<div class=\"options-api\">\n\n添加到组件 `v-model` 的修饰符将通过 `modelModifiers` prop 提供给组件。在下面的示例中，我们创建了一个包含 `modelModifiers` prop 的组件，该 prop 默认为空对象：\n\n```vue{11}\n<script>\nexport default {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  emits: ['update:modelValue'],\n  created() {\n    console.log(this.modelModifiers) // { capitalize: true }\n  }\n}\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"$emit('update:modelValue', $event.target.value)\"\n  />\n</template>\n```\n\n请注意，该组件的 `modelModifiers` prop 包含 `capitalize` 且值为 `true` ——因为它是在 `v-model.capitalize=\"myText\"` 这个 `v-model` 绑定上设置的。\n\n现在我们已经为组件配置了 prop，我们可以检查 `modelModifiers` 对象的键并编写一个处理程序来更改抛出的值。在下面的代码中，每当 `<input />` 元素触发 `input` 事件时，我们都会将首字母大写。\n\n```vue{13-15}\n<script>\nexport default {\n  props: {\n    modelValue: String,\n    modelModifiers: {\n      default: () => ({})\n    }\n  },\n  emits: ['update:modelValue'],\n  methods: {\n    emitValue(e) {\n      let value = e.target.value\n      if (this.modelModifiers.capitalize) {\n        value = value.charAt(0).toUpperCase() + value.slice(1)\n      }\n      this.$emit('update:modelValue', value)\n    }\n  }\n}\n</script>\n\n<template>\n  <input type=\"text\" :value=\"modelValue\" @input=\"emitValue\" />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqFks1qg0AQgF9lkIKGpqa9iikNOefUtJfaw6KTZEHdZR1DbPDdO7saf0qgIq47//PNXL2N1uG5Ri/y4io1UtNrUspCK0Owa7aK/0osCQ5GFeCHq4nMuvlJCZCUeHEOGR5EnRNcrTS92VURXGex2qXVZ4JEsOhsAQxSbcrbDaBo9nihCHyXAaC1B3/4jVdDoXwhLHQuCPkGsD/JCmSpa4JUaEkilz9YAZ7RNHSS5REaVQPXgCay9vG0rPNToTLMw9FznXhdHYkHK04Qr4Zs3tL7g2JG8B4QbZS2LLqGXK5PkdcYwTsZrs1R6RU7lcmDRDPaM7AuWARMbf0KwbVdTNk4dyyk5f3l15r5YjRm8b+dQYF0UtkY1jo4fYDDLAByZBxWCmvAkIQ5IvdoBTcLeYCAiVbhvNwJvEk4GIK5M0xPwmwoeF6EpD60RrMVFXJXj72+ymWKwUvfXt+gfVzGB1tzcKfDZec+o/LfxsTdtlCj7bSpm3Xk4tjpD8FZ+uZMWTowu7MW7S+CWR77)\n\n</div>\n\n### 带参数的 `v-model` 修饰符 {#modifiers-for-v-model-with-arguments}\n\n<div class=\"options-api\">\n\n对于又有参数又有修饰符的 `v-model` 绑定，生成的 prop 名将是 `arg + \"Modifiers\"`。举例来说：\n\n```vue-html\n<MyComponent v-model:title.capitalize=\"myText\">\n```\n\n相应的声明应该是：\n\n```js\nexport default {\n  props: ['title', 'titleModifiers'],\n  emits: ['update:title'],\n  created() {\n    console.log(this.titleModifiers) // { capitalize: true }\n  }\n}\n```\n\n</div>\n\n这里是另一个例子，展示了如何在使用多个不同参数的 `v-model` 时使用修饰符：\n\n```vue-html\n<UserName\n  v-model:first-name.capitalize=\"first\"\n  v-model:last-name.uppercase=\"last\"\n/>\n```\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nconst [firstName, firstNameModifiers] = defineModel('firstName')\nconst [lastName, lastNameModifiers] = defineModel('lastName')\n\nconsole.log(firstNameModifiers) // { capitalize: true }\nconsole.log(lastNameModifiers) // { uppercase: true }\n</script>\n```\n\n<details>\n<summary>3.4 之前的用法</summary>\n\n```vue{5,6,10,11}\n<script setup>\nconst props = defineProps({\n  firstName: String,\n  lastName: String,\n  firstNameModifiers: { default: () => ({}) },\n  lastNameModifiers: { default: () => ({}) }\n})\ndefineEmits(['update:firstName', 'update:lastName'])\n\nconsole.log(props.firstNameModifiers) // { capitalize: true }\nconsole.log(props.lastNameModifiers) // { uppercase: true }\n</script>\n```\n\n</details>\n</div>\n<div class=\"options-api\">\n\n```vue{15,16}\n<script>\nexport default {\n  props: {\n    firstName: String,\n    lastName: String,\n    firstNameModifiers: {\n      default: () => ({})\n    },\n    lastNameModifiers: {\n      default: () => ({})\n    }\n  },\n  emits: ['update:firstName', 'update:lastName'],\n  created() {\n    console.log(this.firstNameModifiers) // { capitalize: true }\n    console.log(this.lastNameModifiers) // { uppercase: true }\n  }\n}\n</script>\n```\n\n</div>\n\n\n\n================================================\nFILE: src/guide/essentials/application.md\n================================================\n# 创建一个 Vue 应用 {#creating-a-vue-application}\n\n## 应用实例 {#the-application-instance}\n\n每个 Vue 应用都是通过 [`createApp`](/api/application#createapp) 函数创建一个新的 **应用实例**：\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp({\n  /* 根组件选项 */\n})\n```\n\n## 根组件 {#the-root-component}\n\n我们传入 `createApp` 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。\n\n如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。\n\n```js\nimport { createApp } from 'vue'\n// 从一个单文件组件中导入根组件\nimport App from './App.vue'\n\nconst app = createApp(App)\n```\n\n虽然本指南中的许多示例只需要一个组件，但大多数真实的应用都是由一棵嵌套的、可重用的组件树组成的。例如，一个待办事项 (Todos) 应用的组件树可能是这样的：\n\n```\nApp (root component)\n├─ TodoList\n│  └─ TodoItem\n│     ├─ TodoDeleteButton\n│     └─ TodoEditButton\n└─ TodoFooter\n   ├─ TodoClearButton\n   └─ TodoStatistics\n```\n\n我们会在指南的后续章节中讨论如何定义和组合多个组件。在那之前，我们得先关注一个组件内到底发生了什么。\n\n## 挂载应用 {#mounting-the-app}\n\n应用实例必须在调用了 `.mount()` 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：\n\n```html\n<div id=\"app\"></div>\n```\n\n```js\napp.mount('#app')\n```\n\n应用根组件的内容将会被渲染在容器元素里面。容器元素自己将**不会**被视为应用的一部分。\n\n`.mount()` 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。\n\n### DOM 中的根组件模板 {#in-dom-root-component-template}\n\n根组件的模板通常是组件本身的一部分，但也可以直接通过在挂载容器内编写模板来单独提供：\n\n```html\n<div id=\"app\">\n  <button @click=\"count++\">{{ count }}</button>\n</div>\n```\n\n```js\nimport { createApp } from 'vue'\n\nconst app = createApp({\n  data() {\n    return {\n      count: 0\n    }\n  }\n})\n\napp.mount('#app')\n```\n\n当根组件没有设置 `template` 选项时，Vue 将自动使用容器的 `innerHTML` 作为模板。\n\nDOM 内模板通常用于[无构建步骤](/guide/quick-start.html#using-vue-from-cdn)的 Vue 应用程序。它们也可以与服务器端框架一起使用，其中根模板可能是由服务器动态生成的。\n\n## 应用配置 {#app-configurations}\n\n应用实例会暴露一个 `.config` 对象允许我们配置一些应用级的选项，例如定义一个应用级的错误处理器，用来捕获所有子组件上的错误：\n\n```js\napp.config.errorHandler = (err) => {\n  /* 处理错误 */\n}\n```\n\n应用实例还提供了一些方法来注册应用范围内可用的资源，例如注册一个组件：\n\n```js\napp.component('TodoDeleteButton', TodoDeleteButton)\n```\n\n这使得 `TodoDeleteButton` 在应用的任何地方都是可用的。我们会在指南的后续章节中讨论关于组件和其他资源的注册。你也可以在 [API 参考](/api/application)中浏览应用实例 API 的完整列表。\n\n确保在挂载应用实例之前完成所有应用配置！\n\n## 多个应用实例 {#multiple-application-instances}\n\n应用实例并不只限于一个。`createApp` API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。\n\n```js\nconst app1 = createApp({\n  /* ... */\n})\napp1.mount('#container-1')\n\nconst app2 = createApp({\n  /* ... */\n})\napp2.mount('#container-2')\n```\n\n如果你正在使用 Vue 来增强服务端渲染 HTML，并且只想要 Vue 去控制一个大型页面中特殊的一小部分，应避免将一个单独的 Vue 应用实例挂载到整个页面上，而是应该创建多个小的应用实例，将它们分别挂载到所需的元素上去。\n\n<!-- zhlint disabled -->\n\n\n\n================================================\nFILE: src/guide/essentials/class-and-style.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/essentials/component-basics.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/essentials/computed.md\n================================================\n# 计算属性 {#computed-properties}\n\n<div class=\"options-api\">\n  <VueSchoolLink href=\"https://vueschool.io/lessons/computed-properties-in-vue-3\" title=\"免费的 Vue.js 计算属性课程\"/>\n</div>\n\n<div class=\"composition-api\">\n  <VueSchoolLink href=\"https://vueschool.io/lessons/vue-fundamentals-capi-computed-properties-in-vue-with-the-composition-api\" title=\"免费的 Vue.js 计算属性课程\"/>\n</div>\n\n## 基础示例 {#basic-example}\n\n模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象：\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  data() {\n    return {\n      author: {\n        name: 'John Doe',\n        books: [\n          'Vue 2 - Advanced Guide',\n          'Vue 3 - Basic Guide',\n          'Vue 4 - The Mystery'\n        ]\n      }\n    }\n  }\n}\n```\n\n</div>\n<div class=\"composition-api\">\n\n```js\nconst author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})\n```\n\n</div>\n\n我们想根据 `author` 是否已有一些书籍来展示不同的信息：\n\n```vue-html\n<p>Has published books:</p>\n<span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>\n```\n\n这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于 `author.books`。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。\n\n因此我们推荐使用**计算属性**来描述依赖响应式状态的复杂逻辑。这是重构后的示例：\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  data() {\n    return {\n      author: {\n        name: 'John Doe',\n        books: [\n          'Vue 2 - Advanced Guide',\n          'Vue 3 - Basic Guide',\n          'Vue 4 - The Mystery'\n        ]\n      }\n    }\n  },\n  computed: {\n    // 一个计算属性的 getter\n    publishedBooksMessage() {\n      // `this` 指向当前组件实例\n      return this.author.books.length > 0 ? 'Yes' : 'No'\n    }\n  }\n}\n```\n\n```vue-html\n<p>Has published books:</p>\n<span>{{ publishedBooksMessage }}</span>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqFkN1KxDAQhV/l0JsqaFfUq1IquwiKsF6JINaLbDNui20S8rO4lL676c82eCFCIDOZMzkzXxetlUoOjqI0ykypa2XzQtC3ktqC0ydzjUVXCIAzy87OpxjQZJ0WpwxgzlZSp+EBEKylFPGTrATuJcUXobST8sukeA8vQPzqCNe4xJofmCiJ48HV/FfbLLrxog0zdfmn4tYrXirC9mgs6WMcBB+nsJ+C8erHH0rZKmeJL0sot2tqUxHfDONuyRi2p4BggWCr2iQTgGTcLGlI7G2FHFe4Q/xGJoYn8SznQSbTQviTrRboPrHUqoZZ8hmQqfyRmTDFTC1bqalsFBN5183o/3NG33uvoWUwXYyi/gdTEpwK)\n\n我们在这里定义了一个计算属性 `publishedBooksMessage`。\n\n更改此应用的 `data` 中 `books` 数组的值后，可以看到 `publishedBooksMessage` 也会随之改变。\n\n在模板中使用计算属性的方式和一般的属性并无二致。Vue 会检测到 `this.publishedBooksMessage` 依赖于 `this.author.books`，所以当 `this.author.books` 改变时，任何依赖于 `this.publishedBooksMessage` 的绑定都将同时更新。\n\n也可参考：[为计算属性标记类型](/guide/typescript/options-api#typing-computed-properties) <sup class=\"vt-badge ts\" />\n\n</div>\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nimport { reactive, computed } from 'vue'\n\nconst author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})\n\n// 一个计算属性 ref\nconst publishedBooksMessage = computed(() => {\n  return author.books.length > 0 ? 'Yes' : 'No'\n})\n</script>\n\n<template>\n  <p>Has published books:</p>\n  <span>{{ publishedBooksMessage }}</span>\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp1kE9Lw0AQxb/KI5dtoTainkoaaREUoZ5EEONhm0ybYLO77J9CCfnuzta0vdjbzr6Zeb95XbIwZroPlMySzJW2MR6OfDB5oZrWaOvRwZIsfbOnCUrdmuCpQo+N1S0ET4pCFarUynnI4GttMT9PjLpCAUq2NIN41bXCkyYxiZ9rrX/cDF/xDYiPQLjDDRbVXqqSHZ5DUw2tg3zP8lK6pvxHe2DtvSasDs6TPTAT8F2ofhzh0hTygm5pc+I1Yb1rXE3VMsKsyDm5JcY/9Y5GY8xzHI+wnIpVw4nTI/10R2rra+S4xSPEJzkBvvNNs310ztK/RDlLLjy1Zic9cQVkJn+R7gIwxJGlMXiWnZEq77orhH3Pq2NH9DjvTfpfSBSbmA==)\n\n我们在这里定义了一个计算属性 `publishedBooksMessage`。`computed()` 方法期望接收一个 [getter 函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description)，返回值为一个**计算属性 ref**。和其他一般的 ref 类似，你可以通过 `publishedBooksMessage.value` 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 `.value`。\n\nVue 的计算属性会自动追踪响应式依赖。它会检测到 `publishedBooksMessage` 依赖于 `author.books`，所以当 `author.books` 改变时，任何依赖于 `publishedBooksMessage` 的绑定都会同时更新。\n\n也可参考：[为计算属性标注类型](/guide/typescript/composition-api#typing-computed) <sup class=\"vt-badge ts\" />\n\n</div>\n\n## 计算属性缓存 vs 方法 {#computed-caching-vs-methods}\n\n你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果：\n\n```vue-html\n<p>{{ calculateBooksMessage() }}</p>\n```\n\n<div class=\"options-api\">\n\n```js\n// 组件中\nmethods: {\n  calculateBooksMessage() {\n    return this.author.books.length > 0 ? 'Yes' : 'No'\n  }\n}\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n```js\n// 组件中\nfunction calculateBooksMessage() {\n  return author.books.length > 0 ? 'Yes' : 'No'\n}\n```\n\n</div>\n\n若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于**计算属性值会基于其响应式依赖被缓存**。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 `author.books` 不改变，无论多少次访问 `publishedBooksMessage` 都会立即返回先前的计算结果，而不用重复执行 getter 函数。\n\n这也解释了为什么下面的计算属性永远不会更新，因为 `Date.now()` 并不是一个响应式依赖：\n\n<div class=\"options-api\">\n\n```js\ncomputed: {\n  now() {\n    return Date.now()\n  }\n}\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n```js\nconst now = computed(() => Date.now())\n```\n\n</div>\n\n相比之下，方法调用**总是**会在重渲染发生时再次执行函数。\n\n为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 `list`，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 `list`。没有缓存的话，我们会重复执行非常多次 `list` 的 getter，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。\n\n## 可写计算属性 {#writable-computed}\n\n计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  data() {\n    return {\n      firstName: 'John',\n      lastName: 'Doe'\n    }\n  },\n  computed: {\n    fullName: {\n      // getter\n      get() {\n        return this.firstName + ' ' + this.lastName\n      },\n      // setter\n      set(newValue) {\n        // 注意：我们这里使用的是解构赋值语法\n        [this.firstName, this.lastName] = newValue.split(' ')\n      }\n    }\n  }\n}\n```\n\n现在当你再运行 `this.fullName = 'John Doe'` 时，setter 会被调用而 `this.firstName` 和 `this.lastName` 会随之更新。\n\n</div>\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nimport { ref, computed } from 'vue'\n\nconst firstName = ref('John')\nconst lastName = ref('Doe')\n\nconst fullName = computed({\n  // getter\n  get() {\n    return firstName.value + ' ' + lastName.value\n  },\n  // setter\n  set(newValue) {\n    // 注意：我们这里使用的是解构赋值语法\n    [firstName.value, lastName.value] = newValue.split(' ')\n  }\n})\n</script>\n```\n\n现在当你再运行 `fullName.value = 'John Doe'` 时，setter 会被调用而 `firstName` 和 `lastName` 会随之更新。\n\n</div>\n\n## 获取上一个值 {#previous}\n\n- 仅 3.4+ 支持\n\n<p class=\"options-api\">\n如果需要，可以通过访问计算属性的 getter 的第二个参数来获取计算属性返回的上一个值：\n</p>\n\n<p class=\"composition-api\">\n如果需要，可以通过访问计算属性的 getter 的第一个参数来获取计算属性返回的上一个值：\n</p>\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  data() {\n    return {\n      count: 2\n    }\n  },\n  computed: {\n    // 这个计算属性在 count 的值小于或等于 3 时，将返回 count 的值。\n    // 当 count 的值大于等于 4 时，将会返回满足我们条件的最后一个值\n    // 直到 count 的值再次小于或等于 3 为止。\n    alwaysSmall(_, previous) {\n      if (this.count <= 3) {\n        return this.count\n      }\n\n      return previous\n    }\n  }\n}\n```\n</div>\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nimport { ref, computed } from 'vue'\n\nconst count = ref(2)\n\n// 这个计算属性在 count 的值小于或等于 3 时，将返回 count 的值。\n// 当 count 的值大于等于 4 时，将会返回满足我们条件的最后一个值\n// 直到 count 的值再次小于或等于 3 为止。\nconst alwaysSmall = computed((previous) => {\n  if (count.value <= 3) {\n    return count.value\n  }\n\n  return previous\n})\n</script>\n```\n</div>\n\n如果你正在使用可写的计算属性的话：\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  data() {\n    return {\n      count: 2\n    }\n  },\n  computed: {\n    alwaysSmall: {\n      get(_, previous) {\n        if (this.count <= 3) {\n          return this.count\n        }\n\n        return previous;\n      },\n      set(newValue) {\n        this.count = newValue * 2\n      }\n    }\n  }\n}\n```\n\n</div>\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nimport { ref, computed } from 'vue'\n\nconst count = ref(2)\n\nconst alwaysSmall = computed({\n  get(previous) {\n    if (count.value <= 3) {\n      return count.value\n    }\n\n    return previous\n  },\n  set(newValue) {\n    count.value = newValue * 2\n  }\n})\n</script>\n```\n\n</div>\n\n## 最佳实践 {#best-practices}\n\n### Getter 不应有副作用 {#getters-should-be-side-effect-free}\n\n计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，**不要改变其他状态、在 getter 中做异步请求或者更改 DOM**！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用[侦听器](./watchers)根据其他响应式状态的变更来创建副作用。\n\n### 避免直接修改计算属性值 {#avoid-mutating-computed-value}\n\n从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。\n\n\n\n================================================\nFILE: src/guide/essentials/conditional.md\n================================================\n# 条件渲染 {#conditional-rendering}\n\n<script setup>\nimport { ref } from 'vue'\nconst awesome = ref(true)\n</script>\n\n## `v-if` {#v-if}\n\n`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回真值时才被渲染。\n\n```vue-html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n```\n\n## `v-else` {#v-else}\n\n你也可以使用 `v-else` 为 `v-if` 添加一个“else 区块”。\n\n```vue-html\n<button @click=\"awesome = !awesome\">Toggle</button>\n\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>Oh no 😢</h1>\n```\n\n<div class=\"demo\">\n  <button @click=\"awesome = !awesome\">Toggle</button>\n  <h1 v-if=\"awesome\">Vue is awesome!</h1>\n  <h1 v-else>Oh no 😢</h1>\n</div>\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpFjkEOgjAQRa8ydIMulLA1hegJ3LnqBskAjdA27RQXhHu4M/GEHsEiKLv5mfdf/sBOxux7j+zAuCutNAQOyZtcKNkZbQkGsFjBCJXVHcQBjYUSqtTKERR3dLpDyCZmQ9bjViiezKKgCIGwM21BGBIAv3oireBYtrK8ZYKtgmg5BctJ13WLPJnhr0YQb1Lod7JaS4G8eATpfjMinjTphC8wtg7zcwNKw/v5eC1fnvwnsfEDwaha7w==)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpFjj0OwjAMha9iMsEAFWuVVnACNqYsoXV/RJpEqVOQqt6DDYkTcgRSWoplWX7y56fXs6O1u84jixlvM1dbSoXGuzWOIMdCekXQCw2QS5LrzbQLckje6VEJglDyhq1pMAZyHidkGG9hhObRYh0EYWOVJAwKgF88kdFwyFSdXRPBZidIYDWvgqVkylIhjyb4ayOIV3votnXxfwrk2SPU7S/PikfVfsRnGFWL6akCbeD9fLzmK4+WSGz4AA5dYQY=)\n\n</div>\n\n一个 `v-else` 元素必须跟在一个 `v-if` 或者 `v-else-if` 元素后面，否则它将不会被识别。\n\n## `v-else-if` {#v-else-if}\n\n顾名思义，`v-else-if` 提供的是相应于 `v-if` 的“else if 区块”。它可以连续多次重复使用：\n\n```vue-html\n<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else-if=\"type === 'C'\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n```\n\n和 `v-else` 类似，一个使用 `v-else-if` 的元素必须紧跟在一个 `v-if` 或一个 `v-else-if` 元素后面。\n\n## `<template>` 上的 `v-if` {#v-if-on-template}\n\n因为 `v-if` 是一个指令，他必须依附于某个元素。但如果我们想要切换不止一个元素呢？在这种情况下我们可以在一个 `<template>` 元素上使用 `v-if`，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 `<template>` 元素。\n\n```vue-html\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n```\n\n`v-else` 和 `v-else-if` 也可以在 `<template>` 上使用。\n\n## `v-show` {#v-show}\n\n另一个可以用来按条件显示一个元素的指令是 `v-show`。其用法基本一样：\n\n```vue-html\n<h1 v-show=\"ok\">Hello!</h1>\n```\n\n不同之处在于 `v-show` 会在 DOM 渲染中保留该元素；`v-show` 仅切换了该元素上名为 `display` 的 CSS 属性。\n\n`v-show` 不支持在 `<template>` 元素上使用，也不能和 `v-else` 搭配使用。\n\n## `v-if` vs. `v-show` {#v-if-vs-v-show}\n\n`v-if` 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。\n\n`v-if` 也是**惰性**的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。\n\n相比之下，`v-show` 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS `display` 属性会被切换。\n\n总的来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 `v-show` 较好；如果在运行时绑定条件很少改变，则 `v-if` 会更合适。\n\n## `v-if` 和 `v-for` {#v-if-with-v-for}\n\n当 `v-if` 和 `v-for` 同时存在于一个元素上的时候，`v-if` 会首先被执行。请查看[列表渲染指南](list#v-for-with-v-if)获取更多细节。\n\n::: warning 警告\n同时使用 `v-if` 和 `v-for` 是**不推荐的**，因为这样二者的优先级不明显。请查看[列表渲染指南](list#v-for-with-v-if)获得更多信息。\n:::\n\n\n\n================================================\nFILE: src/guide/essentials/event-handling.md\n================================================\n# 事件处理 {#event-handling}\n\n## 监听事件 {#listening-to-events}\n\n我们可以使用 `v-on` 指令 (简写为 `@`) 来监听 DOM 事件，并在事件触发时执行对应的 JavaScript。用法：`v-on:click=\"handler\"` 或 `@click=\"handler\"`。\n\n事件处理器 (handler) 的值可以是：\n\n1. **内联事件处理器**：事件被触发时执行的内联 JavaScript 语句 (与 `onclick` 类似)。\n\n2. **方法事件处理器**：一个指向组件上定义的方法的属性名或是路径。\n\n## 内联事件处理器 {#inline-handlers}\n\n内联事件处理器通常用于简单场景，例如：\n\n<div class=\"composition-api\">\n\n```js\nconst count = ref(0)\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\ndata() {\n  return {\n    count: 0\n  }\n}\n```\n\n</div>\n\n```vue-html\n<button @click=\"count++\">Add 1</button>\n<p>Count is: {{ count }}</p>\n```\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNo9jssKgzAURH/lko0tgrbbEqX+Q5fZaLxiqHmQ3LgJ+fdqFZcD58xMYp1z1RqRvRgP0itHEJCia4VR2llPkMDjBBkmbzUUG1oII4y0JhBIGw2hh2Znbo+7MLw+WjZ/C4TaLT3hnogPkcgaeMtFyW8j2GmXpWBtN47w5PWBHLhrPzPCKfWDXRHmPsCAaOBfgSOkdH3IGUhpDBWv9/e8vsZZ/gFFhFJN)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNo9jcEKgzAQRH9lyKlF0PYqqdR/6DGXaLYo1RjiRgrivzepIizLzu7sm1XUzuVLIFEKObe+d1wpS183eYahtw4DY1UWMJr15ZpmxYAnDt7uF0BxOwXL5Evc0kbxlmyxxZLFyY2CaXSDZkqKZROYJ4tnO/Tt56HEgckyJaraGNxlsVt2u6teHeF40s20EDo9oyGy+CPIYF1xULBt4H6kOZeFiwBZnOFi+wH0B1hk)\n\n</div>\n\n## 方法事件处理器 {#method-handlers}\n\n随着事件处理器的逻辑变得愈发复杂，内联代码方式变得不够灵活。因此 `v-on` 也可以接受一个方法名或对某个方法的调用。\n\n举例来说：\n\n<div class=\"composition-api\">\n\n```js\nconst name = ref('Vue.js')\n\nfunction greet(event) {\n  alert(`Hello ${name.value}!`)\n  // `event` 是 DOM 原生事件\n  if (event) {\n    alert(event.target.tagName)\n  }\n}\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\ndata() {\n  return {\n    name: 'Vue.js'\n  }\n},\nmethods: {\n  greet(event) {\n    // 方法中的 `this` 指向当前活跃的组件实例\n    alert(`Hello ${this.name}!`)\n    // `event` 是 DOM 原生事件\n    if (event) {\n      alert(event.target.tagName)\n    }\n  }\n}\n```\n\n</div>\n\n```vue-html\n<!-- `greet` 是上面定义过的方法名 -->\n<button @click=\"greet\">Greet</button>\n```\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpVj0FLxDAQhf/KMwjtXtq7dBcFQS/qzVMOrWFao2kSkkkvpf/dJIuCEBgm771vZnbx4H23JRJ3YogqaM+IxMlfpNWrd4GxI9CMA3NwK5psbaSVVjkbGXZaCediaJv3RN1XbE5FnZNVrJ3FEoi4pY0sn7BLC0yGArfjMxnjcLsXQrdNJtFxM+Ys0PcYa2CEjuBPylNYb4THtxdUobj0jH/YX3D963gKC5WyvGZ+xR7S5jf01yPzeblhWr2ZmErHw0dizivfK6PV91mKursUl6dSh/4qZ+vQ/+XE8QODonDi)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNplUE1LxDAQ/StjEbYL0t5LXRQEvag3Tz00prNtNE1CMilC6X83SUkRhJDJfLz3Jm8tHo2pFo9FU7SOW2Ho0in8MdoSDHhlXhKsnQIYGLHyvL8BLJK3KmcAis3YwOnDY/XlTnt1i2G7i/eMNOnBNRkwWkQqcUFFByVAXUNPk3A9COXEgBkGRgtFDkgDTQjcWxuAwDiJBeMsMcUxszCJlsr+BaXUcLtGwiqut930579KST1IBd5Aqlgie3p/hdTIk+IK//bMGqleEbMjxjC+BZVDIv0+m9CpcNr6MDgkhLORjDBm1H56Iq3ggUvBv++7IhnUFZfnGNt6b4fRtj5wxfYL9p+Sjw==)\n\n</div>\n\n方法事件处理器会自动接收原生 DOM 事件并触发执行。在上面的例子中，我们能够通过被触发事件的 `event.target` 访问到该 DOM 元素。\n\n<div class=\"composition-api\">\n\n你也可以看看[为事件处理器标注类型](/guide/typescript/composition-api#typing-event-handlers)这一章了解更多。<sup class=\"vt-badge ts\" />\n\n</div>\n<div class=\"options-api\">\n\n你也可以看看[为事件处理器标注类型](/guide/typescript/options-api#typing-event-handlers)这一章了解更多。<sup class=\"vt-badge ts\" />\n\n</div>\n\n### 方法与内联事件判断 {#method-vs-inline-detection}\n\n模板编译器会通过检查 `v-on` 的值是否是合法的 JavaScript 标识符或属性访问路径来断定是何种形式的事件处理器。举例来说，`foo`、`foo.bar` 和 `foo['bar']` 会被视为方法事件处理器，而 `foo()` 和 `count++` 会被视为内联事件处理器。\n\n## 在内联处理器中调用方法 {#calling-methods-in-inline-handlers}\n\n除了直接绑定方法名，你还可以在内联事件处理器中调用方法。这允许我们向方法传入自定义参数以代替原生事件：\n\n<div class=\"composition-api\">\n\n```js\nfunction say(message) {\n  alert(message)\n}\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nmethods: {\n  say(message) {\n    alert(message)\n  }\n}\n```\n\n</div>\n\n```vue-html\n<button @click=\"say('hello')\">Say hello</button>\n<button @click=\"say('bye')\">Say bye</button>\n```\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9jTEOwjAMRa8SeSld6I5CBWdg9ZJGBiJSN2ocpKjq3UmpFDGx+Vn//b/ANYTjOxGcQEc7uyAqkqTQI98TW3ETq2jyYaQYzYNatSArZTzNUn/IK7Ludr2IBYTG4I3QRqKHJFJ6LtY7+zojbIXNk7yfmhahv5msvqS7PfnHGjJVp9w/hu7qKKwfEd1NSg==)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNptjUEKwjAQRa8yZFO7sfsSi57B7WzGdjTBtA3NVC2ldzehEFwIw8D7vM9f1cX742tmVSsd2sl6aXDgjx8ngY7vNDuBFQeAnsWMXagToQAEWg49h0APLncDAIUcT5LzlKJsqRBfPF3ljQjCvXcknEj0bRYZBzi3zrbPE6o0UBhblKiaKy1grK52J/oA//23IcmNBD8dXeVBtX0BF0pXsg==)\n\n</div>\n\n## 在内联事件处理器中访问事件参数 {#accessing-event-argument-in-inline-handlers}\n\n有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 `$event` 变量，或者使用内联箭头函数：\n\n```vue-html\n<!-- 使用特殊的 $event 变量 -->\n<button @click=\"warn('Form cannot be submitted yet.', $event)\">\n  Submit\n</button>\n\n<!-- 使用内联箭头函数 -->\n<button @click=\"(event) => warn('Form cannot be submitted yet.', event)\">\n  Submit\n</button>\n```\n\n<div class=\"composition-api\">\n\n```js\nfunction warn(message, event) {\n  // 这里可以访问原生事件\n  if (event) {\n    event.preventDefault()\n  }\n  alert(message)\n}\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nmethods: {\n  warn(message, event) {\n    // 这里可以访问 DOM 原生事件\n    if (event) {\n      event.preventDefault()\n    }\n    alert(message)\n  }\n}\n```\n\n</div>\n\n## 事件修饰符 {#event-modifiers}\n\n在处理事件时调用 `event.preventDefault()` 或 `event.stopPropagation()` 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。\n\n为解决这一问题，Vue 为 `v-on` 提供了**事件修饰符**。修饰符是用 `.` 表示的指令后缀，包含以下这些：\n\n- `.stop`\n- `.prevent`\n- `.self`\n- `.capture`\n- `.once`\n- `.passive`\n\n```vue-html\n<!-- 单击事件将停止传递 -->\n<a @click.stop=\"doThis\"></a>\n\n<!-- 提交事件将不再重新加载页面 -->\n<form @submit.prevent=\"onSubmit\"></form>\n\n<!-- 修饰语可以使用链式书写 -->\n<a @click.stop.prevent=\"doThat\"></a>\n\n<!-- 也可以只有修饰符 -->\n<form @submit.prevent></form>\n\n<!-- 仅当 event.target 是元素本身时才会触发事件处理器 -->\n<!-- 例如：事件处理器不来自子元素 -->\n<div @click.self=\"doThat\">...</div>\n```\n\n::: tip\n使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。因此使用 `@click.prevent.self` 会阻止**元素及其子元素的所有点击事件的默认行为**，而 `@click.self.prevent` 则只会阻止对元素本身的点击事件的默认行为。\n:::\n\n`.capture`、`.once` 和 `.passive` 修饰符与[原生 `addEventListener` 事件](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#options)相对应：\n\n```vue-html\n<!-- 添加事件监听器时，使用 `capture` 捕获模式 -->\n<!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 -->\n<div @click.capture=\"doThis\">...</div>\n\n<!-- 点击事件最多被触发一次 -->\n<a @click.once=\"doThis\"></a>\n\n<!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 -->\n<!-- 以防其中包含 `event.preventDefault()` -->\n<div @scroll.passive=\"onScroll\">...</div>\n```\n\n`.passive` 修饰符一般用于触摸事件的监听器，可以用来[改善移动端设备的滚屏性能](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD)。\n\n::: tip\n请勿同时使用 `.passive` 和 `.prevent`，因为 `.passive` 已经向浏览器表明了你*不想*阻止事件的默认行为。如果你这么做了，则 `.prevent` 会被忽略，并且浏览器会抛出警告。\n:::\n\n## 按键修饰符 {#key-modifiers}\n\n在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 `v-on` 或 `@` 监听按键事件时添加按键修饰符。\n\n```vue-html\n<!-- 仅在 `key` 为 `Enter` 时调用 `submit` -->\n<input @keyup.enter=\"submit\" />\n```\n\n你可以直接使用 [`KeyboardEvent.key`](https://developer.mozilla.org/zh-CN/docs/Web/API/UI_Events/Keyboard_event_key_values) 暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。\n\n```vue-html\n<input @keyup.page-down=\"onPageDown\" />\n```\n\n在上面的例子中，仅会在 `$event.key` 为 `'PageDown'` 时调用事件处理。\n\n### 按键别名 {#key-aliases}\n\nVue 为一些常用的按键提供了别名：\n\n- `.enter`\n- `.tab`\n- `.delete` (捕获“Delete”和“Backspace”两个按键)\n- `.esc`\n- `.space`\n- `.up`\n- `.down`\n- `.left`\n- `.right`\n\n### 系统按键修饰符 {#system-modifier-keys}\n\n你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。\n\n- `.ctrl`\n- `.alt`\n- `.shift`\n- `.meta`\n\n::: tip 注意\n在 Mac 键盘上，meta 是 Command 键 (⌘)。在 Windows 键盘上，meta 键是 Windows 键 (⊞)。在 Sun 微机系统键盘上，meta 是钻石键 (◆)。在某些键盘上，特别是 MIT 和 Lisp 机器的键盘及其后代版本的键盘，如 Knight 键盘，space-cadet 键盘，meta 都被标记为“META”。在 Symbolics 键盘上，meta 也被标识为“META”或“Meta”。\n:::\n\n举例来说：\n\n```vue-html\n<!-- Alt + Enter -->\n<input @keyup.alt.enter=\"clear\" />\n\n<!-- Ctrl + 点击 -->\n<div @click.ctrl=\"doSomething\">Do something</div>\n```\n\n::: tip\n请注意，系统按键修饰符和常规按键不同。与 `keyup` 事件一起使用时，该按键必须在事件发出时处于按下状态。换句话说，`keyup.ctrl` 只会在你仍然按住 `ctrl` 但松开了另一个键时被触发。若你单独松开 `ctrl` 键将不会触发。\n:::\n\n### `.exact` 修饰符 {#exact-modifier}\n\n`.exact` 修饰符允许精确控制触发事件所需的系统修饰符的组合。\n\n```vue-html\n<!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 -->\n<button @click.ctrl=\"onClick\">A</button>\n\n<!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 -->\n<button @click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- 仅当没有按下任何系统按键时触发 -->\n<button @click.exact=\"onClick\">A</button>\n```\n\n## 鼠标按键修饰符 {#mouse-button-modifiers}\n\n- `.left`\n- `.right`\n- `.middle`\n\n这些修饰符将处理程序限定为由特定鼠标按键触发的事件。\n\n但请注意，`.left`，`.right` 和 `.middle` 这些修饰符名称是基于常见的右手用鼠标布局设定的，但实际上它们分别指代设备事件触发器的“主”、”次“，“辅助”，而非实际的物理按键。因此，对于左手用鼠标布局而言，“主”按键在物理上可能是右边的按键，但却会触发 `.left` 修饰符对应的处理程序。又或者，触控板可能通过单指点击触发 `.left` 处理程序，通过双指点击触发 `.right` 处理程序，通过三指点击触发 `.middle` 处理程序。同样，产生“鼠标”事件的其他设备和事件源，也可能具有与“左”，“右”完全无关的触发模式。\n\n<!-- zhlint disabled -->\n\n\n\n================================================\nFILE: src/guide/essentials/forms.md\n================================================\n---\noutline: deep\n---\n\n<script setup>\nimport { ref } from 'vue'\nconst message = ref('')\nconst multilineText = ref('')\nconst checked = ref(false)\nconst checkedNames = ref([])\nconst picked = ref('')\nconst selected = ref('')\nconst multiSelected = ref([])\nconst dynamicSelected = ref('A')\nconst options = ref([\n  { text: 'One', value: 'A' },\n  { text: 'Two', value: 'B' },\n  { text: 'Three', value: 'C' }\n])\n</script>\n\n# 表单输入绑定 {#form-input-bindings}\n\n在前端处理表单时，我们常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦：\n\n```vue-html\n<input\n  :value=\"text\"\n  @input=\"event => text = event.target.value\">\n```\n\n`v-model` 指令帮我们简化了这一步骤：\n\n```vue-html\n<input v-model=\"text\">\n```\n\n另外，`v-model` 还可以用于各种不同类型的输入，`<textarea>`、`<select>` 元素。它会根据所使用的元素自动使用对应的 DOM 属性和事件组合：\n\n- 文本类型的 `<input>` 和 `<textarea>` 元素会绑定 `value` property 并侦听 `input` 事件；\n- `<input type=\"checkbox\">` 和 `<input type=\"radio\">` 会绑定 `checked` property 并侦听 `change` 事件；\n- `<select>` 会绑定 `value` property 并侦听 `change` 事件。\n\n::: tip 注意\n`v-model` 会忽略任何表单元素上初始的 `value`、`checked` 或 `selected` attribute。它将始终将当前绑定的 JavaScript 状态视为数据的正确来源。你应该在 JavaScript 中使用<span class=\"options-api\"> [`data`](/api/options-state.html#data) 选项</span><span class=\"composition-api\">[响应式系统的 API](/api/reactivity-core.html#reactivity-api-core) </span>来声明该初始值。\n:::\n\n## 基本用法 {#basic-usage}\n\n### 文本 {#text}\n\n```vue-html\n<p>Message is: {{ message }}</p>\n<input v-model=\"message\" placeholder=\"edit me\" />\n```\n\n<div class=\"demo\">\n  <p>Message is: {{ message }}</p>\n  <input v-model=\"message\" placeholder=\"edit me\" />\n</div>\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNo9jUEOgyAQRa8yYUO7aNkbNOkBegM2RseWRGACoxvC3TumxuX/+f+9ql5Ez31D1SlbpuyJoSBvNLjoA6XMUCHjAg2WnAJomWoXXZxSLAwBSxk/CP2xuWl9d9GaP0YAEhgDrSOjJABLw/s8+NJBrde/NWsOpWPrI20M+yOkGdfeqXPiFAhowm9aZ8zS4+wPv/RGjtZcJtV+YpNK1g==)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNo9jdEKwjAMRX8l9EV90L2POvAD/IO+lDVqoetCmw6h9N/NmBuEJPeSc1PVg+i2FFS90nlMnngwEb80JwaHL1sCQzURwFm258u2AyTkkuKuACbM2b6xh9Nps9o6pEnp7ggWwThRsIyiADQNz40En3uodQ+C1nRHK8HaRyoMy3WaHYa7Uf8To0CCRvzMwWESH51n4cXvBNTd8Um1H0FuTq0=)\n\n</div>\n\n<span id=\"vmodel-ime-tip\"></span>\n::: tip 注意\n对于需要使用 [IME](https://en.wikipedia.org/wiki/Input_method) 的语言 (中文，日文和韩文等)，你会发现 `v-model` 不会在 IME 输入还在拼字阶段时触发更新。如果你的确想在拼字阶段也触发更新，请直接使用自己的 `input` 事件监听器和 `value` 绑定而不要使用 `v-model`。\n:::\n\n### 多行文本 {#multiline-text}\n\n```vue-html\n<span>Multiline message is:</span>\n<p style=\"white-space: pre-line;\">{{ message }}</p>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n```\n\n<div class=\"demo\">\n  <span>Multiline message is:</span>\n  <p style=\"white-space: pre-line;\">{{ multilineText }}</p>\n  <textarea v-model=\"multilineText\" placeholder=\"add multiple lines\"></textarea>\n</div>\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNo9jktuwzAMRK9CaON24XrvKgZ6gN5AG8FmGgH6ECKdJjB891D5LYec9zCb+SH6Oq9oRmN5roEEGGWlyeWQqFSBDSoeYYdjLQk6rXYuuzyXzAIJmf0fwqF1Prru02U7PDQq0CCYKHrBlsQy+Tz9rlFCDBnfdOBRqfa7twhYrhEPzvyfgmCvnxlHoIp9w76dmbbtDe+7HdpaBQUv4it6OPepLBjV8Gw5AzpjxlOJC1a9+2WB1IZQRGhWVqsdXgb1tfDcbvYbJDRqLQ==)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNo9jk2OwyAMha9isenMIpN9hok0B+gN2FjBbZEIscDpj6LcvaZpKiHg2X6f32L+mX+uM5nO2DLkwNK7RHeesoCnE85RYHEJwKPg1/f2B8gkc067AhipFDxTB4fDVlrro5ce237AKoRGjihUldjCmPqjLgkxJNoxEEqnrtp7TTEUeUT6c+Z2CUKNdgbdxZmaavt1pl+Wj3ldbcubUegumAnh2oyTp6iE95QzoDEGukzRU9Y6eg9jDcKRoFKLUm27E5RXxTu7WZ89/G4E)\n\n</div>\n\n注意在 `<textarea>` 中是不支持插值表达式的。请使用 `v-model` 来替代：\n\n```vue-html\n<!-- 错误 -->\n<textarea>{{ text }}</textarea>\n\n<!-- 正确 -->\n<textarea v-model=\"text\"></textarea>\n```\n\n### 复选框 {#checkbox}\n\n单一的复选框，绑定布尔类型值：\n\n```vue-html\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" />\n<label for=\"checkbox\">{{ checked }}</label>\n```\n\n<div class=\"demo\">\n  <input type=\"checkbox\" id=\"checkbox-demo\" v-model=\"checked\" />\n  <label for=\"checkbox-demo\">{{ checked }}</label>\n</div>\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpVjssKgzAURH/lko3tonVfotD/yEaTKw3Ni3gjLSH/3qhUcDnDnMNk9gzhviRkD8ZnGXUgmJFS6IXTNvhIkCHiBAWm6C00ddoIJ5z0biaQL5RvVNCtmwvFhFfheLuLqqIGQhvMQLgm4tqFREDfgJ1gGz36j2Cg1TkvN+sVmn+JqnbtrjDDiAYmH09En/PxphTebqsK8PY4wMoPslBUxQ==)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpVjtEKgzAMRX8l9Gl72Po+OmH/0ZdqI5PVNnSpOEr/fVVREEKSc0kuN4sX0X1KKB5Cfbs4EDfa40whMljsTXIMWXsAa9hcrtsOEJFT9DsBdG/sPmgfwDHhJpZl1FZLycO6AuNIzjAuxGrwlBj4R/jUYrVpw6wFDPbM020MFt0uoq2a3CycadFBH+Lpo8l5jwWlKLle1QcljwCi/AH7gFic)\n\n</div>\n\n我们也可以将多个复选框绑定到同一个数组或[集合](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)的值：\n\n<div class=\"composition-api\">\n\n```js\nconst checkedNames = ref([])\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  data() {\n    return {\n      checkedNames: []\n    }\n  }\n}\n```\n\n</div>\n\n```vue-html\n<div>Checked names: {{ checkedNames }}</div>\n\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\" />\n<label for=\"jack\">Jack</label>\n\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\" />\n<label for=\"john\">John</label>\n\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\" />\n<label for=\"mike\">Mike</label>\n```\n\n<div class=\"demo\">\n  <div>Checked names: {{ checkedNames }}</div>\n\n  <input type=\"checkbox\" id=\"demo-jack\" value=\"Jack\" v-model=\"checkedNames\" />\n  <label for=\"demo-jack\">Jack</label>\n\n  <input type=\"checkbox\" id=\"demo-john\" value=\"John\" v-model=\"checkedNames\" />\n  <label for=\"demo-john\">John</label>\n\n  <input type=\"checkbox\" id=\"demo-mike\" value=\"Mike\" v-model=\"checkedNames\" />\n  <label for=\"demo-mike\">Mike</label>\n</div>\n\n在这个例子中，`checkedNames` 数组将始终包含所有当前被选中的框的值。\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqVkUtqwzAURbfy0CTtoNU8KILSWaHdQNWBIj8T1fohyybBeO+RbOc3i2e+vHvuMWggHyG89x2SLWGtijokaDF1gQunbfAxwQARaxihjt7CJlc3wgmnvGsTqAOqBqsfabGFXSm+/P69CsfovJVXckhog5EJcwJgle7558yBK+AWhuFxaRwZLbVCZ0K70CVIp4A7Qabi3h8FAV3l/C9Vk797abpy/lrim/UVmkt/Gc4HOv+EkXs0UPt4XeCFZHQ6lM4TZn9w9+YlrjFPCC/kKrPVDd6Zv5e4wjwv8ELezIxeX4qMZwHduAs=)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqVUc1qxCAQfpXBU3tovS9WKL0V2hdoenDjLGtjVNwxbAl592rMpru3DYjO5/cnOLLXEJ6HhGzHxKmNJpBsHJ6DjwQaDypZgrFxAFqRenisM0BEStFdEEB7xLZD/al6PO3g67veT+XIW16Cr+kZEPbBKsKMAIQ2g3yrAeBqwjjeRMI0CV5kxZ0dxoVEQL8BXxo2C/f+3DAwOuMf1XZ5HpRNhX5f4FPvNdqLfgnOBK+PsGqPFg4+rgmyOAWfiaK5o9kf3XXzArc0zxZZnJuae9PhVfPHAjc01wRZnP/Ngq8/xaY/yMW74g==)\n\n</div>\n\n### 单选按钮 {#radio}\n\n```vue-html\n<div>Picked: {{ picked }}</div>\n\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" />\n<label for=\"one\">One</label>\n\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" />\n<label for=\"two\">Two</label>\n```\n\n<div class=\"demo\">\n  <div>Picked: {{ picked }}</div>\n\n  <input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" />\n  <label for=\"one\">One</label>\n\n  <input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" />\n  <label for=\"two\">Two</label>\n</div>\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqFkDFuwzAMRa9CaHE7tNoDxUBP0A4dtTgWDQiRJUKmHQSG7x7KhpMMAbLxk3z/g5zVD9H3NKI6KDO02RPDgDxSbaPvKWWGGTJ2sECXUw+VrFY22timODCQb8/o4FhWPqrfiNWnjUZvRmIhgrGn0DCKAjDOT/XfCh1gnnd+WYwukwJYNj7SyMBXwqNVuXE+WQXeiUgRpZyaMJaR5BX11SeHQfTmJi1dnNiE5oQBupR3shbC6LX9Posvpdyz/jf1OksOe85ayVqIR5bR9z+o5Qbc6oCk)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNqNkEEOAiEMRa/SsFEXyt7gJJ5AFy5ng1ITIgLBMmomc3eLOONSEwJ9Lf//pL3YxrjqMoq1ULdTspGa1uMjhkRg8KyzI+hbD2A06fmi1gAJKSc/EkC0pwuaNcx2Hme1OZSHLz5KTtYMhNfoNGEhUsZ2zf6j7vuPEQyDkmVSBPzJ+pgJ6Blx04qkjQ2tAGsYgkcuO+1yGXF6oeU1GHTM1Y1bsoY5fUQH55BGZcMKJd/t31l0L+WYdaj0V9Zb2bDim6XktAcxvADR+YWb)\n\n</div>\n\n### 选择器 {#select}\n\n单个选择器的示例如下：\n\n```vue-html\n<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\">\n  <option disabled value=\"\">Please select one</option>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n```\n\n<div class=\"demo\">\n  <div>Selected: {{ selected }}</div>\n  <select v-model=\"selected\">\n    <option disabled value=\"\">Please select one</option>\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n</div>\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp1j7EOgyAQhl/lwmI7tO4Nmti+QJOuLFTPxASBALoQ3r2H2jYOjvff939wkTXWXucJ2Y1x37rBBvAYJlsLPYzWuAARHPaQoHdmhILQQmihW6N9RhW2ATuoMnQqirPQvFw9ZKAh4GiVDEgTAPdW6hpeW+sGMf4VKVEz73Mvs8sC5stoOlSVYF9SsEVGiLFhMBq6wcu3IsUs1YREEvFUKD1udjAaebnS+27dHOT3g/yxy+nHywM08PJ3KksfXwJ2dA==)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp1j1ELgyAUhf/KxZe2h633cEHbHxjstReXdxCYSt5iEP333XIJPQSinuN3jjqJyvvrOKAohAxN33oqa4tf73oCjR81GIKptgBakTqd4x6gRxp6uymAgAYbQl1AlkVvXhaeeMg8NbMg7LxRhKwAZPDKlvBK8WlKXTDPnFzOI7naMF46p9HcarFxtVgBRpyn1lnQbVBvwwWjMgMyycTToAr47wZnUeaR3mfL6sC/H/iPnc/vXS9gIfP0UTH/ACgWeYE=)\n\n</div>\n\n:::tip 注意\n如果 `v-model` 表达式的初始值不匹配任何一个选择项，`<select>` 元素会渲染成一个“未选择”的状态。在 iOS 上，这将导致用户无法选择第一项，因为 iOS 在这种情况下不会触发一个 change 事件。因此，我们建议提供一个空值的禁用选项，如上面的例子所示。\n:::\n\n多选 (值绑定到一个数组)：\n\n```vue-html\n<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n```\n\n<div class=\"demo\">\n  <div>Selected: {{ multiSelected }}</div>\n\n  <select v-model=\"multiSelected\" multiple>\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n</div>\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp1kL2OwjAQhF9l5Ya74i7QBhMJeARKTIESIyz5Z5VsAsjyu7NOQEBB5xl/M7vaKNaI/0OvRSlkV7cGCTpNPVbKG4ehJYjQ6hMkOLXBwYzRmfLK18F3GbW6Jt3AKkM/+8Ov8rKYeriBBWmH9kiaFYBszFDtHpkSYnwVpCSL/JtDDE4+DH8uNNqulHiCSoDrLRm0UyWzAckEX61l8Xh9+psv/vbD563HCSxk8bY0y45u47AJ2D/HHyDm4MU0dC5hMZ/jdal8Gg8wJkS6A3nRew4=)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp1UEEOgjAQ/MqmJz0oeMVKgj7BI3AgdI1NCjSwIIbwdxcqRA4mTbsznd2Z7CAia49diyIQsslrbSlMSuxtVRMofGStIRiSEkBllO32rgaokdq6XBBAgwZzQhVAnDpunB6++EhvncyAsLAmI2QEIJXuwvvaPAzrJBhH6U2/UxMLHQ/doagUmksiFmEioOCU2ho3krWVJV2VYSS9b7Xlr3/424bn1LMDA+n9hGbY0Hs2c4J4sU/dPl5a0TOAk+/b/rwsYO4Q4wdtRX7l)\n\n</div>\n\n选择器的选项可以使用 `v-for` 动态渲染：\n\n<div class=\"composition-api\">\n\n```js\nconst selected = ref('A')\n\nconst options = ref([\n  { text: 'One', value: 'A' },\n  { text: 'Two', value: 'B' },\n  { text: 'Three', value: 'C' }\n])\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  data() {\n    return {\n      selected: 'A',\n      options: [\n        { text: 'One', value: 'A' },\n        { text: 'Two', value: 'B' },\n        { text: 'Three', value: 'C' }\n      ]\n    }\n  }\n}\n```\n\n</div>\n\n```vue-html\n<div>Selected: {{ selected }}</div>\n\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" :value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>\n```\n<div class=\"demo\">\n  <div>Selected: {{ dynamicSelected }}</div>\n  \n  <select v-model=\"dynamicSelected\">\n    <option v-for=\"option in options\" :value=\"option.value\">\n      {{ option.text }}\n    </option>\n  </select>\n</div>\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9kj9vwjAQxb/KyUtaiYahGwpIgBjaoVSFre6AkguEOnZkOwEpynfv2flDqlZkyt37+fye7ZotiyKsSmQzFplYZ4UFg7YsFlxmeaG0hRo0ptBAqlUOAaEBl1zGShqHCowtJjB30EOwDB5voipsRj+d9skl0CyLVzuDYCsxmEB1ECVStQygmfzS9xc10ld/9ZPG8YQ1EVx+0e7RtI1BAaiwmBfiYNFVNkqyarHrLM+grm/+myaaOtUtAojaPlRPuUpQzDnrQc4IAfqiNh0hqdIEdGUm+9icwcy7G8TQl8MESlN3cOhSkYdu9LTteo7i+K2piKZDGjZh1tApp9kxPBsl6fZqR3MWq7zIBOpt74JytmM5OwihLq++Z3WJ/kT9mhPG3//0z+bqepy9azSoK/I+aPagj2hbebN7I/8jkU6tFETfET/QKFE6jy22KmVCtkecd/vi32Amj3uzuVqUpg/ljDqyfRec0btc34l+s/scPvt1XDas+QENov3B)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9ksFuwjAMhl/FyoVNYuWwG+omAeKwHcY0uC07VK2BspBUiVuQKt59Tkq6Hjakqortz87/J2nFrKqSpkYxFanLbVnRs9R4rowlKHCb1YqglRqgyCi7u+/WABaptjpGAA4V5oTFFEaz0ThmTUWl0W4KnzED0ALhmZhbaRyNoclUjaELLn3fgNqczICa/0ftLQ6nLZiL2Fe3CDH/+EsnvVMOCI+Vygh9RGlRNs/r3kzb9s7gckknvuqbANIuD83D0RSonqSIoBSM+B3Tzj4jW2MZuIaljuciBUyD4r6YhLCfwA7bK5x4p6zhOnrSZQPHdsLWHKST3o0YC3K50dtylxyc0XzB4bakyM2xKhXaVVTBPruxUmRKmdNryJGt8XrW3LPH/PuP/MGdfU6Kd4sObcPa+xpldofUlZfrN9Y/KPKp1YrpG8UPdEbVXmOHzWtdsOwBF9S+HP1jLfVu45ZnQu2iKS80XHrgpeBXvrhh/VfuY/IYH4u4/AD+8ADR)\n\n</div>\n\n## 值绑定 {#value-bindings}\n\n对于单选按钮，复选框和选择器选项，`v-model` 绑定的值通常是静态的字符串 (或者对复选框是布尔值)：\n\n```vue-html\n<!-- `picked` 在被选择时是字符串 \"a\" -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\" />\n\n<!-- `toggle` 只会为 true 或 false -->\n<input type=\"checkbox\" v-model=\"toggle\" />\n\n<!-- `selected` 在第一项被选中时为字符串 \"abc\" -->\n<select v-model=\"selected\">\n  <option value=\"abc\">ABC</option>\n</select>\n```\n\n但有时我们可能希望将该值绑定到当前组件实例上的动态数据。这可以通过使用 `v-bind` 来实现。此外，使用 `v-bind` 还使我们可以将选项值绑定为非字符串的数据类型。\n\n### 复选框 {#checkbox-1}\n\n```vue-html\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  true-value=\"yes\"\n  false-value=\"no\" />\n```\n\n`true-value` 和 `false-value` 是 Vue 特有的 attributes，仅支持和 `v-model` 配套使用。这里 `toggle` 属性的值会在选中时被设为 `'yes'`，取消选择时设为 `'no'`。你同样可以通过 `v-bind` 将其绑定为其他动态值：\n\n```vue-html\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  :true-value=\"dynamicTrueValue\"\n  :false-value=\"dynamicFalseValue\" />\n```\n\n:::tip 提示\n`true-value` 和 `false-value` attributes 不会影响 `value` attribute，因为浏览器在表单提交时，并不会包含未选择的复选框。为了保证这两个值 (例如：“yes”和“no”) 的其中之一被表单提交，请使用单选按钮作为替代。\n:::\n\n### 单选按钮 {#radio-1}\n\n```vue-html\n<input type=\"radio\" v-model=\"pick\" :value=\"first\" />\n<input type=\"radio\" v-model=\"pick\" :value=\"second\" />\n```\n\n`pick` 会在第一个按钮选中时被设为 `first`，在第二个按钮选中时被设为 `second`。\n\n### 选择器选项 {#select-options-2}\n\n```vue-html\n<select v-model=\"selected\">\n  <!-- 内联对象字面量 -->\n  <option :value=\"{ number: 123 }\">123</option>\n</select>\n```\n\n`v-model` 同样也支持非字符串类型的值绑定！在上面这个例子中，当某个选项被选中，`selected` 会被设为该对象字面量值 `{ number: 123 }`。\n\n## 修饰符 {#modifiers}\n\n### `.lazy` {#lazy}\n\n默认情况下，`v-model` 会在每次 `input` 事件后更新数据 ([IME 拼字阶段的状态](#vmodel-ime-tip)例外)。你可以添加 `lazy` 修饰符来改为在每次 `change` 事件后更新数据：\n\n```vue-html\n<!-- 在 \"change\" 事件后同步更新而不是 \"input\" -->\n<input v-model.lazy=\"msg\" />\n```\n\n### `.number` {#number}\n\n如果你想让用户输入自动转换为数字，你可以在 `v-model` 后添加 `.number` 修饰符来管理输入：\n\n```vue-html\n<input v-model.number=\"age\" />\n```\n\n如果该值无法被 `parseFloat()` 处理，那么将返回原始值。特别是当输入为空时 (例如用户清空输入字段之后)，会返回一个空字符串。这种行为与 [DOM 属性 valueAsNumber](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLInputElement#valueasnumber) 有所不同。\n\n`number` 修饰符会在输入框有 `type=\"number\"` 时自动启用。\n\n### `.trim` {#trim}\n\n如果你想要默认自动去除用户输入内容中两端的空格，你可以在 `v-model` 后添加 `.trim` 修饰符：\n\n```vue-html\n<input v-model.trim=\"msg\" />\n```\n\n## 组件上的 `v-model` {#v-model-with-components}\n\n> 如果你还不熟悉 Vue 的组件，那么现在可以跳过这个部分。\n\nHTML 的内置表单输入类型并不总能满足所有需求。幸运的是，我们可以使用 Vue 构建具有自定义行为的可复用输入组件，并且这些输入组件也支持 `v-model`！要了解更多关于此的内容，请在组件指引中阅读[配合 `v-model` 使用](/guide/components/v-model)。\n\n\n\n================================================\nFILE: src/guide/essentials/lifecycle.md\n================================================\n# 生命周期钩子 {#lifecycle-hooks}\n\n每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。\n\n## 注册周期钩子 {#registering-lifecycle-hooks}\n\n举例来说，<span class=\"composition-api\">`onMounted`</span><span class=\"options-api\">`mounted`</span> 钩子可以用来在组件完成初始渲染并创建 DOM 节点后运行代码：\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nimport { onMounted } from 'vue'\n\nonMounted(() => {\n  console.log(`the component is now mounted.`)\n})\n</script>\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  mounted() {\n    console.log(`the component is now mounted.`)\n  }\n}\n```\n\n</div>\n\n还有其他一些钩子，会在实例生命周期的不同阶段被调用，最常用的是 <span class=\"composition-api\">[`onMounted`](/api/composition-api-lifecycle#onmounted)、[`onUpdated`](/api/composition-api-lifecycle#onupdated) 和 [`onUnmounted`](/api/composition-api-lifecycle#onunmounted)。所有生命周期钩子的完整参考及其用法请参考 [API 索引](/api/composition-api-lifecycle.html)。</span><span class=\"options-api\">[`mounted`](/api/options-lifecycle#mounted)、[`updated`](/api/options-lifecycle#updated) 和 [`unmounted`](/api/options-lifecycle#unmounted)。</span>\n\n<div class=\"options-api\">\n\n所有生命周期钩子函数的 `this` 上下文都会自动指向当前调用它的组件实例。注意：避免用箭头函数来定义生命周期钩子，因为如果这样的话你将无法在函数中通过 `this` 获取组件实例。\n\n</div>\n\n<div class=\"composition-api\">\n\n当调用 `onMounted` 时，Vue 会自动将回调函数注册到当前正被初始化的组件实例上。这意味着这些钩子应当在组件初始化时被**同步**注册。例如，请不要这样做：\n\n```js\nsetTimeout(() => {\n  onMounted(() => {\n    // 异步注册时当前组件实例已丢失\n    // 这将不会正常工作\n  })\n}, 100)\n```\n\n注意这并不意味着对 `onMounted` 的调用必须放在 `setup()` 或 `<script setup>` 内的词法上下文中。`onMounted()` 也可以在一个外部函数中调用，只要调用栈是同步的，且最终起源自 `setup()` 就可以。\n\n</div>\n\n## 生命周期图示 {#lifecycle-diagram}\n\n下面是实例生命周期的图表。你现在并不需要完全理解图中的所有内容，但以后它将是一个有用的参考。\n\n![组件生命周期图示](./images/lifecycle_zh-CN.png)\n\n<!-- https://www.figma.com/file/Xw3UeNMOralY6NV7gSjWdS/Vue-Lifecycle -->\n<!-- https://www.figma.com/file/QHo4ehJ4TRx3f7gzRP1F1k/Vue-Lifecycle-(zh-CN) -->\n\n有关所有生命周期钩子及其各自用例的详细信息，请参考<span class=\"composition-api\">[生命周期钩子 API 索引](/api/composition-api-lifecycle)</span><span class=\"options-api\">[生命周期钩子 API 索引](/api/options-lifecycle)</span>。\n\n\n\n================================================\nFILE: src/guide/essentials/list.md\n================================================\n# 列表渲染 {#list-rendering}\n\n## `v-for` {#v-for}\n\n我们可以使用 `v-for` 指令基于一个数组来渲染一个列表。`v-for` 指令的值需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据的数组，而 `item` 是迭代项的**别名**：\n\n<div class=\"composition-api\">\n\n```js\nconst items = ref([{ message: 'Foo' }, { message: 'Bar' }])\n```\n\n</div>\n\n<div class=\"options-api\">\n\n```js\ndata() {\n  return {\n    items: [{ message: 'Foo' }, { message: 'Bar' }]\n  }\n}\n```\n\n</div>\n\n```vue-html\n<li v-for=\"item in items\">\n  {{ item.message }}\n</li>\n```\n\n在 `v-for` 块中可以完整地访问父作用域内的属性和变量。`v-for` 也支持使用可选的第二个参数表示当前项的位置索引。\n\n<div class=\"composition-api\">\n\n```js\nconst parentMessage = ref('Parent')\nconst items = ref([{ message: 'Foo' }, { message: 'Bar' }])\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\ndata() {\n  return {\n    parentMessage: 'Parent',\n    items: [{ message: 'Foo' }, { message: 'Bar' }]\n  }\n}\n```\n\n</div>\n\n```vue-html\n<li v-for=\"(item, index) in items\">\n  {{ parentMessage }} - {{ index }} - {{ item.message }}\n</li>\n```\n\n<script setup>\nconst parentMessage = 'Parent'\nconst items = [{ message: 'Foo' }, { message: 'Bar' }]\n</script>\n<div class=\"demo\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</div>\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpdTsuqwjAQ/ZVDNlFQu5d64bpwJ7g3LopOJdAmIRlFCPl3p60PcDWcM+eV1X8Iq/uN1FrV6RxtYCTiW/gzzvbBR0ZGpBYFbfQ9tEi1ccadvUuM0ERyvKeUmithMyhn+jCSev4WWaY+vZ7HjH5Sr6F33muUhTR8uW0ThTuJua6mPbJEgGSErmEaENedxX3Z+rgxajbEL2DdhR5zOVOdUSIEDOf8M7IULCHsaPgiMa1eK4QcS6rOSkhdfapVeQLQEWnH)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpVTssKwjAQ/JUllyr0cS9V0IM3wbvxEOxWAm0a0m0phPy7m1aqhpDsDLMz48XJ2nwaUZSiGp5OWzpKg7PtHUGNjRpbAi8NQK1I7fbrLMkhjc5EJAn4WOXQ0BWHQb2whOS24CSN6qjXhN1Qwt1Dt2kufZ9ASOGXOyvH3GMNCdGdH75VsZVjwGa2VYQRUdVqmLKmdwcpdjEnBW1qnPf8wZIrBQujoff/RSEEyIDZZeGLeCn/dGJyCSlazSZVsUWL8AYme21i)\n\n</div>\n\n`v-for` 变量的作用域和下面的 JavaScript 代码很类似：\n\n```js\nconst parentMessage = 'Parent'\nconst items = [\n  /* ... */\n]\n\nitems.forEach((item, index) => {\n  // 可以访问外层的 `parentMessage`\n  // 而 `item` 和 `index` 只在这个作用域可用\n  console.log(parentMessage, item.message, index)\n})\n```\n\n注意 `v-for` 是如何对应 `forEach` 回调的函数签名的。实际上，你也可以在定义 `v-for` 的变量别名时使用解构，和解构函数参数类似：\n\n```vue-html\n<li v-for=\"{ message } in items\">\n  {{ message }}\n</li>\n\n<!-- 有 index 索引时 -->\n<li v-for=\"({ message }, index) in items\">\n  {{ message }} {{ index }}\n</li>\n```\n\n对于多层嵌套的 `v-for`，作用域的工作方式和函数的作用域很类似。每个 `v-for` 作用域都可以访问到父级作用域：\n\n```vue-html\n<li v-for=\"item in items\">\n  <span v-for=\"childItem in item.children\">\n    {{ item.message }} {{ childItem }}\n  </span>\n</li>\n```\n\n你也可以使用 `of` 作为分隔符来替代 `in`，这更接近 JavaScript 的迭代器语法：\n\n```vue-html\n<div v-for=\"item of items\"></div>\n```\n\n## `v-for` 与对象 {#v-for-with-an-object}\n\n你也可以使用 `v-for` 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 `Object.values()` 的返回值来决定。\n\n<div class=\"composition-api\">\n\n```js\nconst myObject = reactive({\n  title: 'How to do lists in Vue',\n  author: 'Jane Doe',\n  publishedAt: '2016-04-10'\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\ndata() {\n  return {\n    myObject: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n}\n```\n\n</div>\n\n```vue-html\n<ul>\n  <li v-for=\"value in myObject\">\n    {{ value }}\n  </li>\n</ul>\n```\n\n可以通过提供第二个参数表示属性名 (例如 key)：\n\n```vue-html\n<li v-for=\"(value, key) in myObject\">\n  {{ key }}: {{ value }}\n</li>\n```\n\n第三个参数表示位置索引：\n\n```vue-html\n<li v-for=\"(value, key, index) in myObject\">\n  {{ index }}. {{ key }}: {{ value }}\n</li>\n```\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNo9jjFvgzAQhf/KE0sSCQKpqg7IqRSpQ9WlWycvBC6KW2NbcKaNEP+9B7Tx4nt33917Y3IKYT9ESspE9XVnAqMnjuFZO9MG3zFGdFTVbAbChEvnW2yE32inXe1dz2hv7+dPqhnHO7kdtQPYsKUSm1f/DfZoPKzpuYdx+JAL6cxUka++E+itcoQX/9cO8SzslZoTy+yhODxlxWN2KMR22mmn8jWrpBTB1AZbMc2KVbTyQ56yBkN28d1RJ9uhspFSfNEtFf+GfnZzjP/oOll2NQPjuM4xTftZyIaU5VwuN0SsqMqtWZxUvliq/J4jmX4BTCp08A==)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNo9T8FqwzAM/RWRS1pImnSMHYI3KOwwdtltJ1/cRqXe3Ng4ctYS8u+TbVJjLD3rPelpLg7O7aaARVeI8eS1ozc54M1ZT9DjWQVDMMsBoFekNtucS/JIwQ8RSQI+1/vX8QdP1K2E+EmaDHZQftg/IAu9BaNHGkEP8B2wrFYxgAp0sZ6pn2pAeLepmEuSXDiy7oL9gduXT+3+pW6f631bZoqkJY/kkB6+onnswoDw6owijIhEMByjUBgNU322/lUWm0mZgBX84r1ifz3ettHmupYskjbanedch2XZRcAKTnnvGVIPBpkqGqPTJNGkkaJ5+CiWf4KkfBs=)\n\n</div>\n\n## 在 `v-for` 里使用范围值 {#v-for-with-a-range}\n\n`v-for` 可以直接接受一个整数值。在这种用例中，会将该模板基于 `1...n` 的取值范围重复多次。\n\n```vue-html\n<span v-for=\"n in 10\">{{ n }}</span>\n```\n\n注意此处 `n` 的初值是从 `1` 开始而非 `0`。\n\n## `<template>` 上的 `v-for` {#v-for-on-template}\n\n与模板上的 `v-if` 类似，你也可以在 `<template>` 标签上使用 `v-for` 来渲染一个包含多个元素的块。例如：\n\n```vue-html\n<ul>\n  <template v-for=\"item in items\">\n    <li>{{ item.msg }}</li>\n    <li class=\"divider\" role=\"presentation\"></li>\n  </template>\n</ul>\n```\n\n## `v-for` 与 `v-if` {#v-for-with-v-if}\n\n当它们同时存在于一个节点上时，`v-if` 比 `v-for` 的优先级更高。这意味着 `v-if` 的条件将无法访问到 `v-for` 作用域内定义的变量别名：\n\n```vue-html\n<!--\n 这会抛出一个错误，因为属性 todo 此时\n 没有在该实例上定义\n-->\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n  {{ todo.name }}\n</li>\n```\n\n在外先包装一层 `<template>` 再在其上使用 `v-for` 可以解决这个问题 (这也更加明显易读)：\n\n```vue-html\n<template v-for=\"todo in todos\">\n  <li v-if=\"!todo.isComplete\">\n    {{ todo.name }}\n  </li>\n</template>\n```\n\n:::warning 注意\n同时使用 `v-if` 和 `v-for` 是**不推荐的**，因为这样二者的优先级不明显。\n\n两种常见的情况可能导致这种用法：\n\n- 过滤列表中的项目 (例如，`v-for=\"user in users\" v-if=\"user.isActive\"`)。在这种情况下，可以用一个新的计算属性来替换 `users`，该属性返回过滤后的列表 (例如 `activeUsers`)。\n\n- 避免渲染应该隐藏的列表 (例如 `v-for=\"user in users\" v-if=\"shouldShowUsers\"`)。在这种情况下，将 `v-if` 移至容器元素 (如 `ul`、`ol`)。\n:::\n\n## 通过 key 管理状态 {#maintaining-state-with-key}\n\nVue 默认按照“就地更新”的策略来更新通过 `v-for` 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。\n\n默认模式是高效的，但**只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况**。\n\n为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 `key` attribute：\n\n```vue-html\n<div v-for=\"item in items\" :key=\"item.id\">\n  <!-- 内容 -->\n</div>\n```\n\n当你使用 `<template v-for>` 时，`key` 应该被放置在这个 `<template>` 容器上：\n\n```vue-html\n<template v-for=\"todo in todos\" :key=\"todo.name\">\n  <li>{{ todo.name }}</li>\n</template>\n```\n\n:::tip 注意\n`key` 在这里是一个通过 `v-bind` 绑定的特殊 attribute。请不要和[在 `v-for` 中使用对象](#v-for-with-an-object)里所提到的对象属性名相混淆。\n:::\n\n推荐在任何可行的时候为 `v-for` 提供一个 `key` attribute，除非所迭代的 DOM 内容非常简单 (例如：不包含组件或有状态的 DOM 元素)，或者你想有意采用默认行为来提高性能。\n\n`key` 绑定的值期望是一个基础类型的值，例如字符串或 number 类型。不要用对象作为 `v-for` 的 key。关于 `key` attribute 的更多用途细节，请参阅 [`key` API 文档](/api/built-in-special-attributes#key)。\n\n## 组件上使用 `v-for` {#v-for-with-a-component}\n\n> 这一小节假设你已了解[组件](/guide/essentials/component-basics)的相关知识，或者你也可以先跳过这里，之后再回来看。\n\n我们可以直接在组件上使用 `v-for`，和在一般的元素上使用没有区别 (别忘记提供一个 `key`)：\n\n```vue-html\n<MyComponent v-for=\"item in items\" :key=\"item.id\" />\n```\n\n但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还需要传递 props：\n\n```vue-html\n<MyComponent\n  v-for=\"(item, index) in items\"\n  :item=\"item\"\n  :index=\"index\"\n  :key=\"item.id\"\n/>\n```\n\n不自动将 `item` 注入组件的原因是，这会使组件与 `v-for` 的工作方式紧密耦合。明确其数据的来源可以使组件在其他情况下重用。\n\n<div class=\"composition-api\">\n\n这里是一个简单的 [Todo List 的例子](https://play.vuejs.org/#eNp1U8Fu2zAM/RXCGGAHTWx02ylwgxZYB+ywYRhyq3dwLGYRYkuCJTsZjPz7KMmK3ay9JBQfH/meKA/Rk1Jp32G0jnJdtVwZ0Gg6tSkEb5RsDQzQ4h4usG9lAzGVxldoK5n8ZrAZsTQLCduRygAKUUmhDQg8WWyLZwMPtmESx4sAGkL0mH6xrMH+AHC2hvuljw03Na4h/iLBHBAY1wfUbsTFVcwoH28o2/KIIDuaQ0TTlvrwNu/TDe+7PDlKXZ6EZxTiN4kuRI3W0dk4u4yUf7bZfScqw6WAkrEf3m+y8AOcw7Qv6w5T1elDMhs7Nbq7e61gdmme60SQAvgfIhExiSSJeeb3SBukAy1D1aVBezL5XrYN9Csp1rrbNdykqsUehXkookl0EVGxlZHX5Q5rIBLhNHFlbRD6xBiUzlOeuZJQz4XqjI+BxjSSYe2pQWwRBZizV01DmsRWeJA1Qzv0Of2TwldE5hZRlVd+FkbuOmOksJLybIwtkmfWqg+7qz47asXpSiaN3lxikSVwwfC8oD+/sEnV+oh/qcxmU85mebepgLjDBD622Mg+oDrVquYVJm7IEu4XoXKTZ1dho3gnmdJhedEymn9ab3ysDPdc4M9WKp28xE5JbB+rzz/Trm3eK3LAu8/E7p2PNzYM/i3ChR7W7L7hsSIvR7L2Aal1EhqTp80vF95sw3WcG7r8A0XaeME=)，展示了如何通过 `v-for` 来渲染一个组件列表，并向每个实例中传入不同的数据。\n\n</div>\n<div class=\"options-api\">\n\n这里是一个简单的 [Todo List 的例子](https://play.vuejs.org/#eNqNVE2PmzAQ/SsjVIlEm4C27Qmx0a7UVuqhPVS5lT04eFKsgG2BSVJF+e8d2xhIu10tihR75s2bNx9wiZ60To49RlmUd2UrtNkUUjRatQa2iquvBhvYt6qBOEmDwQbEhQQoJJ4dlOOe9bWBi7WWiuIlStNlcJlYrivr5MywxdIDAVo0fSvDDUDiyeK3eDYZxLGLsI8hI7H9DHeYQuwjeAb3I9gFCFMjUXxSYCoELroKO6fZP17Mf6jev0i1ZQcE1RtHaFrWVW/l+/Ai3zd1clQ1O8k5Uzg+j1HUZePaSFwfvdGhfNIGTaW47bV3Mc6/+zZOfaaslegS18ZE9121mIm0Ep17ynN3N5M8CB4g44AC4Lq8yTFDwAPNcK63kPTL03HR6EKboWtm0N5MvldtA8e1klnX7xphEt3ikTbpoYimsoqIwJY0r9kOa6Ag8lPeta2PvE+cA3M7k6cOEvBC6n7UfVw3imPtQ8eiouAW/IY0mElsiZWqOdqkn5NfCXxB5G6SJRvj05By1xujpJWUp8PZevLUluqP/ajPploLasmk0Re3sJ4VCMnxvKQ//0JMqrID/iaYtSaCz+xudsHjLpPzscVGHYO3SzpdixIXLskK7pcBucnTUdgg3kkmcxhetIrmH4ebr8m/n4jC6FZp+z7HTlLsVx1p4M7odcXPr6+Lnb8YOne5+C2F6/D6DH2Hx5JqOlCJ7yz7IlBTbZsf7vjXVBzjvLDrH5T0lgo=)，展示了如何通过 `v-for` 来渲染一个组件列表，并向每个实例中传入不同的数据。\n\n</div>\n\n## 数组变化侦测 {#array-change-detection}\n\n### 变更方法 {#mutation-methods}\n\nVue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括：\n\n- `push()`\n- `pop()`\n- `shift()`\n- `unshift()`\n- `splice()`\n- `sort()`\n- `reverse()`\n\n### 替换一个数组 {#replacing-an-array}\n\n变更方法，顾名思义，就是会对调用它们的原数组进行变更。相对地，也有一些不可变 (immutable) 方法，例如 `filter()`，`concat()` 和 `slice()`，这些都不会更改原数组，而总是**返回一个新数组**。当遇到的是非变更方法时，我们需要将旧的数组替换为新的：\n\n<div class=\"composition-api\">\n\n```js\n// `items` 是一个数组的 ref\nitems.value = items.value.filter((item) => item.message.match(/Foo/))\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nthis.items = this.items.filter((item) => item.message.match(/Foo/))\n```\n\n</div>\n\n你可能认为这将导致 Vue 丢弃现有的 DOM 并重新渲染整个列表——幸运的是，情况并非如此。Vue 实现了一些巧妙的方法来最大化对 DOM 元素的重用，因此用另一个包含部分重叠对象的数组来做替换，仍会是一种非常高效的操作。\n\n## 展示过滤或排序后的结果 {#displaying-filtered-sorted-results}\n\n有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性。\n\n举例来说：\n\n<div class=\"composition-api\">\n\n```js\nconst numbers = ref([1, 2, 3, 4, 5])\n\nconst evenNumbers = computed(() => {\n  return numbers.value.filter((n) => n % 2 === 0)\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\ndata() {\n  return {\n    numbers: [1, 2, 3, 4, 5]\n  }\n},\ncomputed: {\n  evenNumbers() {\n    return this.numbers.filter(n => n % 2 === 0)\n  }\n}\n```\n\n</div>\n\n```vue-html\n<li v-for=\"n in evenNumbers\">{{ n }}</li>\n```\n\n在计算属性不可行的情况下 (例如在多层嵌套的 `v-for` 循环中)，你可以使用以下方法：\n\n<div class=\"composition-api\">\n\n```js\nconst sets = ref([\n  [1, 2, 3, 4, 5],\n  [6, 7, 8, 9, 10]\n])\n\nfunction even(numbers) {\n  return numbers.filter((number) => number % 2 === 0)\n}\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\ndata() {\n  return {\n    sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]\n  }\n},\nmethods: {\n  even(numbers) {\n    return numbers.filter(number => number % 2 === 0)\n  }\n}\n```\n\n</div>\n\n```vue-html\n<ul v-for=\"numbers in sets\">\n  <li v-for=\"n in even(numbers)\">{{ n }}</li>\n</ul>\n```\n\n在计算属性中使用 `reverse()` 和 `sort()` 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本：\n\n```diff\n- return numbers.reverse()\n+ return [...numbers].reverse()\n```\n\n\n\n================================================\nFILE: src/guide/essentials/reactivity-fundamentals.md\n================================================\n---\noutline: deep\n---\n\n# 响应式基础 {#reactivity-fundamentals}\n\n:::tip API 参考\n本页和后面很多页面中都分别包含了选项式 API 和组合式 API 的示例代码。现在你选择的是 <span class=\"options-api\">选项式 API</span><span class=\"composition-api\">组合式 API</span>。你可以使用左侧侧边栏顶部的“API 风格偏好”开关在 API 风格之间切换。\n:::\n\n<div class=\"options-api\">\n\n## 声明响应式状态 \\* {#declaring-reactive-state}\n\n选用选项式 API 时，会用 `data` 选项来声明组件的响应式状态。此选项的值应为返回一个对象的函数。Vue 将在创建新组件实例的时候调用此函数，并将函数返回的对象用响应式系统进行包装。此对象的所有顶层属性都会被代理到组件实例 (即方法和生命周期钩子中的 `this`) 上。\n\n```js{2-6}\nexport default {\n  data() {\n    return {\n      count: 1\n    }\n  },\n\n  // `mounted` 是生命周期钩子，之后我们会讲到\n  mounted() {\n    // `this` 指向当前组件实例\n    console.log(this.count) // => 1\n\n    // 数据属性也可以被更改\n    this.count = 2\n  }\n}\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpFUNFqhDAQ/JXBpzsoHu2j3B2U/oYPpnGtoetGkrW2iP/eRFsPApthd2Zndilex7H8mqioimu0wY16r4W+Rx8ULXVmYsVSC9AaNafz/gcC6RTkHwHWT6IVnne85rI+1ZLr5YJmyG1qG7gIA3Yd2R/LhN77T8y9sz1mwuyYkXazcQI2SiHz/7iP3VlQexeb5KKjEKEe2lPyMIxeSBROohqxVO4E6yV6ppL9xykTy83tOQvd7tnzoZtDwhrBO2GYNFloYWLyxrzPPOi44WWLWUt618txvASUhhRCKSHgbZt2scKy7HfCujGOqWL9BVfOgyI=)\n\n这些实例上的属性仅在实例首次创建时被添加，因此你需要确保它们都出现在 `data` 函数返回的对象上。若所需的值还未准备好，在必要时也可以使用 `null`、`undefined` 或者其他一些值占位。\n\n虽然也可以不在 `data` 上定义，直接向组件实例添加新属性，但这个属性将无法触发响应式更新。\n\nVue 在组件实例上暴露的内置 API 使用 `$` 作为前缀。它同时也为内部属性保留 `_` 前缀。因此，你应该避免在顶层 `data` 上使用任何以这些字符作前缀的属性。\n\n### 响应式代理 vs. 原始值 \\* {#reactive-proxy-vs-original}\n\n在 Vue 3 中，数据是基于 [JavaScript Proxy (代理)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 实现响应式的。使用过 Vue 2 的用户可能需要注意下面这样的边界情况：\n\n```js\nexport default {\n  data() {\n    return {\n      someObject: {}\n    }\n  },\n  mounted() {\n    const newObject = {}\n    this.someObject = newObject\n\n    console.log(newObject === this.someObject) // false\n  }\n}\n```\n\n当你在赋值后再访问 `this.someObject`，此值已经是原来的 `newObject` 的一个响应式代理。**与 Vue 2 不同的是，这里原始的 `newObject` 不会变为响应式：请确保始终通过 `this` 来访问响应式状态。**\n\n</div>\n\n<div class=\"composition-api\">\n\n## 声明响应式状态 \\*\\* {#declaring-reactive-state-1}\n\n### `ref()` \\*\\* {#ref}\n\n在组合式 API 中，推荐使用 [`ref()`](/api/reactivity-core#ref) 函数来声明响应式状态：\n\n```js\nimport { ref } from 'vue'\n\nconst count = ref(0)\n```\n\n`ref()` 接收参数，并将其包裹在一个带有 `.value` 属性的 ref 对象中返回：\n\n```js\nconst count = ref(0)\n\nconsole.log(count) // { value: 0 }\nconsole.log(count.value) // 0\n\ncount.value++\nconsole.log(count.value) // 1\n```\n\n> 参考：[为 refs 标注类型](/guide/typescript/composition-api#typing-ref) <sup class=\"vt-badge ts\" />\n\n要在组件模板中访问 ref，请从组件的 `setup()` 函数中声明并返回它们：\n\n```js{5,9-11}\nimport { ref } from 'vue'\n\nexport default {\n  // `setup` 是一个特殊的钩子，专门用于组合式 API。\n  setup() {\n    const count = ref(0)\n\n    // 将 ref 暴露给模板\n    return {\n      count\n    }\n  }\n}\n```\n\n```vue-html\n<div>{{ count }}</div>\n```\n\n注意，在模板中使用 ref 时，我们**不**需要附加 `.value`。为了方便起见，当在模板中使用时，ref 会自动解包 (有一些[注意事项](#caveat-when-unwrapping-in-templates))。\n\n你也可以直接在事件监听器中改变一个 ref：\n\n```vue-html{1}\n<button @click=\"count++\">\n  {{ count }}\n</button>\n```\n\n对于更复杂的逻辑，我们可以在同一作用域内声明更改 ref 的函数，并将它们作为方法与状态一起公开：\n\n```js{7-10,15}\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    function increment() {\n      // 在 JavaScript 中需要 .value\n      count.value++\n    }\n\n    // 不要忘记同时暴露 increment 函数\n    return {\n      count,\n      increment\n    }\n  }\n}\n```\n\n然后，暴露的方法可以被用作事件监听器：\n\n```vue-html{1}\n<button @click=\"increment\">\n  {{ count }}\n</button>\n```\n\n这里是 [Codepen](https://codepen.io/vuejs-examples/pen/WNYbaqo) 上的例子，没有使用任何构建工具。\n\n### `<script setup>` \\*\\* {#script-setup}\n\n在 `setup()` 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用[单文件组件 (SFC)](/guide/scaling-up/sfc) 来避免这种情况。我们可以使用 `<script setup>` 来大幅度地简化代码：\n\n```vue{1}\n<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n\nfunction increment() {\n  count.value++\n}\n</script>\n\n<template>\n  <button @click=\"increment\">\n    {{ count }}\n  </button>\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNo9jUEKgzAQRa8yZKMiaNcllvYe2dgwQqiZhDhxE3L3jrW4/DPvv1/UK8Zhz6juSm82uciwIef4MOR8DImhQMIFKiwpeGgEbQwZsoE2BhsyMUwH0d66475ksuwCgSOb0CNx20ExBCc77POase8NVUN6PBdlSwKjj+vMKAlAvzOzWJ52dfYzGXXpjPoBAKX856uopDGeFfnq8XKp+gWq4FAi)\n\n`<script setup>` 中的顶层的导入、声明的变量和函数可在同一组件的模板中直接使用。你可以理解为模板是在同一作用域内声明的一个 JavaScript 函数——它自然可以访问与它一起声明的所有内容。\n\n:::tip\n在指南的后续章节中，我们基本上都会在组合式 API 示例中使用单文件组件 + `<script setup>` 的语法，因为大多数 Vue 开发者都会这样使用。\n\n如果你没有使用单文件组件，你仍然可以在 [`setup()`](/api/composition-api-setup) 选项中使用组合式 API。\n:::\n\n### 为什么要使用 ref？ \\*\\* {#why-refs}\n\n你可能会好奇：为什么我们需要使用带有 `.value` 的 ref，而不是普通的变量？为了解释这一点，我们需要简单地讨论一下 Vue 的响应式系统是如何工作的。\n\n当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue 会**追踪**在渲染过程中使用的每一个 ref。然后，当一个 ref 被修改时，它会**触发**追踪它的组件的一次重新渲染。\n\n在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。\n\n该 `.value` 属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。从概念上讲，你可以将 ref 看作是一个像这样的对象：\n\n```js\n// 伪代码，不是真正的实现\nconst myRef = {\n  _value: 0,\n  get value() {\n    track()\n    return this._value\n  },\n  set value(newValue) {\n    this._value = newValue\n    trigger()\n  }\n}\n```\n\n另一个 ref 的好处是，与普通变量不同，你可以将 ref 传递给函数，同时保留对最新值和响应式连接的访问。当将复杂的逻辑重构为可重用的代码时，这将非常有用。\n\n该响应性系统在[深入响应式系统](/guide/extras/reactivity-in-depth)章节中有更详细的讨论。\n</div>\n\n<div class=\"options-api\">\n\n## 声明方法 \\* {#declaring-methods}\n\n<VueSchoolLink href=\"https://vueschool.io/lessons/methods-in-vue-3\" title=\"免费的 Vue.js Methods 课程\"/>\n\n要为组件添加方法，我们需要用到 `methods` 选项。它应该是一个包含所有方法的对象：\n\n```js{7-11}\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n  mounted() {\n    // 在其他方法或是生命周期中也可以调用方法\n    this.increment()\n  }\n}\n```\n\nVue 自动为 `methods` 中的方法绑定了永远指向组件实例的 `this`。这确保了方法在作为事件监听器或回调函数时始终保持正确的 `this`。你不应该在定义 `methods` 时使用箭头函数，因为箭头函数没有自己的 `this` 上下文。\n\n```js\nexport default {\n  methods: {\n    increment: () => {\n      // 反例：无法访问此处的 `this`!\n    }\n  }\n}\n```\n\n和组件实例上的其他属性一样，方法也可以在模板上被访问。在模板中它们常常被用作事件监听器：\n\n```vue-html\n<button @click=\"increment\">{{ count }}</button>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNplj9EKwyAMRX8l+LSx0e65uLL9hy+dZlTWqtg4BuK/z1baDgZicsPJgUR2d656B2QN45P02lErDH6c9QQKn10YCKIwAKqj7nAsPYBHCt6sCUDaYKiBS8lpLuk8/yNSb9XUrKg20uOIhnYXAPV6qhbF6fRvmOeodn6hfzwLKkx+vN5OyIFwdENHmBMAfwQia+AmBy1fV8E2gWBtjOUASInXBcxLvN4MLH0BCe1i4Q==)\n\n在上面的例子中，`increment` 方法会在 `<button>` 被点击时调用。\n\n</div>\n\n### 深层响应性 {#deep-reactivity}\n\n<div class=\"options-api\">\n\n在 Vue 中，默认情况下，状态是深度响应的。这意味着当改变嵌套对象或数组时，这些变化也会被检测到：\n\n```js\nexport default {\n  data() {\n    return {\n      obj: {\n        nested: { count: 0 },\n        arr: ['foo', 'bar']\n      }\n    }\n  },\n  methods: {\n    mutateDeeply() {\n      // 以下都会按照期望工作\n      this.obj.nested.count++\n      this.obj.arr.push('baz')\n    }\n  }\n}\n```\n\n</div>\n\n<div class=\"composition-api\">\n\nRef 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构，比如 `Map`。\n\nRef 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到：\n\n```js\nimport { ref } from 'vue'\n\nconst obj = ref({\n  nested: { count: 0 },\n  arr: ['foo', 'bar']\n})\n\nfunction mutateDeeply() {\n  // 以下都会按照期望工作\n  obj.value.nested.count++\n  obj.value.arr.push('baz')\n}\n```\n\n非原始值将通过 [`reactive()`](#reactive) 转换为响应式代理，该函数将在后面讨论。\n\n也可以通过 [shallow ref](/api/reactivity-advanced#shallowref) 来放弃深层响应性。对于浅层 ref，只有 `.value` 的访问会被追踪。浅层 ref 可以用于避免对大型数据的响应性开销来优化性能、或者有外部库管理其内部状态的情况。\n\n阅读更多：\n\n- [减少大型不可变数据的响应性开销](/guide/best-practices/performance#reduce-reactivity-overhead-for-large-immutable-structures)\n- [与外部状态系统集成](/guide/extras/reactivity-in-depth#integration-with-external-state-systems)\n\n</div>\n\n### DOM 更新时机 {#dom-update-timing}\n\n当你修改了响应式状态时，DOM 会被自动更新。但是需要注意的是，DOM 更新不是同步的。Vue 会在“next tick”更新周期中缓冲所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。\n\n要等待 DOM 更新完成后再执行额外的代码，可以使用 [nextTick()](/api/general#nexttick) 全局 API：\n\n<div class=\"composition-api\">\n\n```js\nimport { nextTick } from 'vue'\n\nasync function increment() {\n  count.value++\n  await nextTick()\n  // 现在 DOM 已经更新了\n}\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nimport { nextTick } from 'vue'\n\nexport default {\n  methods: {\n    async increment() {\n      this.count++\n      await nextTick()\n      // 现在 DOM 已经更新了\n    }\n  }\n}\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n## `reactive()` \\*\\* {#reactive}\n\n还有另一种声明响应式状态的方式，即使用 `reactive()` API。与将内部值包装在特殊对象中的 ref 不同，`reactive()` 将使对象本身具有响应性：\n\n```js\nimport { reactive } from 'vue'\n\nconst state = reactive({ count: 0 })\n```\n\n> 参考：[为 `reactive()` 标注类型](/guide/typescript/composition-api#typing-reactive) <sup class=\"vt-badge ts\" />\n\n在模板中使用：\n\n```vue-html\n<button @click=\"state.count++\">\n  {{ state.count }}\n</button>\n```\n\n响应式对象是 [JavaScript 代理](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，其行为就和普通对象一样。不同的是，Vue 能够拦截对响应式对象所有属性的访问和修改，以便进行依赖追踪和触发更新。\n\n`reactive()` 将深层地转换对象：当访问嵌套对象时，它们也会被 `reactive()` 包装。当 ref 的值是一个对象时，`ref()` 也会在内部调用它。与浅层 ref 类似，这里也有一个 [`shallowReactive()`](/api/reactivity-advanced#shallowreactive) API 可以选择退出深层响应性。\n\n### Reactive Proxy vs. Original \\*\\* {#reactive-proxy-vs-original-1}\n\n值得注意的是，`reactive()` 返回的是一个原始对象的 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，它和原始对象是不相等的：\n\n```js\nconst raw = {}\nconst proxy = reactive(raw)\n\n// 代理对象和原始对象不是全等的\nconsole.log(proxy === raw) // false\n```\n\n只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用 Vue 的响应式系统的最佳实践是**仅使用你声明对象的代理版本**。\n\n为保证访问代理的一致性，对同一个原始对象调用 `reactive()` 会总是返回同样的代理对象，而对一个已存在的代理对象调用 `reactive()` 会返回其本身：\n\n```js\n// 在同一个对象上调用 reactive() 会返回相同的代理\nconsole.log(reactive(raw) === proxy) // true\n\n// 在一个代理上调用 reactive() 会返回它自己\nconsole.log(reactive(proxy) === proxy) // true\n```\n\n这个规则对嵌套对象也适用。依靠深层响应性，响应式对象内的嵌套对象依然是代理：\n\n```js\nconst proxy = reactive({})\n\nconst raw = {}\nproxy.nested = raw\n\nconsole.log(proxy.nested === raw) // false\n```\n\n### `reactive()` 的局限性 \\*\\* {#limitations-of-reactive}\n\n`reactive()` API 有一些局限性：\n\n1. **有限的值类型**：它只能用于对象类型 (对象、数组和如 `Map`、`Set` 这样的[集合类型](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#keyed_collections))。它不能持有如 `string`、`number` 或 `boolean` 这样的[原始类型](https://developer.mozilla.org/en-US/docs/Glossary/Primitive)。\n\n2. **不能替换整个对象**：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失：\n\n   ```js\n   let state = reactive({ count: 0 })\n\n   // 上面的 ({ count: 0 }) 引用将不再被追踪\n   // (响应性连接已丢失！)\n   state = reactive({ count: 1 })\n   ```\n\n3. **对解构操作不友好**：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接：\n\n   ```js\n   const state = reactive({ count: 0 })\n\n   // 当解构时，count 已经与 state.count 断开连接\n   let { count } = state\n   // 不会影响原始的 state\n   count++\n\n   // 该函数接收到的是一个普通的数字\n   // 并且无法追踪 state.count 的变化\n   // 我们必须传入整个对象以保持响应性\n   callSomeFunction(state.count)\n   ```\n\n由于这些限制，我们建议使用 `ref()` 作为声明响应式状态的主要 API。\n\n## 额外的 ref 解包细节 \\*\\* {#additional-ref-unwrapping-details}\n\n### 作为 reactive 对象的属性 \\*\\* {#ref-unwrapping-as-reactive-object-property}\n\n一个 ref 会在作为响应式对象的属性被访问或修改时自动解包。换句话说，它的行为就像一个普通的属性：\n\n```js\nconst count = ref(0)\nconst state = reactive({\n  count\n})\n\nconsole.log(state.count) // 0\n\nstate.count = 1\nconsole.log(count.value) // 1\n```\n\n如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref：\n\n```js\nconst otherCount = ref(2)\n\nstate.count = otherCount\nconsole.log(state.count) // 2\n// 原始 ref 现在已经和 state.count 失去联系\nconsole.log(count.value) // 1\n```\n\n只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为[浅层响应式对象](/api/reactivity-advanced#shallowreactive)的属性被访问时不会解包。\n\n### 数组和集合的注意事项 \\*\\* {#caveat-in-arrays-and-collections}\n\n与 reactive 对象不同的是，当 ref 作为响应式数组或原生集合类型 (如 `Map`) 中的元素被访问时，它**不会**被解包：\n\n```js\nconst books = reactive([ref('Vue 3 Guide')])\n// 这里需要 .value\nconsole.log(books[0].value)\n\nconst map = reactive(new Map([['count', ref(0)]]))\n// 这里需要 .value\nconsole.log(map.get('count').value)\n```\n\n### 在模板中解包的注意事项 \\*\\* {#caveat-when-unwrapping-in-templates}\n\n在模板渲染上下文中，只有顶级的 ref 属性才会被解包。\n\n在下面的例子中，`count` 和 `object` 是顶级属性，但 `object.id` 不是：\n\n```js\nconst count = ref(0)\nconst object = { id: ref(1) }\n```\n\n因此，这个表达式按预期工作：\n\n```vue-html\n{{ count + 1 }}\n```\n\n...但这个**不会**：\n\n```vue-html\n{{ object.id + 1 }}\n```\n\n渲染的结果将是 `[object Object]1`，因为在计算表达式时 `object.id` 没有被解包，仍然是一个 ref 对象。为了解决这个问题，我们可以将 `id` 解构为一个顶级属性：\n\n```js\nconst { id } = object\n```\n\n```vue-html\n{{ id + 1 }}\n```\n\n现在渲染的结果将是 `2`。\n\n另一个需要注意的点是，如果 ref 是文本插值的最终计算值 (即 <code v-pre>{{ }}</code> 标签)，那么它将被解包，因此以下内容将渲染为 `1`：\n\n```vue-html\n{{ object.id }}\n```\n\n该特性仅仅是文本插值的一个便利特性，等价于 <code v-pre>{{ object.id.value }}</code>。\n\n</div>\n\n<div class=\"options-api\">\n\n### 有状态方法 \\* {#stateful-methods}\n\n在某些情况下，我们可能需要动态地创建一个方法函数，比如创建一个预置防抖的事件处理器：\n\n```js\nimport { debounce } from 'lodash-es'\n\nexport default {\n  methods: {\n    // 使用 Lodash 的防抖函数\n    click: debounce(function () {\n      // ... 对点击的响应 ...\n    }, 500)\n  }\n}\n```\n\n不过这种方法对于被重用的组件来说是有问题的，因为这个预置防抖的函数是**有状态的**：它在运行时维护着一个内部状态。如果多个组件实例都共享这同一个预置防抖的函数，那么它们之间将会互相影响。\n\n要保持每个组件实例的防抖函数都彼此独立，我们可以改为在 `created` 生命周期钩子中创建这个预置防抖的函数：\n\n```js\nexport default {\n  created() {\n    // 每个实例都有了自己的预置防抖的处理函数\n    this.debouncedClick = _.debounce(this.click, 500)\n  },\n  unmounted() {\n    // 最好是在组件卸载时\n    // 清除掉防抖计时器\n    this.debouncedClick.cancel()\n  },\n  methods: {\n    click() {\n      // ... 对点击的响应 ...\n    }\n  }\n}\n```\n\n</div>\n\n\n\n================================================\nFILE: src/guide/essentials/template-refs.md\n================================================\n# 模板引用 {#template-refs}\n\n虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 `ref` attribute：\n\n```vue-html\n<input ref=\"input\">\n```\n\n`ref` 是一个特殊的 attribute，和 `v-for` 章节中提到的 `key` 类似。它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库。\n\n## 访问模板引用 {#accessing-the-refs}\n\n<div class=\"composition-api\">\n\n要在组合式 API 中获取引用，我们可以使用辅助函数 [`useTemplateRef()`](/api/composition-api-helpers#usetemplateref) <sup class=\"vt-badge\" data-text=\"3.5+\" />：\n\n```vue\n<script setup>\nimport { useTemplateRef, onMounted } from 'vue'\n\n// 第一个参数必须与模板中的 ref 值匹配\nconst input = useTemplateRef('my-input')\n\nonMounted(() => {\n  input.value.focus()\n})\n</script>\n\n<template>\n  <input ref=\"my-input\" />\n</template>\n```\n\n在使用 TypeScript 时，Vue 的 IDE 支持和 `vue-tsc` 将根据匹配的 `ref` attribute 所用的元素或组件自动推断 `input.value` 的类型。\n\n<details>\n<summary>3.5 前的用法</summary>\n\n在 3.5 之前的版本尚未引入 `useTemplateRef()`，我们需要声明一个与模板里 ref attribute 匹配的引用：\n\n```vue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// 声明一个 ref 来存放该元素的引用\n// 必须和模板里的 ref 同名\nconst input = ref(null)\n\nonMounted(() => {\n  input.value.focus()\n})\n</script>\n\n<template>\n  <input ref=\"input\" />\n</template>\n```\n\n如果不使用 `<script setup>`，需确保从 `setup()` 返回 ref：\n\n```js{6}\nexport default {\n  setup() {\n    const input = ref(null)\n    // ...\n    return {\n      input\n    }\n  }\n}\n```\n\n</details>\n\n</div>\n<div class=\"options-api\">\n\n挂载结束后引用都会被暴露在 `this.$refs` 之上：\n\n```vue\n<script>\nexport default {\n  mounted() {\n    this.$refs.input.focus()\n  }\n}\n</script>\n\n<template>\n  <input ref=\"input\" />\n</template>\n```\n\n</div>\n\n注意，你只可以**在组件挂载后**才能访问模板引用。如果你想在模板中的表达式上访问 <span class=\"options-api\">`$refs.input`</span><span class=\"composition-api\">`input`</span>，在初次渲染时会是 <span class=\"options-api\">`undefined`</span><span class=\"composition-api\">`null`</span>。这是因为在初次渲染前这个元素还不存在呢！\n\n<div class=\"composition-api\">\n\n如果你需要侦听一个模板引用 ref 的变化，确保考虑到其值为 `null` 的情况：\n\n```js\nwatchEffect(() => {\n  if (input.value) {\n    input.value.focus()\n  } else {\n    // 此时还未挂载，或此元素已经被卸载(例如通过 v-if 控制)\n  }\n})\n```\n\n也可参考：[为模板引用标注类型](/guide/typescript/composition-api#typing-template-refs) <sup class=\"vt-badge ts\" />\n\n</div>\n\n## 组件上的 ref {#ref-on-component}\n\n> 这一小节假设你已了解[组件](/guide/essentials/component-basics)的相关知识，或者你也可以先跳过这里，之后再回来看。\n\n模板引用也可以被用在一个子组件上。这种情况下引用中获得的值是组件实例：\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nimport { useTemplateRef, onMounted } from 'vue'\nimport Child from './Child.vue'\n\nconst childRef = useTemplateRef('child')\n\nonMounted(() => {\n  // childRef.value 将持有 <Child /> 的实例\n})\n</script>\n\n<template>\n  <Child ref=\"child\" />\n</template>\n```\n\n<details>\n<summary>3.5 前的用法</summary>\n\n```vue\n<script setup>\nimport { ref, onMounted } from 'vue'\nimport Child from './Child.vue'\n\nconst child = ref(null)\n\nonMounted(() => {\n  // child.value 是 <Child /> 组件的实例\n})\n</script>\n\n<template>\n  <Child ref=\"child\" />\n</template>\n```\n\n</details>\n\n</div>\n<div class=\"options-api\">\n\n```vue\n<script>\nimport Child from './Child.vue'\n\nexport default {\n  components: {\n    Child\n  },\n  mounted() {\n    // this.$refs.child 是 <Child /> 组件的实例\n  }\n}\n</script>\n\n<template>\n  <Child ref=\"child\" />\n</template>\n```\n\n</div>\n\n如果一个子组件使用的是选项式 API <span class=\"composition-api\">或没有使用 `<script setup>`</span>，被引用的组件实例和该子组件的 `this` 完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互。\n\n<div class=\"composition-api\">\n\n有一个例外的情况，使用了 `<script setup>` 的组件是**默认私有**的：一个父组件无法访问到一个使用了 `<script setup>` 的子组件中的任何东西，除非子组件在其中通过 `defineExpose` 宏显式暴露：\n\n```vue\n<script setup>\nimport { ref } from 'vue'\n\nconst a = 1\nconst b = ref(2)\n\n// 像 defineExpose 这样的编译器宏不需要导入\ndefineExpose({\n  a,\n  b\n})\n</script>\n```\n\n当父组件通过模板引用获取到了该组件的实例时，得到的实例类型为 `{ a: number, b: number }` (ref 都会自动解包，和一般的实例一样)。\n\n请注意，defineExpose 必须在任何 await 操作之前调用。否则，在 await 操作后暴露的属性和方法将无法访问。\n\nTypeScript 用户请参考：[为组件的模板引用标注类型](/guide/typescript/composition-api#typing-component-template-refs) <sup class=\"vt-badge ts\" />\n\n</div>\n<div class=\"options-api\">\n\n`expose` 选项可以用于限制对子组件实例的访问：\n\n```js\nexport default {\n  expose: ['publicData', 'publicMethod'],\n  data() {\n    return {\n      publicData: 'foo',\n      privateData: 'bar'\n    }\n  },\n  methods: {\n    publicMethod() {\n      /* ... */\n    },\n    privateMethod() {\n      /* ... */\n    }\n  }\n}\n```\n\n在上面这个例子中，父组件通过模板引用访问到子组件实例后，仅能访问 `publicData` 和 `publicMethod`。\n\n</div>\n\n## `v-for` 中的模板引用 {#refs-inside-v-for}\n\n> 需要 v3.5 及以上版本\n\n<div class=\"composition-api\">\n\n当在 `v-for` 中使用模板引用时，对应的 ref 中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素：\n\n```vue\n<script setup>\nimport { ref, useTemplateRef, onMounted } from 'vue'\n\nconst list = ref([\n  /* ... */\n])\n\nconst itemRefs = useTemplateRef('items')\n\nonMounted(() => console.log(itemRefs.value))\n</script>\n\n<template>\n  <ul>\n    <li v-for=\"item in list\" ref=\"items\">\n      {{ item }}\n    </li>\n  </ul>\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9UsluwjAQ/ZWRLwQpDepyQoDUIg6t1EWUW91DFAZq6tiWF4oU5d87dtgqVRyyzLw3b+aN3bB7Y4ptQDZkI1dZYTw49MFMuBK10dZDAxZXOQSHC6yNLD3OY6zVsw7K4xJaWFldQ49UelxxVWnlPEhBr3GszT6uc7jJ4fazf4KFx5p0HFH+Kme9CLle4h6bZFkfxhNouAIoJVqfHQSKbSkDFnVpMhEpovC481NNVcr3SaWlZzTovJErCqgydaMIYBRk+tKfFLC9Wmk75iyqg1DJBWfRxT7pONvTAZom2YC23QsMpOg0B0l0NDh2YjnzjpyvxLrYOK1o3ckLZ5WujSBHr8YL2gxnw85lxEop9c9TynkbMD/kqy+svv/Jb9wu5jh7s+jQbpGzI+ZLu0byEuHZ+wvt6Ays9TJIYl8A5+i0DHHGjvYQ1JLGPuOlaR/TpRFqvXCzHR2BO5iKg0Zmm/ic0W2ZXrB+Gve2uEt1dJKs/QXbwePE)\n\n<details>\n<summary>3.5 前的用法</summary>\n\n在 3.5 版本以前，`useTemplateRef()` 尚未引入，需要声明一个与模板引用 attribute 同名的 ref。该 ref 的值需要是一个数组。\n\n```vue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\nconst list = ref([\n  /* ... */\n])\n\nconst itemRefs = ref([])\n\nonMounted(() => console.log(itemRefs.value))\n</script>\n\n<template>\n  <ul>\n    <li v-for=\"item in list\" ref=\"itemRefs\">\n      {{ item }}\n    </li>\n  </ul>\n</template>\n```\n\n</details>\n\n</div>\n<div class=\"options-api\">\n\n当在 `v-for` 中使用模板引用时，相应的引用中包含的值是一个数组：\n\n```vue\n<script>\nexport default {\n  data() {\n    return {\n      list: [\n        /* ... */\n      ]\n    }\n  },\n  mounted() {\n    console.log(this.$refs.items)\n  }\n}\n</script>\n\n<template>\n  <ul>\n    <li v-for=\"item in list\" ref=\"items\">\n      {{ item }}\n    </li>\n  </ul>\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpFjk0KwjAQha/yCC4Uaou6kyp4DuOi2KkGYhKSiQildzdNa4WQmTc/37xeXJwr35HEUdTh7pXjszT0cdYzWuqaqBm9NEDbcLPeTDngiaM3PwVoFfiI667AvsDhNpWHMQzF+L9sNEztH3C3JlhNpbaPNT9VKFeeulAqplfY5D1p0qurxVQSqel0w5QUUEedY8q0wnvbWX+SYgRAmWxIiuSzm4tBinkc6HvkuSE7TIBKq4lZZWhdLZfE8AWp4l3T)\n\n</div>\n\n应该注意的是，ref 数组**并不**保证与源数组相同的顺序。\n\n## 函数模板引用 {#function-refs}\n\n除了使用字符串值作名字，`ref` attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数：\n\n```vue-html\n<input :ref=\"(el) => { /* 将 el 赋值给一个数据属性或 ref 变量 */ }\">\n```\n\n注意我们这里需要使用动态的 `:ref` 绑定才能够传入一个函数。当绑定的元素被卸载时，函数也会被调用一次，此时的 `el` 参数会是 `null`。你当然也可以绑定一个组件方法而不是内联函数。\n\n\n\n================================================\nFILE: src/guide/essentials/template-syntax.md\n================================================\n# 模板语法 {#template-syntax}\n\n<ScrimbaLink href=\"https://scrimba.com/links/vue-template-syntax\" title=\"Free Vue.js Template Syntax Lesson\" type=\"scrimba\">\n  观看 Scrimba 的互动视频课程\n</ScrimbaLink>\n\nVue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。\n\n在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。\n\n如果你对虚拟 DOM 的概念比较熟悉，并且偏好直接使用 JavaScript，你也可以结合可选的 JSX 支持[直接手写渲染函数](/guide/extras/render-function)而不采用模板。但请注意，这将不会享受到和模板同等级别的编译时优化。\n\n## 文本插值 {#text-interpolation}\n\n最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)：\n\n```vue-html\n<span>Message: {{ msg }}</span>\n```\n\n双大括号标签会被替换为[相应组件实例中](/guide/essentials/reactivity-fundamentals#declaring-reactive-state) `msg` 属性的值。同时每次 `msg` 属性更改时它也会同步更新。\n\n## 原始 HTML {#raw-html}\n\n双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 [`v-html` 指令](/api/built-in-directives#v-html)：\n\n```vue-html\n<p>Using text interpolation: {{ rawHtml }}</p>\n<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n```\n\n<script setup>\n  const rawHtml = '<span style=\"color: red\">This should be red.</span>'\n</script>\n\n<p class=\"demo\">\n  <p>Using text interpolation: {{ rawHtml }}</p>\n  <p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n</p>\n\n这里我们遇到了一个新的概念。这里看到的 `v-html` attribute 被称为一个**指令**。指令由 `v-` 作为前缀，表明它们是一些由 Vue 提供的特殊 attribute，你可能已经猜到了，它们将为渲染的 DOM 应用特殊的响应式行为。这里我们做的事情简单来说就是：在当前组件实例上，将此元素的 innerHTML 与 `rawHtml` 属性保持同步。\n\n`span` 的内容将会被替换为 `rawHtml` 属性的值，插值为纯 HTML——数据绑定将会被忽略。注意，你不能使用 `v-html` 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。\n\n:::warning 安全警告\n在网站上动态渲染任意 HTML 是非常危险的，因为这非常容易造成 [XSS 漏洞](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC)。请仅在内容安全可信时再使用 `v-html`，并且**永远不要**使用用户提供的 HTML 内容。\n:::\n\n## Attribute 绑定 {#attribute-bindings}\n\n双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 [`v-bind` 指令](/api/built-in-directives#v-bind)：\n\n```vue-html\n<div v-bind:id=\"dynamicId\"></div>\n```\n\n`v-bind` 指令指示 Vue 将元素的 `id` attribute 与组件的 `dynamicId` 属性保持一致。如果绑定的值是 `null` 或者 `undefined`，那么该 attribute 将会从渲染的元素上移除。\n\n### 简写 {#shorthand}\n\n因为 `v-bind` 非常常用，我们提供了特定的简写语法：\n\n```vue-html\n<div :id=\"dynamicId\"></div>\n```\n\n开头为 `:` 的 attribute 可能和一般的 HTML attribute 看起来不太一样，但它的确是合法的 attribute 名称字符，并且所有支持 Vue 的浏览器都能正确解析它。此外，他们不会出现在最终渲染的 DOM 中。简写语法是可选的，但相信在你了解了它更多的用处后，你应该会更喜欢它。\n\n> 接下来的指引中，我们都将在示例中使用简写语法，因为这是在实际开发中更常见的用法。\n\n### 同名简写 {#same-name-shorthand}\n\n- 仅支持 3.4 版本及以上\n\n如果 attribute 的名称与绑定的 JavaScript 变量的名称相同，那么可以进一步简化语法，省略 attribute 值：\n\n```vue-html\n<!-- 与 :id=\"id\" 相同 -->\n<div :id></div>\n\n<!-- 这也同样有效 -->\n<div v-bind:id></div>\n```\n\n这与在 JavaScript 中声明对象时使用的属性简写语法类似。请注意，这是一个只在 Vue 3.4 及以上版本中可用的特性。\n\n### 布尔型 Attribute {#boolean-attributes}\n\n[布尔型 attribute](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes#%E5%B8%83%E5%B0%94%E5%80%BC%E5%B1%9E%E6%80%A7) 依据 true / false 值来决定 attribute 是否应该存在于该元素上。[`disabled`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled) 就是最常见的例子之一。\n\n`v-bind` 在这种场景下的行为略有不同：\n\n```vue-html\n<button :disabled=\"isButtonDisabled\">Button</button>\n```\n\n当 `isButtonDisabled` 为[真值](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)或一个空字符串 (即 `<button disabled=\"\">`) 时，元素会包含这个 `disabled` attribute。而当其为其他[假值](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)时 attribute 将被忽略。\n\n### 动态绑定多个值 {#dynamically-binding-multiple-attributes}\n\n如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：\n\n<div class=\"composition-api\">\n\n```js\nconst objectOfAttrs = {\n  id: 'container',\n  class: 'wrapper',\n  style: 'background-color:green'\n}\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\ndata() {\n  return {\n    objectOfAttrs: {\n      id: 'container',\n      class: 'wrapper'\n    }\n  }\n}\n```\n\n</div>\n\n通过不带参数的 `v-bind`，你可以将它们绑定到单个元素上：\n\n```vue-html\n<div v-bind=\"objectOfAttrs\"></div>\n```\n\n## 使用 JavaScript 表达式 {#using-javascript-expressions}\n\n至此，我们仅在模板中绑定了一些简单的属性名。但是 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式：\n\n```vue-html\n{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div :id=\"`list-${id}`\"></div>\n```\n\n这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。\n\n在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：\n\n- 在文本插值中 (双大括号)\n- 在任何 Vue 指令 (以 `v-` 开头的特殊 attribute) attribute 的值中\n\n### 仅支持表达式 {#expressions-only}\n\n每个绑定仅支持**单一表达式**，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在 `return` 后面。\n\n因此，下面的例子都是**无效**的：\n\n```vue-html\n<!-- 这是一个语句，而非表达式 -->\n{{ var a = 1 }}\n\n<!-- 条件控制也不支持，请使用三元表达式 -->\n{{ if (ok) { return message } }}\n```\n\n### 调用函数 {#calling-functions}\n\n可以在绑定的表达式中使用一个组件暴露的方法：\n\n```vue-html\n<time :title=\"toTitleDate(date)\" :datetime=\"date\">\n  {{ formatDate(date) }}\n</time>\n```\n\n:::tip\n绑定在表达式中的方法在组件每次更新时都会被重新调用，因此**不**应该产生任何副作用，比如改变数据或触发异步操作。\n:::\n\n### 受限的全局访问 {#restricted-globals-access}\n\n模板中的表达式将被沙盒化，仅能够访问到[有限的全局对象列表](https://github.com/vuejs/core/blob/main/packages/shared/src/globalsAllowList.ts#L3)。该列表中会暴露常用的内置全局对象，比如 `Math` 和 `Date`。\n\n没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 `window` 上的属性。然而，你也可以自行在 [`app.config.globalProperties`](/api/application#app-config-globalproperties) 上显式地添加它们，供所有的 Vue 表达式使用。\n\n## 指令 Directives {#directives}\n\n指令是带有 `v-` 前缀的特殊 attribute。Vue 提供了许多[内置指令](/api/built-in-directives)，包括上面我们所介绍的 `v-bind` 和 `v-html`。\n\n指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 `v-for`、`v-on` 和 `v-slot`)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 [`v-if`](/api/built-in-directives#v-if) 为例：\n\n```vue-html\n<p v-if=\"seen\">Now you see me</p>\n```\n\n这里，`v-if` 指令会基于表达式 `seen` 的值的真假来移除/插入该 `<p>` 元素。\n\n### 参数 Arguments {#arguments}\n\n某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 `v-bind` 指令来响应式地更新一个 HTML attribute：\n\n```vue-html\n<a v-bind:href=\"url\"> ... </a>\n\n<!-- 简写 -->\n<a :href=\"url\"> ... </a>\n```\n\n这里 `href` 就是一个参数，它告诉 `v-bind` 指令将表达式 `url` 的值绑定到元素的 `href` attribute 上。在简写中，参数前的一切 (例如 `v-bind:`) 都会被缩略为一个 `:` 字符。\n\n另一个例子是 `v-on` 指令，它将监听 DOM 事件：\n\n```vue-html\n<a v-on:click=\"doSomething\"> ... </a>\n\n<!-- 简写 -->\n<a @click=\"doSomething\"> ... </a>\n```\n\n这里的参数是要监听的事件名称：`click`。`v-on` 有一个相应的缩写，即 `@` 字符。我们之后也会讨论关于事件处理的更多细节。\n\n### 动态参数 {#dynamic-arguments}\n\n同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：\n\n```vue-html\n<!--\n注意，参数表达式有一些约束，\n参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释\n-->\n<a v-bind:[attributeName]=\"url\"> ... </a>\n\n<!-- 简写 -->\n<a :[attributeName]=\"url\"> ... </a>\n```\n\n这里的 `attributeName` 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性 `attributeName`，其值为 `\"href\"`，那么这个绑定就等价于 `v-bind:href`。\n\n相似地，你还可以将一个函数绑定到动态的事件名称上：\n\n```vue-html\n<a v-on:[eventName]=\"doSomething\"> ... </a>\n\n<!-- 简写 -->\n<a @[eventName]=\"doSomething\"> ... </a>\n```\n\n在此示例中，当 `eventName` 的值是 `\"focus\"` 时，`v-on:[eventName]` 就等价于 `v-on:focus`。\n\n#### 动态参数值的限制 {#dynamic-argument-value-constraints}\n\n动态参数中表达式的值应当是一个字符串，或者是 `null`。特殊值 `null` 意为显式移除该绑定。其他非字符串的值会触发警告。\n\n#### 动态参数语法的限制 {#dynamic-argument-syntax-constraints}\n\n动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例：\n\n```vue-html\n<!-- 这会触发一个编译器警告 -->\n<a :['foo' + bar]=\"value\"> ... </a>\n```\n\n如果你需要传入一个复杂的动态参数，我们推荐使用[计算属性](computed)替换复杂的表达式，也是 Vue 最基础的概念之一，我们很快就会讲到。\n\n当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写：\n\n```vue-html\n<a :[someAttr]=\"value\"> ... </a>\n```\n\n上面的例子将会在 DOM 内嵌模板中被转换为 `:[someattr]`。如果你的组件拥有 “someAttr” 属性而非 “someattr”，这段代码将不会工作。单文件组件内的模板**不**受此限制。\n\n### 修饰符 Modifiers {#modifiers}\n\n修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 `.prevent` 修饰符会告知 `v-on` 指令对触发的事件调用 `event.preventDefault()`：\n\n```vue-html\n<form @submit.prevent=\"onSubmit\">...</form>\n```\n\n之后在讲到 [`v-on`](./event-handling#event-modifiers) 和 [`v-model`](./forms#modifiers) 的功能时，你将会看到其他修饰符的例子。\n\n最后，在这里你可以直观地看到完整的指令语法：\n\n![指令语法图](./images/directive.png)\n\n<!-- https://www.figma.com/file/BGWUknIrtY9HOmbmad0vFr/Directive -->\n\n<!-- zhlint disabled -->\n\n\n\n================================================\nFILE: src/guide/essentials/watchers.md\n================================================\n# 侦听器 {#watchers}\n\n## 基本示例 {#basic-example}\n\n计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。\n\n<div class=\"options-api\">\n\n在选项式 API 中，我们可以使用 [`watch` 选项](/api/options-state#watch)在每次响应式属性发生变化时触发一个函数。\n\n```js\nexport default {\n  data() {\n    return {\n      question: '',\n      answer: 'Questions usually contain a question mark. ;-)',\n      loading: false\n    }\n  },\n  watch: {\n    // 每当 question 改变时，这个函数就会执行\n    question(newQuestion, oldQuestion) {\n      if (newQuestion.includes('?')) {\n        this.getAnswer()\n      }\n    }\n  },\n  methods: {\n    async getAnswer() {\n      this.loading = true\n      this.answer = 'Thinking...'\n      try {\n        const res = await fetch('https://yesno.wtf/api')\n        this.answer = (await res.json()).answer\n      } catch (error) {\n        this.answer = 'Error! Could not reach the API. ' + error\n      } finally {\n        this.loading = false\n      }\n    }\n  }\n}\n```\n\n```vue-html\n<p>\n  Ask a yes/no question:\n  <input v-model=\"question\" :disabled=\"loading\" />\n</p>\n<p>{{ answer }}</p>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9VE1v2zAM/SucLnaw1D70lqUbsiKH7rB1W4++aDYdq5ElTx9xgiD/fbT8lXZFAQO2+Mgn8pH0mW2aJjl4ZCu2trkRjfucKTw22jgosOReOjhnCqDgjseL/hvAoPNGjSeAvx6tE1qtIIqWo5Er26Ih088BteCt51KeINfKcaGAT5FQc7NP4NPNYiaQmhdC7VZQcmlxMF+61yUcWu7yajVmkabQVqjwgGZmzSuudmiX4CphofQqD+ZWSAnGqz5y9I4VtmOuS9CyGA9T3QCihGu3RKhc+gJtHH2JFld+EG5Mdug2QYZ4MSKhgBd11OgqXdipEm5PKoer0Jk2kA66wB044/EF1GtOSPRUCbUnryRJosnFnK4zpC5YR7205M9bLhyUSIrGUeVcY1dpekKrdNK6MuWNiKYKXt8V98FElDxbknGxGLCpZMi7VkGMxmjzv0pz1tvO4QPcay8LULoj5RToKoTN40MCEXyEQDJTl0KFmXpNOqsUxudN+TNFzzqdJp8ODutGcod0Alg34QWwsXsaVtIjVXqe9h5bC9V4B4ebWhco7zI24hmDVSEs/yOxIPOQEFnTnjzt2emS83nYFrhcevM6nRJhS+Ys9aoUu6Av7WqoNWO5rhsh0fxownplbBqhjJEmuv0WbN2UDNtDMRXm+zfsz/bY2TL2SH1Ec8CMTZjjhqaxh7e/v+ORvieQqvaSvN8Bf6HV0veSdG5fvSoo7Su/kO1D3f13SKInuz06VHYsahzzfl0yRj+s+3dKn9O9TW7HPrPLP624lFU=)\n\n`watch` 选项也支持把键设置成用 `.` 分隔的路径：\n\n```js\nexport default {\n  watch: {\n    // 注意：只能是简单的路径，不支持表达式。\n    'some.nested.key'(newValue) {\n      // ...\n    }\n  }\n}\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n在组合式 API 中，我们可以使用 [`watch` 函数](/api/reactivity-core#watch)在每次响应式状态发生变化时触发回调函数：\n\n```vue\n<script setup>\nimport { ref, watch } from 'vue'\n\nconst question = ref('')\nconst answer = ref('Questions usually contain a question mark. ;-)')\nconst loading = ref(false)\n\n// 可以直接侦听一个 ref\nwatch(question, async (newQuestion, oldQuestion) => {\n  if (newQuestion.includes('?')) {\n    loading.value = true\n    answer.value = 'Thinking...'\n    try {\n      const res = await fetch('https://yesno.wtf/api')\n      answer.value = (await res.json()).answer\n    } catch (error) {\n      answer.value = 'Error! Could not reach the API. ' + error\n    } finally {\n      loading.value = false\n    }\n  }\n})\n</script>\n\n<template>\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\" :disabled=\"loading\" />\n  </p>\n  <p>{{ answer }}</p>\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9U8Fy0zAQ/ZVFF9tDah96C2mZ0umhHKBAj7oIe52oUSQjyXEyGf87KytyoDC9JPa+p+e3b1cndtd15b5HtmQrV1vZeXDo++6Wa7nrjPVwAovtAgbh6w2M0Fqzg4xOZFxzXRvtPPzq0XlpNNwEbp5lRUKEdgPaVP925jnoXS+UOgKxvJAaxEVjJ+y2hA9XxUVFGdFIvT7LtEI5JIzrqjrbGozdOmikxdqTKqmIQOV6gvOkvQDhjrqGXOOQvCzAqCa9FHBzCyeuAWT7F6uUulZ9gy7PPmZFETmQjJV7oXoke972GJHY+Axkzxupt4FalhRcYHh7TDIQcqA+LTriikFIDy0G59nG+84tq+qITpty8G0lOhmSiedefSaPZ0mnfHFG50VRRkbkj1BPceVorbFzF/+6fQj4O7g3vWpAm6Ao6JzfINw9PZaQwXuYNJJuK/U0z1nxdTLT0M7s8Ec/I3WxquLS0brRi8ddp4RHegNYhR0M/Du3pXFSAJU285osI7aSuus97K92pkF1w1nCOYNlI534qbCh8tkOVasoXkV1+sjplLZ0HGN5Vc1G2IJ5R8Np5XpKlK7J1CJntdl1UqH92k0bzdkyNc8ZRWGGz1MtbMQi1esN1tv/1F/cIdQ4e6LJod0jZzPmhV2jj/DDjy94oOcZpK57Rew3wO/ojOpjJIH2qdcN2f6DN7l9nC47RfTsHg4etUtNpZUeJz5ndPPv32j9Yve6vE6DZuNvu1R2Tg==)\n\n### 侦听数据源类型 {#watch-source-types}\n\n`watch` 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 [getter 函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description)、或多个数据源组成的数组：\n\n```js\nconst x = ref(0)\nconst y = ref(0)\n\n// 单个 ref\nwatch(x, (newX) => {\n  console.log(`x is ${newX}`)\n})\n\n// getter 函数\nwatch(\n  () => x.value + y.value,\n  (sum) => {\n    console.log(`sum of x + y is: ${sum}`)\n  }\n)\n\n// 多个来源组成的数组\nwatch([x, () => y.value], ([newX, newY]) => {\n  console.log(`x is ${newX} and y is ${newY}`)\n})\n```\n\n注意，你不能直接侦听响应式对象的属性值，例如:\n\n```js\nconst obj = reactive({ count: 0 })\n\n// 错误，因为 watch() 得到的参数是一个 number\nwatch(obj.count, (count) => {\n  console.log(`Count is: ${count}`)\n})\n```\n\n这里需要用一个返回该属性的 getter 函数：\n\n```js\n// 提供一个 getter 函数\nwatch(\n  () => obj.count,\n  (count) => {\n    console.log(`Count is: ${count}`)\n  }\n)\n```\n\n</div>\n\n## 深层侦听器 {#deep-watchers}\n\n<div class=\"options-api\">\n\n`watch` 默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数——而嵌套属性的变化不会触发。如果想侦听所有嵌套的变更，你需要深层侦听器：\n\n```js\nexport default {\n  watch: {\n    someObject: {\n      handler(newValue, oldValue) {\n        // 注意：在嵌套的变更中，\n        // 只要没有替换对象本身，\n        // 那么这里的 `newValue` 和 `oldValue` 相同\n      },\n      deep: true\n    }\n  }\n}\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n直接给 `watch()` 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发：\n\n```js\nconst obj = reactive({ count: 0 })\n\nwatch(obj, (newValue, oldValue) => {\n  // 在嵌套的属性变更时触发\n  // 注意：`newValue` 此处和 `oldValue` 是相等的\n  // 因为它们是同一个对象！\n})\n\nobj.count++\n```\n\n相比之下，一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调：\n\n```js\nwatch(\n  () => state.someObject,\n  () => {\n    // 仅当 state.someObject 被替换时触发\n  }\n)\n```\n\n你也可以给上面这个例子显式地加上 `deep` 选项，强制转成深层侦听器：\n\n```js\nwatch(\n  () => state.someObject,\n  (newValue, oldValue) => {\n    // 注意：`newValue` 此处和 `oldValue` 是相等的\n    // *除非* state.someObject 被整个替换了\n  },\n  { deep: true }\n)\n```\n\n</div>\n\n在 Vue 3.5+ 中，`deep` 选项还可以是一个数字，表示最大遍历深度——即 Vue 应该遍历对象嵌套属性的级数。\n\n:::warning 谨慎使用\n深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。\n:::\n\n## 即时回调的侦听器 {#eager-watchers}\n\n`watch` 默认是懒执行的：仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。\n\n<div class=\"options-api\">\n\n我们可以用一个对象来声明侦听器，这个对象有 `handler` 方法和 `immediate: true` 选项，这样便能强制回调函数立即执行：\n\n```js\nexport default {\n  // ...\n  watch: {\n    question: {\n      handler(newQuestion) {\n        // 在组件实例创建时会立即调用\n      },\n      // 强制立即执行回调\n      immediate: true\n    }\n  }\n  // ...\n}\n```\n\n回调函数的初次执行就发生在 `created` 钩子之前。Vue 此时已经处理了 `data`、`computed` 和 `methods` 选项，所以这些属性在第一次调用时就是可用的。\n\n</div>\n\n<div class=\"composition-api\">\n\n我们可以通过传入 `immediate: true` 选项来强制侦听器的回调立即执行：\n\n```js\nwatch(\n  source,\n  (newValue, oldValue) => {\n    // 立即执行，且当 `source` 改变时再次执行\n  },\n  { immediate: true }\n)\n```\n\n</div>\n\n## 一次性侦听器 {#once-watchers}\n\n- 仅支持 3.4 及以上版本\n\n每当被侦听源发生变化时，侦听器的回调就会执行。如果希望回调只在源变化时触发一次，请使用 `once: true` 选项。\n\n<div class=\"options-api\">\n\n```js\nexport default {\n  watch: {\n    source: {\n      handler(newValue, oldValue) {\n        // 当 `source` 变化时，仅触发一次\n      },\n      once: true\n    }\n  }\n}\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n```js\nwatch(\n  source,\n  (newValue, oldValue) => {\n    // 当 `source` 变化时，仅触发一次\n  },\n  { once: true }\n)\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n## `watchEffect()` \\*\\* {#watcheffect}\n\n侦听器的回调使用与源完全相同的响应式状态是很常见的。例如下面的代码，在每当 `todoId` 的引用发生变化时使用侦听器来加载一个远程资源：\n\n```js\nconst todoId = ref(1)\nconst data = ref(null)\n\nwatch(\n  todoId,\n  async () => {\n    const response = await fetch(\n      `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n    )\n    data.value = await response.json()\n  },\n  { immediate: true }\n)\n```\n\n特别是注意侦听器是如何两次使用 `todoId` 的，一次是作为源，另一次是在回调中。\n\n我们可以用 [`watchEffect` 函数](/api/reactivity-core#watcheffect) 来简化上面的代码。`watchEffect()` 允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为：\n\n```js\nwatchEffect(async () => {\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n  )\n  data.value = await response.json()\n})\n```\n\n这个例子中，回调会立即执行，不需要指定 `immediate: true`。在执行期间，它会自动追踪 `todoId.value` 作为依赖(和计算属性类似)。每当 `todoId.value` 变化时，回调会再次执行。有了 `watchEffect()`，我们不再需要明确传递 `todoId` 作为源值。\n\n你可以参考一下[这个例子](/examples/#fetching-data)的 `watchEffect` 和响应式的数据请求的操作。\n\n对于这种只有一个依赖项的例子来说，`watchEffect()` 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 `watchEffect()` 可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，`watchEffect()` 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。\n\n:::tip\n`watchEffect` 仅会在其**同步**执行期间，才追踪依赖。在使用异步回调时，只有在第一个 `await` 正常工作前访问到的属性才会被追踪。\n:::\n\n### `watch` vs. `watchEffect` {#watch-vs-watcheffect}\n\n`watch` 和 `watchEffect` 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：\n\n- `watch` 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。`watch` 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。\n\n- `watchEffect`，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。\n\n</div>\n\n## 副作用清理 {#side-effect-cleanup}\n\n有时我们可能会在侦听器中执行副作用，例如异步请求：\n\n<div class=\"composition-api\">\n\n```js\nwatch(id, (newId) => {\n  fetch(`/api/${newId}`).then(() => {\n    // 回调逻辑\n  })\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  watch: {\n    id(newId) {\n      fetch(`/api/${newId}`).then(() => {\n        // 回调逻辑\n      })\n    }\n  }\n}\n```\n\n</div>\n\n但是如果在请求完成之前 `id` 发生了变化怎么办？当上一个请求完成时，它仍会使用已经过时的 ID 值触发回调。理想情况下，我们希望能够在 `id` 变为新值时取消过时的请求。\n\n我们可以使用 [`onWatcherCleanup()`](/api/reactivity-core#onwatchercleanup) <sup class=\"vt-badge\" data-text=\"3.5+\" /> API 来注册一个清理函数，当侦听器失效并准备重新运行时会被调用：\n\n<div class=\"composition-api\">\n\n```js {10-13}\nimport { watch, onWatcherCleanup } from 'vue'\n\nwatch(id, (newId) => {\n  const controller = new AbortController()\n\n  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {\n    // 回调逻辑\n  })\n\n  onWatcherCleanup(() => {\n    // 终止过期请求\n    controller.abort()\n  })\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js {12-15}\nimport { onWatcherCleanup } from 'vue'\n\nexport default {\n  watch: {\n    id(newId) {\n      const controller = new AbortController()\n\n      fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {\n        // 回调逻辑\n      })\n\n      onWatcherCleanup(() => {\n        // 终止过期请求\n        controller.abort()\n      })\n    }\n  }\n}\n```\n\n</div>\n\n请注意，`onWatcherCleanup` 仅在 Vue 3.5+ 中支持，并且必须在 `watchEffect` 效果函数或 `watch` 回调函数的同步执行期间调用：你不能在异步函数的 `await` 语句之后调用它。\n\n作为替代，`onCleanup` 函数还作为第三个参数传递给侦听器回调<span class=\"composition-api\">，以及 `watchEffect` 作用函数的第一个参数</span>：\n\n<div class=\"composition-api\">\n\n```js\nwatch(id, (newId, oldId, onCleanup) => {\n  // ...\n  onCleanup(() => {\n    // 清理逻辑\n  })\n})\n\nwatchEffect((onCleanup) => {\n  // ...\n  onCleanup(() => {\n    // 清理逻辑\n  })\n})\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  watch: {\n    id(newId, oldId, onCleanup) {\n      // ...\n      onCleanup(() => {\n        // 清理逻辑\n      })\n    }\n  }\n}\n```\n\n</div>\n\n这在 3.5 之前的版本有效。此外，通过函数参数传递的 `onCleanup` 与侦听器实例相绑定，因此不受 `onWatcherCleanup` 的同步限制。\n\n## 回调的触发时机 {#callback-flush-timing}\n\n当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。\n\n类似于组件更新，用户创建的侦听器回调函数也会被批量处理以避免重复调用。例如，如果我们同步将一千个项目推入被侦听的数组中，我们可能不希望侦听器触发一千次。\n\n默认情况下，侦听器回调会在父组件更新 (如有) **之后**、所属组件的 DOM 更新**之前**被调用。这意味着如果你尝试在侦听器回调中访问所属组件的 DOM，那么 DOM 将处于更新前的状态。\n\n### Post Watchers {#post-watchers}\n\n如果想在侦听器回调中能访问被 Vue 更新**之后**的所属组件的 DOM，你需要指明 `flush: 'post'` 选项：\n\n<div class=\"options-api\">\n\n```js{6}\nexport default {\n  // ...\n  watch: {\n    key: {\n      handler() {},\n      flush: 'post'\n    }\n  }\n}\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n```js{2,6}\nwatch(source, callback, {\n  flush: 'post'\n})\n\nwatchEffect(callback, {\n  flush: 'post'\n})\n```\n\n后置刷新的 `watchEffect()` 有个更方便的别名 `watchPostEffect()`：\n\n```js\nimport { watchPostEffect } from 'vue'\n\nwatchPostEffect(() => {\n  /* 在 Vue 更新后执行 */\n})\n```\n\n</div>\n\n### 同步侦听器 {#sync-watchers}\n\n你还可以创建一个同步触发的侦听器，它会在 Vue 进行任何更新之前触发：\n\n<div class=\"options-api\">\n\n```js{6}\nexport default {\n  // ...\n  watch: {\n    key: {\n      handler() {},\n      flush: 'sync'\n    }\n  }\n}\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n```js{2,6}\nwatch(source, callback, {\n  flush: 'sync'\n})\n\nwatchEffect(callback, {\n  flush: 'sync'\n})\n```\n\n同步触发的 `watchEffect()` 有个更方便的别名 `watchSyncEffect()`：\n\n```js\nimport { watchSyncEffect } from 'vue'\n\nwatchSyncEffect(() => {\n  /* 在响应式数据变化时同步执行 */\n})\n```\n\n</div>\n\n:::warning 谨慎使用\n同步侦听器不会进行批处理，每当检测到响应式数据发生变化时就会触发。可以使用它来监视简单的布尔值，但应避免在可能多次同步修改的数据源 (如数组) 上使用。\n:::\n\n<div class=\"options-api\">\n\n## `this.$watch()` \\* {#this-watch}\n\n我们也可以使用组件实例的 [`$watch()` 方法](/api/component-instance#watch)来命令式地创建一个侦听器：\n\n```js\nexport default {\n  created() {\n    this.$watch('question', (newQuestion) => {\n      // ...\n    })\n  }\n}\n```\n\n如果要在特定条件下设置一个侦听器，或者只侦听响应用户交互的内容，这方法很有用。它还允许你提前停止该侦听器。\n\n</div>\n\n## 停止侦听器 {#stopping-a-watcher}\n\n<div class=\"options-api\">\n\n用 `watch` 选项或者 `$watch()` 实例方法声明的侦听器，会在宿主组件卸载时自动停止。因此，在大多数场景下，你无需关心怎么停止它。\n\n在少数情况下，你的确需要在组件卸载之前就停止一个侦听器，这时可以调用 `$watch()` API 返回的函数：\n\n```js\nconst unwatch = this.$watch('foo', callback)\n\n// ...当该侦听器不再需要时\nunwatch()\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n在 `setup()` 或 `<script setup>` 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。因此，在大多数情况下，你无需关心怎么停止一个侦听器。\n\n一个关键点是，侦听器必须用**同步**语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。如下方这个例子：\n\n```vue\n<script setup>\nimport { watchEffect } from 'vue'\n\n// 它会自动停止\nwatchEffect(() => {})\n\n// ...这个则不会！\nsetTimeout(() => {\n  watchEffect(() => {})\n}, 100)\n</script>\n```\n\n要手动停止一个侦听器，请调用 `watch` 或 `watchEffect` 返回的函数：\n\n```js\nconst unwatch = watchEffect(() => {})\n\n// ...当该侦听器不再需要时\nunwatch()\n```\n\n注意，需要异步创建侦听器的情况很少，请尽可能选择同步创建。如果需要等待一些异步数据，你可以使用条件式的侦听逻辑：\n\n```js\n// 需要异步请求得到的数据\nconst data = ref(null)\n\nwatchEffect(() => {\n  if (data.value) {\n    // 数据加载后执行某些操作...\n  }\n})\n```\n\n</div>\n\n<!-- zhlint disabled -->\n\n\n\n================================================\nFILE: src/guide/extras/animation.md\n================================================\n<script setup>\nimport ElasticHeader from './demos/ElasticHeader.vue'\nimport DisabledButton from './demos/DisabledButton.vue'\nimport Colors from './demos/Colors.vue'\nimport AnimateWatcher from './demos/AnimateWatcher.vue'\n</script>\n\n# 动画技巧 {#animation-techniques}\n\nVue 提供了 [`<Transition>`](/guide/built-ins/transition) 和 [`<TransitionGroup>`](/guide/built-ins/transition-group) 组件来处理元素进入、离开和列表顺序变化的过渡效果。但除此之外，还有许多其他制作网页动画的方式在 Vue 应用中也适用。这里我们会探讨一些额外的技巧。\n\n## 基于 CSS class 的动画 {#class-based-animations}\n\n对于那些不是正在进入或离开 DOM 的元素，我们可以通过给它们动态添加 CSS class 来触发动画：\n\n<div class=\"composition-api\">\n\n```js\nconst disabled = ref(false)\n\nfunction warnDisabled() {\n  disabled.value = true\n  setTimeout(() => {\n    disabled.value = false\n  }, 1500)\n}\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  data() {\n    return {\n      disabled: false\n    }\n  },\n  methods: {\n    warnDisabled() {\n      this.disabled = true\n      setTimeout(() => {\n        this.disabled = false\n      }, 1500)\n    }\n  }\n}\n```\n\n</div>\n\n```vue-html\n<div :class=\"{ shake: disabled }\">\n  <button @click=\"warnDisabled\">Click me</button>\n  <span v-if=\"disabled\">This feature is disabled!</span>\n</div>\n```\n\n```css\n.shake {\n  animation: shake 0.82s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;\n  transform: translate3d(0, 0, 0);\n}\n\n@keyframes shake {\n  10%,\n  90% {\n    transform: translate3d(-1px, 0, 0);\n  }\n\n  20%,\n  80% {\n    transform: translate3d(2px, 0, 0);\n  }\n\n  30%,\n  50%,\n  70% {\n    transform: translate3d(-4px, 0, 0);\n  }\n\n  40%,\n  60% {\n    transform: translate3d(4px, 0, 0);\n  }\n}\n```\n\n<DisabledButton />\n\n## 状态驱动的动画 {#state-driven-animations}\n\n有些过渡效果可以通过动态插值来实现，比如在交互时动态地给元素绑定样式。看下面这个例子：\n\n<div class=\"composition-api\">\n\n```js\nconst x = ref(0)\n\nfunction onMousemove(e) {\n  x.value = e.clientX\n}\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  data() {\n    return {\n      x: 0\n    }\n  },\n  methods: {\n    onMousemove(e) {\n      this.x = e.clientX\n    }\n  }\n}\n```\n\n</div>\n\n```vue-html\n<div\n  @mousemove=\"onMousemove\"\n  :style=\"{ backgroundColor: `hsl(${x}, 80%, 50%)` }\"\n  class=\"movearea\"\n>\n  <p>Move your mouse across this div...</p>\n  <p>x: {{ x }}</p>\n</div>\n```\n\n```css\n.movearea {\n  transition: 0.3s background-color ease;\n}\n```\n\n<Colors />\n\n除了颜色外，你还可以使用样式绑定 CSS transform、宽度或高度。你甚至可以通过运用弹性物理模拟为 SVG 添加动画，毕竟它们也只是 attribute 的数据绑定：\n\n<ElasticHeader />\n\n## 基于侦听器的动画 {#animating-with-watchers}\n\n通过发挥一些创意，我们可以基于一些数字状态，配合侦听器给任何东西加上动画。例如，我们可以将数字本身变成动画：\n\n<div class=\"composition-api\">\n\n```js\nimport { ref, reactive, watch } from 'vue'\nimport gsap from 'gsap'\n\nconst number = ref(0)\nconst tweened = reactive({\n  number: 0\n})\n\n// 注意：对于大于 Number.MAX_SAFE_INTEGER (9007199254740991) 的输入值，\n// 由于 JavaScript 数字精度的限制，结果可能不准确。\nwatch(number, (n) => {\n  gsap.to(tweened, { duration: 0.5, number: Number(n) || 0 })\n})\n```\n\n```vue-html\nType a number: <input v-model.number=\"number\" />\n<p>{{ tweened.number.toFixed(0) }}</p>\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nimport gsap from 'gsap'\nexport default {\n  data() {\n    return {\n      number: 0,\n      tweened: 0\n    }\n  },\n  // 注意：对于大于 Number.MAX_SAFE_INTEGER (9007199254740991) 的输入值，\n  // 由于 JavaScript 数字精度的限制，结果可能不准确。\n  watch: {\n    number(n) {\n      gsap.to(this, { duration: 0.5, tweened: Number(n) || 0 })\n    }\n  }\n}\n```\n\n```vue-html\nType a number: <input v-model.number=\"number\" />\n<p>{{ tweened.toFixed(0) }}</p>\n```\n\n</div>\n\n<AnimateWatcher />\n\n<div class=\"composition-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpNUstygzAM/BWNLyEzBDKd6YWSdHrpsacefSGgJG7xY7BImhL+vTKv9ILllXYlr+jEm3PJpUWRidyXjXIEHql1e2mUdrYh6KDBY8yfoiR1wRiuBZVn6OHYWA0r5q6W2pMv3ISHkBPSlNZ4AtPqAzawC2LRdj3DdEU0WA34qB910sBUnsFWmp6LpRmaRo9UHMLIrGG3h4EBQ/OEbDRpxjx51TYFKWtYKHmOF9WP4Qzs+x22EDoA9NLwmaejC/x+vhBqVxeEfAPIK3WBsi6830lRobZSDDjA580hFIt8roxrCS4bbSuskxFmzhhIAenEy92id1CnzZzfd91szETmZ72rH6zYOej7PA3rYXrKE3GUp//m5KunWx3C5CE6enS0hjZXVKczZXCwdfWyoF79YgZPqBliJ9iGSUTEYlzuRrO9X94a/lUGNTklvBTZvAMpwhYCIMWZyPksTVvjvk9JaXUacq9sSlujFJPnvej/AElH3FQ=)\n\n</div>\n<div class=\"options-api\">\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpNUctugzAQ/JWVLyESj6hSL5Sm6qXHnnr0xYENuAXbwus8Svj3GlxIJEvendHMvgb2bkx6cshyVtiyl4b2XMnO6J6gtsLAsdcdbKZwwxVXeJmpCo/CtQQDVwCVIBFtQwzQI7leLRmAct0B+xx28YLQGVFh5aGAjNM3zvRZUNnkizhII7V6w9xTSjqiRtoYBqhcL0hq5c3S5/hu/blKbzfYwbh9LMWVf0W2zusTws60gnDK6OtqEMTaeSGVcQSnpNMVtmmAXzkLAWeQzarCQNkKaz1zkHWysPthWNryjX/IC1bRbgvjWGTG64rssbQqLF3bKUzvHmH6o1aUnFHWDeVw0G31sqJW/mIOT9h5KEw2m7CYhUsmnV/at9XKX3n24v+E5WxdNmfTbieAs4bI2DzLnDI/dVrqLpu4Nz+/a5GzZYls/AM3dcFx)\n\n</div>\n\n\n\n================================================\nFILE: src/guide/extras/composition-api-faq.md\n================================================\n---\noutline: deep\n---\n\n# 组合式 API 常见问答 {#composition-api-faq}\n\n:::tip\n这个 FAQ 假定你已经有一些使用 Vue 的经验，特别是用选项式 API 使用 Vue 2 的经验。\n:::\n\n## 什么是组合式 API？ {#what-is-composition-api}\n\n<VueSchoolLink href=\"https://vueschool.io/lessons/introduction-to-the-vue-js-3-composition-api\" title=\"免费的组合式 API 课程\"/>\n\n组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了以下方面的 API：\n\n- [响应式 API](/api/reactivity-core)：例如 `ref()` 和 `reactive()`，使我们可以直接创建响应式状态、计算属性和侦听器。\n\n- [生命周期钩子](/api/composition-api-lifecycle)：例如 `onMounted()` 和 `onUnmounted()`，使我们可以在组件各个生命周期阶段添加逻辑。\n\n- [依赖注入](/api/composition-api-dependency-injection)：例如 `provide()` 和 `inject()`，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。\n\n组合式 API 是 Vue 3 及 [Vue 2.7](https://blog.vuejs.org/posts/vue-2-7-naruto.html) 的内置功能。对于更老的 Vue 2 版本，可以使用官方维护的插件 [`@vue/composition-api`](https://github.com/vuejs/composition-api)。在 Vue 3 中，组合式 API 基本上都会配合 [`<script setup>`](/api/sfc-script-setup.html) 语法在单文件组件中使用。下面是一个使用组合式 API 的组件示例：\n\n```vue\n<script setup>\nimport { ref, onMounted } from 'vue'\n\n// 响应式状态\nconst count = ref(0)\n\n// 更改状态、触发更新的函数\nfunction increment() {\n  count.value++\n}\n\n// 生命周期钩子\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n```\n\n虽然这套 API 的风格是基于函数的组合，但**组合式 API 并不是函数式编程**。组合式 API 是以 Vue 中数据可变的、细粒度的响应性系统为基础的，而函数式编程通常强调数据不可变。\n\n如果你对如何通过组合式 API 使用 Vue 感兴趣，可以通过页面左侧边栏上方的开关将 API 偏好切换到组合式 API，然后重新从头阅读指引。\n\n## 为什么要有组合式 API？ {#why-composition-api}\n\n### 更好的逻辑复用 {#better-logic-reuse}\n\n组合式 API 最基本的优势是它使我们能够通过[组合函数](/guide/reusability/composables)来实现更加简洁高效的逻辑复用。在选项式 API 中我们主要的逻辑复用机制是 mixins，而组合式 API 解决了 [mixins 的所有缺陷](/guide/reusability/composables#vs-mixins)。\n\n组合式 API 提供的逻辑复用能力孵化了一些非常棒的社区项目，比如 [VueUse](https://vueuse.org/)，一个不断成长的工具型组合式函数集合。组合式 API 还为其他第三方状态管理库与 Vue 的响应式系统之间的集成提供了一套简洁清晰的机制，例如[不可变数据](/guide/extras/reactivity-in-depth#immutable-data)、[状态机](/guide/extras/reactivity-in-depth#state-machines)与 [RxJS](/guide/extras/reactivity-in-depth#rxjs)。\n\n### 更灵活的代码组织 {#more-flexible-code-organization}\n\n许多用户喜欢选项式 API 的原因是它在默认情况下就能够让人写出有组织的代码：大部分代码都自然地被放进了对应的选项里。然而，选项式 API 在单个组件的逻辑复杂到一定程度时，会面临一些无法忽视的限制。这些限制主要体现在需要处理多个**逻辑关注点**的组件中，这是我们在许多 Vue 2 的实际案例中所观察到的。\n\n我们以 Vue CLI GUI 中的文件浏览器组件为例：这个组件承担了以下几个逻辑关注点：\n\n- 追踪当前文件夹的状态，展示其内容\n- 处理文件夹的相关操作 (打开、关闭和刷新)\n- 支持创建新文件夹\n- 可以切换到只展示收藏的文件夹\n- 可以开启对隐藏文件夹的展示\n- 处理当前工作目录中的变更\n\n这个组件[最原始的版本](https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404)是由选项式 API 写成的。如果我们为相同的逻辑关注点标上一种颜色，那将会是这样：\n\n<img alt=\"folder component before\" src=\"https://user-images.githubusercontent.com/499550/62783021-7ce24400-ba89-11e9-9dd3-36f4f6b1fae2.png\" width=\"129\" height=\"500\" style=\"margin: 1.2em auto\">\n\n你可以看到，处理相同逻辑关注点的代码被强制拆分在了不同的选项中，位于文件的不同部分。在一个几百行的大组件中，要读懂代码中的一个逻辑关注点，需要在文件中反复上下滚动，这并不理想。另外，如果我们想要将一个逻辑关注点抽取重构到一个可复用的工具函数中，需要从文件的多个不同部分找到所需的正确片段。\n\n而如果[用组合式 API 重构](https://github.com/vuejs-translations/docs-zh-cn/blob/main/assets/FileExplorer.vue)这个组件，将会变成下面右边这样：\n\n![重构后的文件夹组件](https://user-images.githubusercontent.com/499550/62783026-810e6180-ba89-11e9-8774-e7771c8095d6.png)\n\n现在与同一个逻辑关注点相关的代码被归为了一组：我们无需再为了一个逻辑关注点在不同的选项块间来回滚动切换。此外，我们现在可以很轻松地将这一组代码移动到一个外部文件中，不再需要为了抽象而重新组织代码，大大降低了重构成本，这在长期维护的大型项目中非常关键。\n\n### 更好的类型推导 {#better-type-inference}\n\n近几年来，越来越多的开发者开始使用 [TypeScript](https://www.typescriptlang.org/) 书写更健壮可靠的代码，TypeScript 还提供了非常好的 IDE 开发支持。然而选项式 API 是在 2013 年被设计出来的，那时并没有把类型推导考虑进去，因此我们不得不做了一些[复杂到夸张的类型体操](https://github.com/vuejs/core/blob/44b95276f5c086e1d88fa3c686a5f39eb5bb7821/packages/runtime-core/src/componentPublicInstance.ts#L132-L165)才实现了对选项式 API 的类型推导。但尽管做了这么多的努力，选项式 API 的类型推导在处理 mixins 和依赖注入类型时依然不甚理想。\n\n因此，很多想要搭配 TS 使用 Vue 的开发者采用了由 `vue-class-component` 提供的 Class API。然而，基于 Class 的 API 非常依赖 ES 装饰器，在 2019 年我们开始开发 Vue 3 时，它仍是一个仅处于 stage 2 的语言功能。我们认为基于一个不稳定的语言提案去设计框架的核心 API 风险实在太大了，因此没有继续向 Class API 的方向发展。在那之后装饰器提案果然又发生了很大的变动，在 2022 年才终于到达 stage 3。另一个问题是，基于 Class 的 API 和选项式 API 在逻辑复用和代码组织方面存在相同的限制。\n\n相比之下，组合式 API 主要利用基本的变量和函数，它们本身就是类型友好的。用组合式 API 重写的代码可以享受到完整的类型推导，不需要书写太多类型标注。大多数时候，用 TypeScript 书写的组合式 API 代码和用 JavaScript 写都差不太多！这也让许多纯 JavaScript 用户也能从 IDE 中享受到部分类型推导功能。\n\n### 更小的生产包体积 {#smaller-production-bundle-and-less-overhead}\n\n搭配 `<script setup>` 使用组合式 API 比等价情况下的选项式 API 更高效，对代码压缩也更友好。这是由于 `<script setup>` 形式书写的组件模板被编译为了一个内联函数，和 `<script setup>` 中的代码位于同一作用域。不像选项式 API 需要依赖 `this` 上下文对象访问属性，被编译的模板可以直接访问 `<script setup>` 中定义的变量，无需从实例中代理。这对代码压缩更友好，因为本地变量的名字可以被压缩，但对象的属性名则不能。\n\n## 与选项式 API 的关系 {#relationship-with-options-api}\n\n### 取舍 {#trade-offs}\n\n一些从选项式 API 迁移来的用户发现，他们的组合式 API 代码缺乏组织性，并得出了组合式 API 在代码组织方面“更糟糕”的结论。我们建议持有这类观点的用户换个角度思考这个问题。\n\n组合式 API 不像选项式 API 那样会手把手教你该把代码放在哪里。但反过来，它却让你可以像编写普通的 JavaScript 那样来编写组件代码。这意味着**你能够，并且应该在写组合式 API 的代码时也运用上所有普通 JavaScript 代码组织的最佳实践**。如果你可以编写组织良好的 JavaScript，你也应该有能力编写组织良好的组合式 API 代码。\n\n选项式 API 确实允许你在编写组件代码时“少思考”，这是许多用户喜欢它的原因。然而，在减少费神思考的同时，它也将你锁定在规定的代码组织模式中，没有摆脱的余地，这会导致在更大规模的项目中难以进行重构或提高代码质量。在这方面，组合式 API 提供了更好的长期可维护性。\n\n### 组合式 API 是否覆盖了所有场景？ {#does-composition-api-cover-all-use-cases}\n\n组合式 API 能够覆盖所有状态逻辑方面的需求。除此之外，只需要用到一小部分选项：`props`，`emits`，`name` 和 `inheritAttrs`。\n\n:::tip\n\n从 3.3 开始你可以直接通过 `<script setup>` 中的 `defineOptions` 来设置组件名或 `inheritAttrs` 属性。\n\n:::\n\n如果你在代码中只使用了组合式 API (以及上述必需的选项)，那么你可以通过配置[编译时标记](/api/compile-time-flags)来去掉 Vue 运行时中针对选项式 API 支持的代码，从而减小生产包大概几 kb 左右的体积。注意这个配置也会影响你依赖中的 Vue 组件。\n\n### 可以在同一个组件中使用两种 API 吗？ {#can-i-use-both-apis-in-the-same-component}\n\n可以。你可以在一个选项式 API 的组件中通过 [`setup()`](/api/composition-api-setup) 选项来使用组合式 API。\n\n然而，我们只推荐你在一个已经基于选项式 API 开发了很久、但又需要和基于组合式 API 的新代码或是第三方库整合的项目中这样做。\n\n### 选项式 API 会被废弃吗？ {#will-options-api-be-deprecated}\n\n不会，我们没有任何计划这样做。选项式 API 也是 Vue 不可分割的一部分，也有很多开发者喜欢它。我们也意识到组合式 API 更适用于大型的项目，而对于中小型项目来说选项式 API 仍然是一个不错的选择。\n\n## 与 Class API 的关系 {#relationship-with-class-api}\n\n我们不再推荐在 Vue 3 中使用 Class API，因为组合式 API 提供了很好的 TypeScript 集成，并具有额外的逻辑重用和代码组织优势。\n\n## 和 React Hooks 的对比 {#comparison-with-react-hooks}\n\n组合式 API 提供了和 React Hooks 相同级别的逻辑组织能力，但它们之间有着一些重要的区别。\n\nReact Hooks 在组件每次更新时都会重新调用。这就产生了一些即使是经验丰富的 React 开发者也会感到困惑的问题。这也带来了一些性能问题，并且相当影响开发体验。例如：\n\n- Hooks 有严格的调用顺序，并不可以写在条件分支中。\n\n- React 组件中定义的变量会被一个钩子函数闭包捕获，若开发者传递了错误的依赖数组，它会变得“过期”。这导致了 React 开发者非常依赖 ESLint 规则以确保传递了正确的依赖，然而，这些规则往往不够智能，保持正确的代价过高，在一些边缘情况时会遇到令人头疼的、不必要的报错信息。\n\n- 昂贵的计算需要使用 `useMemo`，这也需要传入正确的依赖数组。\n\n- 在默认情况下，传递给子组件的事件处理函数会导致子组件进行不必要的更新。子组件默认更新，并需要显式的调用 `useCallback` 作优化。这个优化同样需要正确的依赖数组，并且几乎在任何时候都需要。忽视这一点会导致默认情况下对应用进行过度渲染，并可能在不知不觉中导致性能问题。\n\n- 要解决变量闭包导致的问题，再结合并发功能，使得很难推理出一段钩子代码是什么时候运行的，并且很不好处理需要在多次渲染间保持引用 (通过 `useRef`) 的可变状态。\n\n> 注意：上述一些与记忆化相关的问题可以通过即将推出的 [React Compiler](https://react.dev/learn/react-compiler) 解决。\n\n相比起来，Vue 的组合式 API：\n\n- 仅调用 `setup()` 或 `<script setup>` 的代码一次。这使得代码更符合日常 JavaScript 的直觉，不需要担心闭包变量的问题。组合式 API 也并不限制调用顺序，还可以有条件地进行调用。\n\n- Vue 的响应性系统运行时会自动收集计算属性和侦听器的依赖，因此无需手动声明依赖。\n\n- 无需手动缓存回调函数来避免不必要的组件更新。Vue 细粒度的响应性系统能够确保在绝大部分情况下组件仅执行必要的更新。对 Vue 开发者来说几乎不怎么需要对子组件更新进行手动优化。\n\n我们承认 React Hooks 的创造性，它是组合式 API 的一个主要灵感来源。然而，它的设计也确实存在上面提到的问题，而 Vue 的响应性模型恰好提供了一种解决这些问题的方法。\n\n\n\n================================================\nFILE: src/guide/extras/reactivity-in-depth.md\n================================================\n---\noutline: deep\n---\n\n<script setup>\nimport SpreadSheet from './demos/SpreadSheet.vue'\n</script>\n\n# 深入响应式系统 {#reactivity-in-depth}\n\nVue 最标志性的功能就是其低侵入性的响应式系统。组件状态都是由响应式的 JavaScript 对象组成的。当更改它们时，视图会随即自动更新。这让状态管理更加简单直观，但理解它是如何工作的也是很重要的，这可以帮助我们避免一些常见的陷阱。在本节中，我们将深入研究 Vue 响应性系统的一些底层细节。\n\n## 什么是响应性 {#what-is-reactivity}\n\n这个术语在今天的各种编程讨论中经常出现，但人们说它的时候究竟是想表达什么意思呢？本质上，响应性是一种可以使我们声明式地处理变化的编程范式。一个经常被拿来当作典型例子的用例即是 Excel 表格：\n\n<SpreadSheet />\n\n这里单元格 A2 中的值是通过公式 `= A0 + A1` 来定义的 (你可以在 A2 上点击来查看或编辑该公式)，因此最终得到的值为 3，正如所料。但如果你试着更改 A0 或 A1，你会注意到 A2 也随即自动更新了。\n\n而 JavaScript 默认并不是这样的。如果我们用 JavaScript 写类似的逻辑：\n\n```js\nlet A0 = 1\nlet A1 = 2\nlet A2 = A0 + A1\n\nconsole.log(A2) // 3\n\nA0 = 2\nconsole.log(A2) // 仍然是 3\n```\n\n当我们更改 `A0` 后，`A2` 不会自动更新。\n\n那么我们如何在 JavaScript 中做到这一点呢？首先，为了能重新运行计算的代码来更新 `A2`，我们需要将其包装为一个函数：\n\n```js\nlet A2\n\nfunction update() {\n  A2 = A0 + A1\n}\n```\n\n然后，我们需要定义几个术语：\n\n- 这个 `update()` 函数会产生一个**副作用**，或者就简称为**作用** (effect)，因为它会更改程序里的状态。\n\n- `A0` 和 `A1` 被视为这个作用的**依赖** (dependency)，因为它们的值被用来执行这个作用。因此这次作用也可以被称作它的依赖的一个**订阅者** (subscriber)。\n\n我们需要一个魔法函数，能够在 `A0` 或 `A1` (这两个**依赖**) 变化时调用 `update()` (产生**作用**)。\n\n```js\nwhenDepsChange(update)\n```\n\n这个 `whenDepsChange()` 函数有如下的任务：\n\n1. 当一个变量被读取时进行追踪。例如我们执行了表达式 `A0 + A1` 的计算，则 `A0` 和 `A1` 都被读取到了。\n\n2. 如果一个变量在当前运行的副作用中被读取了，就将该副作用设为此变量的一个订阅者。例如由于 `A0` 和 `A1` 在 `update()` 执行时被访问到了，则 `update()` 需要在第一次调用之后成为 `A0` 和 `A1` 的订阅者。\n\n3. 探测一个变量的变化。例如当我们给 `A0` 赋了一个新的值后，应该通知其所有订阅了的副作用重新执行。\n\n## Vue 中的响应性是如何工作的 {#how-reactivity-works-in-vue}\n\n我们无法直接追踪对上述示例中局部变量的读写，原生 JavaScript 没有提供任何机制能做到这一点。**但是**，我们是可以追踪**对象属性**的读写的。\n\n在 JavaScript 中有两种劫持 property 访问的方式：[getter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#description) / [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set#description) 和 [Proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)。Vue 2 使用 getter / setters 完全是出于支持旧版本浏览器的限制。而在 Vue 3 中则使用了 Proxy 来创建响应式对象，仅将 getter / setter 用于 ref。下面的伪代码将会说明它们是如何工作的：\n\n```js{4,9,17,22}\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get(target, key) {\n      track(target, key)\n      return target[key]\n    },\n    set(target, key, value) {\n      target[key] = value\n      trigger(target, key)\n    }\n  })\n}\n\nfunction ref(value) {\n  const refObject = {\n    get value() {\n      track(refObject, 'value')\n      return value\n    },\n    set value(newValue) {\n      value = newValue\n      trigger(refObject, 'value')\n    }\n  }\n  return refObject\n}\n```\n\n:::tip\n这里和下面的代码片段皆旨在以最简单的形式解释核心概念，因此省略了许多细节和边界情况。\n:::\n\n以上代码解释了我们在基础章节部分讨论过的一些 [`reactive()` 的局限性](/guide/essentials/reactivity-fundamentals#limitations-of-reactive)：\n\n- 当你将一个响应式对象的属性赋值或解构到一个本地变量时，访问或赋值该变量是非响应式的，因为它将不再触发源对象上的 get / set 代理。注意这种“断开”只影响变量绑定——如果变量指向一个对象之类的非原始值，那么对该对象的修改仍然是响应式的。\n\n- 从 `reactive()` 返回的代理尽管行为上表现得像原始对象，但我们通过使用 `===` 运算符还是能够比较出它们的不同。\n\n在 `track()` 内部，我们会检查当前是否有正在运行的副作用。如果有，我们会查找到一个存储了所有追踪了该属性的订阅者的 Set，然后将当前这个副作用作为新订阅者添加到该 Set 中。\n\n```js\n// 这会在一个副作用就要运行之前被设置\n// 我们会在后面处理它\nlet activeEffect\n\nfunction track(target, key) {\n  if (activeEffect) {\n    const effects = getSubscribersForProperty(target, key)\n    effects.add(activeEffect)\n  }\n}\n```\n\n副作用订阅将被存储在一个全局的 `WeakMap<target, Map<key, Set<effect>>>` 数据结构中。如果在第一次追踪时没有找到对相应属性订阅的副作用集合，它将会在这里新建。这就是 `getSubscribersForProperty()` 函数所做的事。为了简化描述，我们跳过了它其中的细节。\n\n在 `trigger()` 之中，我们会再查找到该属性的所有订阅副作用。但这一次我们需要执行它们：\n\n```js\nfunction trigger(target, key) {\n  const effects = getSubscribersForProperty(target, key)\n  effects.forEach((effect) => effect())\n}\n```\n\n现在让我们回到 `whenDepsChange()` 函数中：\n\n```js\nfunction whenDepsChange(update) {\n  const effect = () => {\n    activeEffect = effect\n    update()\n    activeEffect = null\n  }\n  effect()\n}\n```\n\n它将原本的 `update` 函数包装在了一个副作用函数中。在运行实际的更新之前，这个外部函数会将自己设为当前活跃的副作用。这使得在更新期间的 `track()` 调用都能定位到这个当前活跃的副作用。\n\n此时，我们已经创建了一个能自动跟踪其依赖的副作用，它会在任意依赖被改动时重新运行。我们称其为**响应式副作用**。\n\nVue 提供了一个 API 来让你创建响应式副作用 [`watchEffect()`](/api/reactivity-core#watcheffect)。事实上，你会发现它的使用方式和我们上面示例中说的魔法函数 `whenDepsChange()` 非常相似。我们可以用真正的 Vue API 改写上面的例子：\n\n```js\nimport { ref, watchEffect } from 'vue'\n\nconst A0 = ref(0)\nconst A1 = ref(1)\nconst A2 = ref()\n\nwatchEffect(() => {\n  // 追踪 A0 和 A1\n  A2.value = A0.value + A1.value\n})\n\n// 将触发副作用\nA0.value = 2\n```\n\n使用一个响应式副作用来更改一个 ref 并不是最优解，事实上使用计算属性会更直观简洁：\n\n```js\nimport { ref, computed } from 'vue'\n\nconst A0 = ref(0)\nconst A1 = ref(1)\nconst A2 = computed(() => A0.value + A1.value)\n\nA0.value = 2\n```\n\n在内部，`computed` 会使用响应式副作用来管理失效与重新计算的过程。\n\n那么，常见的响应式副作用的用例是什么呢？自然是更新 DOM！我们可以像下面这样实现一个简单的“响应式渲染”：\n\n```js\nimport { ref, watchEffect } from 'vue'\n\nconst count = ref(0)\n\nwatchEffect(() => {\n  document.body.innerHTML = `Count is: ${count.value}`\n})\n\n// 更新 DOM\ncount.value++\n```\n\n实际上，这与 Vue 组件保持状态和 DOM 同步的方式非常接近——每个组件实例创建一个响应式副作用来渲染和更新 DOM。当然，Vue 组件使用了比 `innerHTML` 更高效的方式来更新 DOM。这会在[渲染机制](./rendering-mechanism)一章中详细介绍。\n\n<div class=\"options-api\">\n\n`ref()`、`computed()` 和 `watchEffect()` 这些 API 都是组合式 API 的一部分，如果你至今只使用过选项式 API，那么你需要知道的是组合式 API 更贴近 Vue 底层的响应式系统。事实上，Vue 3 中的选项式 API 正是基于组合式 API 建立的。对该组件实例 (`this`) 所有的属性访问都会触发 getter / setter 的响应式追踪，而像 `watch` 和 `computed` 这样的选项也是在内部调用相应等价的组合式 API。\n\n</div>\n\n## 运行时 vs. 编译时响应性 {#runtime-vs-compile-time-reactivity}\n\nVue 的响应式系统基本是基于运行时的。追踪和触发都是在浏览器中运行时进行的。运行时响应性的优点是，它可以在没有构建步骤的情况下工作，而且边界情况较少。另一方面，这使得它受到了 JavaScript 语法的制约，导致需要使用一些例如 Vue ref 这样的值的容器。\n\n一些框架，如 [Svelte](https://svelte.dev/)，选择通过编译时实现响应性来克服这种限制。它对代码进行分析和转换，以模拟响应性。该编译步骤允许框架改变 JavaScript 本身的语义——例如，隐式地注入执行依赖性分析的代码，以及围绕对本地定义的变量的访问进行作用触发。这样做的缺点是，该转换需要一个构建步骤，而改变 JavaScript 的语义实质上是在创造一种新语言，看起来像 JavaScript 但编译出来的东西是另外一回事。\n\nVue 团队确实曾通过一个名为[响应性语法糖](/guide/extras/reactivity-transform)的实验性功能来探索这个方向，但最后由于[这个原因](https://github.com/vuejs/rfcs/discussions/369#discussioncomment-5059028)，我们认为它不适合这个项目。\n\n## 响应性调试 {#reactivity-debugging}\n\nVue 的响应性系统可以自动跟踪依赖关系，但在某些情况下，我们可能希望确切地知道正在跟踪什么，或者是什么导致了组件重新渲染。\n\n### 组件调试钩子 {#component-debugging-hooks}\n\n我们可以在一个组件渲染时使用 <span class=\"options-api\">`renderTracked`</span><span class=\"composition-api\">`onRenderTracked`</span> 生命周期钩子来调试查看哪些依赖正在被使用，或是用 <span class=\"options-api\">`renderTriggered`</span><span class=\"composition-api\">`onRenderTriggered`</span> 来确定哪个依赖正在触发更新。这些钩子都会收到一个调试事件，其中包含了触发相关事件的依赖的信息。推荐在回调中放置一个 `debugger` 语句，使你可以在开发者工具中交互式地查看依赖：\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nimport { onRenderTracked, onRenderTriggered } from 'vue'\n\nonRenderTracked((event) => {\n  debugger\n})\n\nonRenderTriggered((event) => {\n  debugger\n})\n</script>\n```\n\n</div>\n<div class=\"options-api\">\n\n```js\nexport default {\n  renderTracked(event) {\n    debugger\n  },\n  renderTriggered(event) {\n    debugger\n  }\n}\n```\n\n</div>\n\n:::tip\n组件调试钩子仅会在开发模式下工作\n:::\n\n调试事件对象有如下的类型定义：\n\n<span id=\"debugger-event\"></span>\n\n```ts\ntype DebuggerEvent = {\n  effect: ReactiveEffect\n  target: object\n  type:\n    | TrackOpTypes /* 'get' | 'has' | 'iterate' */\n    | TriggerOpTypes /* 'set' | 'add' | 'delete' | 'clear' */\n  key: any\n  newValue?: any\n  oldValue?: any\n  oldTarget?: Map<any, any> | Set<any>\n}\n```\n\n### 计算属性调试 {#computed-debugging}\n\n<!-- TODO options API equivalent -->\n\n我们可以向 `computed()` 传入第二个参数，是一个包含了 `onTrack` 和 `onTrigger` 两个回调函数的对象：\n\n- `onTrack` 将在响应属性或引用作为依赖项被跟踪时被调用。\n- `onTrigger` 将在侦听器回调被依赖项的变更触发时被调用。\n\n这两个回调都会作为组件调试的钩子，接受[相同格式](#debugger-event)的调试事件：\n\n```js\nconst plusOne = computed(() => count.value + 1, {\n  onTrack(e) {\n    // 当 count.value 被追踪为依赖时触发\n    debugger\n  },\n  onTrigger(e) {\n    // 当 count.value 被更改时触发\n    debugger\n  }\n})\n\n// 访问 plusOne，会触发 onTrack\nconsole.log(plusOne.value)\n\n// 更改 count.value，应该会触发 onTrigger\ncount.value++\n```\n\n:::tip\n计算属性的 `onTrack` 和 `onTrigger` 选项仅会在开发模式下工作。\n:::\n\n### 侦听器调试 {#watcher-debugging}\n\n<!-- TODO options API equivalent -->\n\n和 `computed()` 类似，侦听器也支持 `onTrack` 和 `onTrigger` 选项：\n\n```js\nwatch(source, callback, {\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})\n\nwatchEffect(callback, {\n  onTrack(e) {\n    debugger\n  },\n  onTrigger(e) {\n    debugger\n  }\n})\n```\n\n:::tip\n侦听器的 `onTrack` 和 `onTrigger` 选项仅会在开发模式下工作。\n:::\n\n## 与外部状态系统集成 {#integration-with-external-state-systems}\n\nVue 的响应性系统是通过深度转换普通 JavaScript 对象为响应式代理来实现的。这种深度转换在一些情况下是不必要的，在和一些外部状态管理系统集成时，甚至是需要避免的 (例如，当一个外部的解决方案也用了 Proxy 时)。\n\n将 Vue 的响应性系统与外部状态管理方案集成的大致思路是：将外部状态放在一个 [`shallowRef`](/api/reactivity-advanced#shallowref) 中。一个浅层的 ref 中只有它的 `.value` 属性本身被访问时才是有响应性的，而不关心它内部的值。当外部状态改变时，替换此 ref 的 `.value` 才会触发更新。\n\n### 不可变数据 {#immutable-data}\n\n如果你正在实现一个撤销/重做的功能，你可能想要对用户编辑时应用的状态进行快照记录。然而，如果状态树很大的话，Vue 的可变响应性系统没法很好地处理这种情况，因为在每次更新时都序列化整个状态对象对 CPU 和内存开销来说都是非常昂贵的。\n\n[不可变数据结构](https://en.wikipedia.org/wiki/Persistent_data_structure)通过永不更改状态对象来解决这个问题。与 Vue 不同的是，它会创建一个新对象，保留旧的对象未发生改变的一部分。在 JavaScript 中有多种不同的方式来使用不可变数据，但我们推荐使用 [Immer](https://immerjs.github.io/immer/) 搭配 Vue，因为它使你可以在保持原有直观、可变的语法的同时，使用不可变数据。\n\n我们可以通过一个简单的组合式函数来集成 Immer：\n\n```js\nimport { produce } from 'immer'\nimport { shallowRef } from 'vue'\n\nexport function useImmer(baseState) {\n  const state = shallowRef(baseState)\n  const update = (updater) => {\n    state.value = produce(state.value, updater)\n  }\n\n  return [state, update]\n}\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9VMFu2zAM/RXNl6ZAYnfoTlnSdRt66DBsQ7vtEuXg2YyjRpYEUU5TBPn3UZLtuE1RH2KLfCIfycfsk8/GpNsGkmkyw8IK4xiCa8wVV6I22jq2Zw3CbV2DZQe2srpmZ2km/PmMK8a4KrRCxxbCQY1j1pgyd3DrD0s27++OFh689z/0OOEkTBlPvkNuFfvbAE/Gra/UilzOko0Mh2A+ufcHwd9ij8KtWUjwMsAqlxgjcLU854qrVaMKJ7RiTleVDBRHQpWwO4/xB8xHoRg2v+oyh/MioJepT0ClvTsxhnSUi1LOsthN6iMdCGgkBacTY7NGhjd9ScG2k5W2c56M9rG6ceBPdbOWm1AxO0/a+uiZFjJHpFv7Fj10XhdSFBtyntTJkzaxf/ZtQnYguoFNJkUkmAWGs2xAm47onqT/jPWHxjjYuUkJhba57+yUSaFg4tZWN9X6Y9eIcC8ZJ1FQkzo36QNqRZILQXjroAqnXb+9LQzVD3vtnMFpljXKbKq00HWU3/X7i/QivcxKgS5aUglVXjxNAGvK8KnWZSNJWa0KDoGChzmk3L28jSVcQX1o1d1puwfgOpdSP97BqsfQxhCCK9gFTC+tXu7/coR7R71rxRWXBL2FpHOMOAAeYVGJhBvFL3s+kGKIkW5zSfKfd+RHA2u3gzZEpML9y9JS06YtAq5DLFmOMWXsjkM6rET1YjzUcSMk2J/G1/h8TKGOb8HmV7bdQbqzhmLziv0Bd3Govywg2O1x8Umvua3ARffN/Q/S1sDZDfMN5x2glo3nGGFfGlUS7QEusL0NcxWq+o03OwcKu6Ke/+fwhIb89Y3Sj3Qv0w+9xg7/AWfvyMs=)\n\n### 状态机 {#state-machines}\n\n[状态机](https://en.wikipedia.org/wiki/Finite-state_machine)是一种数据模型，用于描述应用可能处于的所有可能状态，以及从一种状态转换到另一种状态的所有可能方式。虽然对于简单的组件来说，这可能有些小题大做了，但它的确可以使得复杂的状态流更加健壮和易于管理。\n\n[XState](https://xstate.js.org/) 是 JavaScript 中一个比较常用的状态机实现方案。这里是集成它的一个例子：\n\n```js\nimport { createMachine, interpret } from 'xstate'\nimport { shallowRef } from 'vue'\n\nexport function useMachine(options) {\n  const machine = createMachine(options)\n  const state = shallowRef(machine.initialState)\n  const service = interpret(machine)\n    .onTransition((newState) => (state.value = newState))\n    .start()\n  const send = (event) => service.send(event)\n\n  return [state, send]\n}\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp1U81unDAQfpWRL7DSFqqqUiXEJumhyqVVpDa3ugcKZtcJjC1syEqId8/YBu/uIRcEM9/P/DGz71pn0yhYwUpTD1JbMMKO+o6j7LUaLMwwGvGrqk8SBSzQDqqHJMv7EMleTMIRgGOt0Fj4a2xlxZ5EsPkHhytuOjucbApIrDoeO5HsfQCllVVHUYlVbeW0xr2OKcCzHCwkKQAK3fP56fHx5w/irSyqbfFMgA+h0cKBHZYey45jmYfeqWv6sKLXHbnTF0D5f7RWITzUnaxfD5y5ztIkSCY7zjwKYJ5DyVlf2fokTMrZ5sbZDu6Bs6e25QwK94b0svgKyjwYkEyZR2e2Z2H8n/pK04wV0oL8KEjWJwxncTicnb23C3F2slabIs9H1K/HrFZ9HrIPX7Mv37LPuTC5xEacSfa+V83YEW+bBfleFkuW8QbqQZDEuso9rcOKQQ/CxosIHnQLkWJOVdept9+ijSA6NEJwFGePaUekAdFwr65EaRcxu9BbOKq1JDqnmzIi9oL0RRDu4p1u/ayH9schrhlimGTtOLGnjeJRAJnC56FCQ3SFaYriLWjA4Q7SsPOp6kYnEXMbldKDTW/ssCFgKiaB1kusBWT+rkLYjQiAKhkHvP2j3IqWd5iMQ+M=)\n\n### RxJS {#rxjs}\n\n[RxJS](https://rxjs.dev/) 是一个用于处理异步事件流的库。[VueUse](https://vueuse.org/) 库提供了 [`@vueuse/rxjs`](https://vueuse.org/rxjs/readme.html) 扩展来支持连接 RxJS 流与 Vue 的响应性系统。\n\n## 与信号 (signal) 的联系 {#connection-to-signals}\n\n很多其他框架已经引入了与 Vue 组合式 API 中的 ref 类似的响应性基础类型，并称之为“信号”：\n\n- [Solid 信号](https://www.solidjs.com/docs/latest/api#createsignal)\n- [Angular 信号](https://angular.dev/guide/signals)\n- [Preact 信号](https://preactjs.com/guide/v10/signals/)\n- [Qwik 信号](https://qwik.builder.io/docs/components/state/#usesignal)\n\n从根本上说，信号是与 Vue 中的 ref 相同的响应性基础类型。它是一个在访问时跟踪依赖、在变更时触发副作用的值容器。这种基于响应性基础类型的范式在前端领域并不是一个特别新的概念：它可以追溯到十多年前的 [Knockout observables](https://knockoutjs.com/documentation/observables.html) 和 [Meteor Tracker](https://docs.meteor.com/api/tracker.html) 等实现。Vue 的选项式 API 和 React 的状态管理库 [MobX](https://mobx.js.org/) 也是基于同样的原则，只不过将基础类型这部分隐藏在了对象属性背后。\n\n虽然这并不是信号的必要特征，但如今这个概念经常与细粒度订阅和更新的渲染模型一起讨论。由于使用了虚拟 DOM，Vue 目前[依靠编译器来实现类似的优化](/guide/extras/rendering-mechanism#compiler-informed-virtual-dom)。然而，我们也在探索一种新的、受 Solid 启发的、名为 [Vapor Mode](https://github.com/vuejs/core-vapor) 的编译策略，它不依赖于虚拟 DOM，而是更多地利用 Vue 的内置响应性系统。\n\n### API 设计权衡 {#api-design-trade-offs}\n\nPreact 和 Qwik 的信号设计与 Vue 的 [shallowRef](/api/reactivity-advanced#shallowref) 非常相似：三者都通过 `.value` 属性提供了一个更改接口。我们将重点讨论 Solid 和 Angular 的信号。\n\n#### Solid Signals {#solid-signals}\n\nSolid 的 `createSignal()` API 设计强调了读/写隔离。信号通过一个只读的 getter 和另一个单独的 setter 暴露：\n\n```js\nconst [count, setCount] = createSignal(0)\n\ncount() // 访问值\nsetCount(1) // 更新值\n```\n\n注意到 `count` 信号在没有 setter 的情况也能传递。这就保证了除非 setter 也被明确暴露，否则状态永远不会被改变。这种更冗长的语法带来的安全保证的合理性取决于项目的要求和个人品味——但如果你喜欢这种 API 风格，可以轻易地在 Vue 中复制它：\n\n```js\nimport { shallowRef, triggerRef } from 'vue'\n\nexport function createSignal(value, options) {\n  const r = shallowRef(value)\n  const get = () => r.value\n  const set = (v) => {\n    r.value = typeof v === 'function' ? v(r.value) : v\n    if (options?.equals === false) triggerRef(r)\n  }\n  return [get, set]\n}\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNpdUk1TgzAQ/Ss7uQAjgr12oNXxH+ix9IAYaDQkMV/qMPx3N6G0Uy9Msu/tvn2PTORJqcI7SrakMp1myoKh1qldI9iopLYwQadpa+krG0TLYYZeyxGSojSSs/d7E8vFh0ka0YhOCmPh0EknbB4mPYfTEeqbIelD1oiqXPRQCS+WjoojAW8A1Wmzm1A39KYZzHNVYiUib85aKeCx46z7rBuySqQe6h14uINN1pDIBWACVUcqbGwtl17EqvIiR3LyzwcmcXFuTi3n8vuF9jlYzYaBajxfMsDcomv6E/m9E51luN2NV99yR3OQKkAmgykss+SkMZerxMLEZFZ4oBYJGAA600VEryAaD6CPaJwJKwnr9ldR2WMedV1Dsi6WwB58emZlsAV/zqmH9LzfvqBfruUmNvZ4QN7VearjenP4aHwmWsABt4x/+tiImcx/z27Jqw==)\n\n#### Angular 信号 {#angular-signals}\n\nAngular 正在经历一些底层的变化，它放弃了脏检查，并引入了自己的响应性基础类型实现。Angular 的信号 API 看起来像这样：\n\n```js\nconst count = signal(0)\n\ncount() // 访问值\ncount.set(1) // 设置值\ncount.update((v) => v + 1) // 通过前值更新\n```\n\n同样，我们可以轻易地在 Vue 中复制这个 API：\n\n```js\nimport { shallowRef } from 'vue'\n\nexport function signal(initialValue) {\n  const r = shallowRef(initialValue)\n  const s = () => r.value\n  s.set = (value) => {\n    r.value = value\n  }\n  s.update = (updater) => {\n    r.value = updater(r.value)\n  }\n  return s\n}\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNp9Ul1v0zAU/SuWX9ZCSRh7m9IKGHuAB0AD8WQJZclt6s2xLX+ESlH+O9d2krbr1Df7nnPu17k9/aR11nmgt7SwleHaEQvO6w2TvNXKONITyxtZihWpVKu9g5oMZGtUS66yvJSNF6V5lyjZk71ikslKSeuQ7qUj61G+eL+cgFr5RwGITAkXiyVZb5IAn2/IB+QWeeoHO8GPg1aL0gH+CCl215u7mJ3bW9L3s3IYihyxifMlFRpJqewL1qN3TknysRK8el4zGjNlXtdYa9GFrjryllwvGY18QrisDLQgXZTnSX8pF64zzD7pDWDghbbI5/Hoip7tFL05eLErhVD/HmB75Edpyd8zc9DUaAbso3TrZeU4tjfawSV3vBR/SuFhSfrQUXLHBMvmKqe8A8siK7lmsi5gAbJhWARiIGD9hM7BIfHSgjGaHljzlDyGF2MEPQs6g5dpcAIm8Xs+2XxODTgUn0xVYdJ5RxPhKOd4gdMsA/rgLEq3vEEHlEQPYrbgaqu5APNDh6KWUTyuZC2jcWvfYswZD6spXu2gen4l/mT3Icboz3AWpgNGZ8yVBttM8P2v77DH9wy2qvYC2RfAB7BK+NBjon32ssa2j3ix26/xsrhsftv7vQNpp6FCo4E5RD6jeE93F0Y/tHuT3URd2OLwHyXleRY=)\n\n与 Vue 的 ref 相比，Solid 和 Angular 基于 getter 的 API 风格在 Vue 组件中使用时提供了一些有趣的权衡：\n\n- `()` 比 `.value` 略微省事，但更新值却更冗长；\n- 没有 ref 解包：总是需要通过 `()` 来访问值。这使得值的访问在任何地方都是一致的。这也意味着你可以将原始信号作为组件的参数传递下去。\n\n这些 API 风格是否适合你，在某种程度上是主观的。我们在这里的目标是展示这些不同的 API 设计之间的基本相似性和取舍。我们还想说明 Vue 是灵活的：你并没有真正被限定在现有的 API 中。如有必要，你可以创建你自己的响应性基础 API，以满足更多的具体需求。\n\n\n\n================================================\nFILE: src/guide/extras/reactivity-transform.md\n================================================\n# 响应性语法糖 {#reactivity-transform}\n\n:::danger 已移除的实验性功能\n响应性语法糖曾经是一个实验性功能，且已在最新的 3.4 版本中被移除，请阅读[废弃原因](https://github.com/vuejs/rfcs/discussions/369#discussioncomment-5059028)。\n\n如果仍然打算使用它，你现在可以使用 [Vue Macros](https://vue-macros.sxzz.moe/features/reactivity-transform.html) 插件。\n:::\n\n:::tip 组合式 API 特有\n响应性语法糖是组合式 API 特有的功能，且必须通过构建步骤使用。\n:::\n\n## ref vs. 响应式变量 {#refs-vs-reactive-variables}\n\n自从引入组合式 API 的概念以来，一个主要的未解决的问题就是 ref 和响应式对象到底用哪个。响应式对象存在解构丢失响应性的问题，而 ref 需要到处使用 `.value` 则感觉很繁琐，并且在没有类型系统的帮助时很容易漏掉 `.value`。\n\n[Vue 的响应性语法糖](https://github.com/vuejs/core/tree/main/packages/reactivity-transform)是一个编译时的转换步骤，让我们可以像这样书写代码：\n\n```vue\n<script setup>\nlet count = $ref(0)\n\nconsole.log(count)\n\nfunction increment() {\n  count++\n}\n</script>\n\n<template>\n  <button @click=\"increment\">{{ count }}</button>\n</template>\n```\n\n这里的这个 `$ref()` 方法是一个**编译时的宏命令**：它不是一个真实的、在运行时会调用的方法。而是用作 Vue 编译器的标记，表明最终的 `count` 变量需要是一个**响应式变量**。\n\n响应式的变量可以像普通变量那样被访问和重新赋值，但这些操作在编译后都会变为带 `.value` 的 ref。比如上面例子中 `<script>` 部分的代码就被编译成了下面这样：\n\n```js{5,8}\nimport { ref } from 'vue'\n\nlet count = ref(0)\n\nconsole.log(count.value)\n\nfunction increment() {\n  count.value++\n}\n```\n\n每一个会返回 ref 的响应式 API 都有一个相对应的、以 `$` 为前缀的宏函数。包括以下这些 API：\n\n- [`ref`](/api/reactivity-core#ref) -> `$ref`\n- [`computed`](/api/reactivity-core#computed) -> `$computed`\n- [`shallowRef`](/api/reactivity-advanced#shallowref) -> `$shallowRef`\n- [`customRef`](/api/reactivity-advanced#customref) -> `$customRef`\n- [`toRef`](/api/reactivity-utilities#toref) -> `$toRef`\n\n当启用响应性语法糖时，这些宏函数都是全局可用的、无需手动导入。但如果你想让它更明显，你也可以选择从 `vue/macros` 中引入它们：\n\n```js\nimport { $ref } from 'vue/macros'\n\nlet count = $ref(0)\n```\n\n## 通过 `$()` 解构 {#destructuring-with}\n\n我们常常会让一个组合函数返回一个含数个 ref 的对象，然后解构得到这些 ref。对于这种场景，响应性语法糖提供了一个 **`$()`** 宏：\n\n```js\nimport { useMouse } from '@vueuse/core'\n\nconst { x, y } = $(useMouse())\n\nconsole.log(x, y)\n```\n\n编译输出为：\n\n```js\nimport { toRef } from 'vue'\nimport { useMouse } from '@vueuse/core'\n\nconst __temp = useMouse(),\n  x = toRef(__temp, 'x'),\n  y = toRef(__temp, 'y')\n\nconsole.log(x.value, y.value)\n```\n\n请注意如果 `x` 已经是一个 ref，`toRef(__temp, 'x')` 则会简单地返回它本身，而不会再创建新的 ref。如果一个被解构的值不是 ref (例如是一个函数)，也仍然可以使用，这个值会被包装进一个 ref，因此其他代码都会正常工作。\n\n对 `$()` 的解构在响应式对象**和**包含数个 ref 的对象都可用。\n\n## 用 `$()` 将现存的 ref 转换为响应式对象 {#convert-existing-refs-to-reactive-variables-with}\n\n在某些场景中我们可能已经有了会返回 ref 的函数。然而，Vue 编译器并不能够提前知道该函数会返回一个 ref。那么此时可以使用 `$()` 宏来将现存的 ref 转换为响应式变量。\n\n```js\nfunction myCreateRef() {\n  return ref(0)\n}\n\nlet count = $(myCreateRef())\n```\n\n## 响应式 props 解构 {#reactive-props-destructure}\n\n现在的 `<script setup>` 中对 `defineProps` 宏的使用有两个痛点：\n\n1. 和 `.value` 类似，为了保持响应性，你始终需要以 `props.x` 的方式访问这些 prop。这意味着你不能够解构 `defineProps` 的返回值，因为得到的变量将不是响应式的、也不会更新。\n\n2. 当使用[基于类型的 props 的声明](https://v3.vuejs.org/api/sfc-script-setup#type-only-props-emit-declarations)时，无法很方便地声明这些 prop 的默认值。为此我们提供了 `withDefaults()` 这个 API，但使用起来仍然很笨拙。\n\n当 `defineProps` 与解构一起使用时，我们可以通过应用编译时转换来解决这些问题，类似于我们之前看到的 `$()`：\n\n```html\n<script setup lang=\"ts\">\n  interface Props {\n    msg: string\n    count?: number\n    foo?: string\n  }\n\n  const {\n    msg,\n    // 默认值正常可用\n    count = 1,\n    // 解构时命别名也可用\n    // 这里我们就将 `props.foo` 命别名为 `bar`\n    foo: bar\n  } = defineProps<Props>()\n\n  watchEffect(() => {\n    // 会在 props 变化时打印\n    console.log(msg, count, bar)\n  })\n</script>\n```\n\n上面的代码将被编译成下面这样的运行时声明：\n\n```js\nexport default {\n  props: {\n    msg: { type: String, required: true },\n    count: { type: Number, default: 1 },\n    foo: String\n  },\n  setup(props) {\n    watchEffect(() => {\n      console.log(props.msg, props.count, props.foo)\n    })\n  }\n}\n```\n\n## 保持在函数间传递时的响应性 {#retaining-reactivity-across-function-boundaries}\n\n虽然响应式变量使我们可以不再受 `.value` 的困扰，但它也使得我们在函数间传递响应式变量时可能造成“响应性丢失”的问题。这可能在以下两种场景中出现：\n\n### 以参数形式传入函数 {#passing-into-function-as-argument}\n\n假设有一个期望接收一个 ref 对象为参数的函数：\n\n```ts\nfunction trackChange(x: Ref<number>) {\n  watch(x, (x) => {\n    console.log('x 改变了！')\n  })\n}\n\nlet count = $ref(0)\ntrackChange(count) // 无效！\n```\n\n上面的例子不会正常工作，因为代码被编译成了这样：\n\n```ts\nlet count = ref(0)\ntrackChange(count.value)\n```\n\n这里的 `count.value` 是以一个 number 类型值的形式传入，然而 `trackChange` 期望接收的是一个真正的 ref。要解决这个问题，可以在将 `count` 作为参数传入之前，用 `$$()` 包装：\n\n```diff\nlet count = $ref(0)\n- trackChange(count)\n+ trackChange($$(count))\n```\n\n上面的代码将被编译成：\n\n```js\nimport { ref } from 'vue'\n\nlet count = ref(0)\ntrackChange(count)\n```\n\n我们可以看到，`$$()` 的效果就像是一个**转义标识**：`$$()` 中的响应式变量不会追加上 `.value`。\n\n### 作为函数返回值 {#returning-inside-function-scope}\n\n如果将响应式变量直接放在返回值表达式中会丢失掉响应性：\n\n```ts\nfunction useMouse() {\n  let x = $ref(0)\n  let y = $ref(0)\n\n  // 监听 mousemove 事件\n\n  // 不起效！\n  return {\n    x,\n    y\n  }\n}\n```\n\n上面的语句将被翻译为：\n\n```ts\nreturn {\n  x: x.value,\n  y: y.value\n}\n```\n\n为了保持响应性，我们需要返回的是真正的 ref，而不是返回时 ref 内的值。\n\n我们还是可以使用 `$$()` 来解决这个问题。在这个例子中，`$$()` 可以直接用在要返回的对象上，`$$()` 调用时任何对响应式变量的引用都会保留为对相应 ref 的引用：\n\n```ts\nfunction useMouse() {\n  let x = $ref(0)\n  let y = $ref(0)\n\n  // 监听 mousemove 事件\n\n  // 修改后起效\n  return $$({\n    x,\n    y\n  })\n}\n```\n\n### 在已解构的 props 上使用 `$$()` {#using-on-destructured-props}\n\n`$$()` 也适用于已解构的 props，因为它们也是响应式的变量。编译器会高效地通过 `toRef` 来做转换：\n\n```ts\nconst { count } = defineProps<{ count: number }>()\n\npassAsRef($$(count))\n```\n\n编译结果为：\n\n```js\nsetup(props) {\n  const __props_count = toRef(props, 'count')\n  passAsRef(__props_count)\n}\n```\n\n## TypeScript 集成 <sup class=\"vt-badge ts\" /> {#typescript-integration}\n\nVue 为这些宏函数都提供了类型声明 (全局可用)，因此类型推导都会符合预期。它与标准的 TypeScript 语义没有不兼容之处，因此它的语法可以与所有现有的工具兼容。\n\n这也意味着这些宏函数在任何 JS / TS 文件中都是合法的，不是仅能在 Vue 单文件组件中使用。\n\n因为这些宏函数都是全局可用的，它们的类型需要被显式地引用 (例如，在 `env.d.ts` 文件中)：\n\n```ts\n/// <reference types=\"vue/macros-global\" />\n```\n\n若你是从 `vue/macros` 中显式引入宏函数时，则不需要像这样全局声明。\n\n## 显式启用 {#explicit-opt-in}\n\n:::danger Core 不再支持\n以下内容仅适用于 Vue 3.3 及以下版本。Vue core 3.4 及以上版本和 `@vitejs/plugin-vue` 5.0 及以上版本已经将其移除。如需继续使用，请迁移至 [Vue Macros](https://vue-macros.sxzz.moe/features/reactivity-transform.html)。\n:::\n\n### Vite {#vite}\n\n- 需要 `@vitejs/plugin-vue@>=2.0.0`\n- 应用于单文件组件和 js(x)/ts(x) 文件。在执行转换之前，会对文件进行快速的使用检查，因此不使用宏的文件不会有性能损失。\n- 注意 `reactivityTransform` 现在是一个插件的顶层选项，而不再是位于 `script.refSugar` 之中了，因为它不仅仅只对单文件组件起效。\n\n```js [vite.config.js]\nexport default {\n  plugins: [\n    vue({\n      reactivityTransform: true\n    })\n  ]\n}\n```\n\n### `vue-cli` {#vue-cli}\n\n- 目前仅对单文件组件起效\n- 需要 `vue-loader@>=17.0.0`\n\n```js [vue.config.js]\nmodule.exports = {\n  chainWebpack: (config) => {\n    config.module\n      .rule('vue')\n      .use('vue-loader')\n      .tap((options) => {\n        return {\n          ...options,\n          reactivityTransform: true\n        }\n      })\n  }\n}\n```\n\n### 仅用 `webpack` + `vue-loader` {#plain-webpack-vue-loader}\n\n- 目前仅对单文件组件起效\n- 需要 `vue-loader@>=17.0.0`\n\n```js [webpack.config.js]\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: {\n          reactivityTransform: true\n        }\n      }\n    ]\n  }\n}\n```\n\n\n\n================================================\nFILE: src/guide/extras/render-function.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/extras/rendering-mechanism.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/extras/ways-of-using-vue.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/extras/web-components.md\n================================================\n# Vue 与 Web Components {#vue-and-web-components}\n\n[Web Components](https://developer.mozilla.org/en-US/docs/Web/Web_Components) 是一组 web 原生 API 的统称，允许开发者创建可复用的自定义元素 (custom elements)。\n\n我们认为 Vue 和 Web Components 是互补的技术。Vue 为使用和创建自定义元素提供了出色的支持。无论你是将自定义元素集成到现有的 Vue 应用中，还是使用 Vue 来构建和分发自定义元素都很方便。\n\n## 在 Vue 中使用自定义元素 {#using-custom-elements-in-vue}\n\nVue [在 Custom Elements Everywhere 测试中取得了 100% 的分数](https://custom-elements-everywhere.com/libraries/vue/results/results.html)。在 Vue 应用中使用自定义元素基本上与使用原生 HTML 元素的效果相同，但需要留意以下几点：\n\n### 跳过组件解析 {#skipping-component-resolution}\n\n默认情况下，Vue 会将任何非原生的 HTML 标签优先当作 Vue 组件处理，而将“渲染一个自定义元素”作为后备选项。这会在开发时导致 Vue 抛出一个“解析组件失败”的警告。要让 Vue 知晓特定元素应该被视为自定义元素并跳过组件解析，我们可以指定 [`compilerOptions.isCustomElement` 这个选项](/api/application#app-config-compileroptions)。\n\n如果在开发 Vue 应用时进行了构建配置，则应该在构建配置中传递该选项，因为它是一个编译时选项。\n\n#### 浏览器内编译时的示例配置 {#example-in-browser-config}\n\n```js\n// 仅在浏览器内编译时才会工作\n// 如果使用了构建工具，请看下面的配置示例\napp.config.compilerOptions.isCustomElement = (tag) => tag.includes('-')\n```\n\n#### Vite 示例配置 {#example-vite-config}\n\n```js [vite.config.js]\nimport vue from '@vitejs/plugin-vue'\n\nexport default {\n  plugins: [\n    vue({\n      template: {\n        compilerOptions: {\n          // 将所有带短横线的标签名都视为自定义元素\n          isCustomElement: (tag) => tag.includes('-')\n        }\n      }\n    })\n  ]\n}\n```\n\n#### Vue CLI 示例配置 {#example-vue-cli-config}\n\n```js [vue.config.js]\nmodule.exports = {\n  chainWebpack: (config) => {\n    config.module\n      .rule('vue')\n      .use('vue-loader')\n      .tap((options) => ({\n        ...options,\n        compilerOptions: {\n          // 将所有以 ion- 开头的标签都视为自定义元素\n          isCustomElement: (tag) => tag.startsWith('ion-')\n        }\n      }))\n  }\n}\n```\n\n### 传递 DOM 属性 {#passing-dom-properties}\n\n由于 DOM attribute 只能为字符串值，因此我们只能使用 DOM 对象的属性来传递复杂数据。当为自定义元素设置 props 时，Vue 3 将通过 `in` 操作符自动检查该属性是否已经存在于 DOM 对象上，并且在这个 key 存在时，更倾向于将值设置为一个 DOM 对象的属性。这意味着，在大多数情况下，如果自定义元素遵循[推荐的最佳实践](https://web.dev/custom-elements-best-practices/)，你就不需要考虑这个问题。\n\n然而，也会有一些特别的情况：必须将数据以一个 DOM 对象属性的方式传递，但该自定义元素无法正确地定义/反射这个属性 (因为 `in` 检查失败)。在这种情况下，你可以强制使用一个 `v-bind` 绑定、通过 `.prop` 修饰符来设置该 DOM 对象的属性：\n\n```vue-html\n<my-element :user.prop=\"{ name: 'jack' }\"></my-element>\n\n<!-- 等价简写 -->\n<my-element .user=\"{ name: 'jack' }\"></my-element>\n```\n\n## 使用 Vue 构建自定义元素 {#building-custom-elements-with-vue}\n\n自定义元素的主要好处是，它们可以在使用任何框架，甚至是在不使用框架的场景下使用。当你面向的最终用户可能使用了不同的前端技术栈，或是当你希望将最终的应用与它使用的组件实现细节解耦时，它们会是理想的选择。\n\n### defineCustomElement {#definecustomelement}\n\nVue 提供了一个和定义一般 Vue 组件几乎完全一致的 [`defineCustomElement`](/api/custom-elements#definecustomelement) 方法来支持创建自定义元素。这个方法接收的参数和 [`defineComponent`](/api/general#definecomponent) 完全相同。但它会返回一个继承自 `HTMLElement` 的自定义元素构造器：\n\n```vue-html\n<my-vue-element></my-vue-element>\n```\n\n```js\nimport { defineCustomElement } from 'vue'\n\nconst MyVueElement = defineCustomElement({\n  // 这里是同平常一样的 Vue 组件选项\n  props: {},\n  emits: {},\n  template: `...`,\n\n  // defineCustomElement 特有的：注入进 shadow root 的 CSS\n  styles: [`/* inlined css */`]\n})\n\n// 注册自定义元素\n// 注册之后，所有此页面中的 `<my-vue-element>` 标签\n// 都会被升级\ncustomElements.define('my-vue-element', MyVueElement)\n\n// 你也可以编程式地实例化元素：\n// (必须在注册之后)\ndocument.body.appendChild(\n  new MyVueElement({\n    // 初始化 props (可选)\n  })\n)\n```\n\n#### 生命周期 {#lifecycle}\n\n- 当该元素的 [`connectedCallback`](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks) 初次调用时，一个 Vue 自定义元素会在内部挂载一个 Vue 组件实例到它的 shadow root 上。\n\n- 当此元素的 `disconnectedCallback` 被调用时，Vue 会在一个微任务后检查元素是否还留在文档中。\n\n  - 如果元素仍然在文档中，那么说明它是一次移动操作，组件实例将被保留；\n\n  - 如果该元素不再存在于文档中，那么说明这是一次移除操作，组件实例将被销毁。\n\n#### Props {#props}\n\n- 所有使用 `props` 选项声明了的 props 都会作为属性定义在该自定义元素上。Vue 会自动地、恰当地处理其作为 attribute 还是属性的反射。\n\n  - attribute 总是根据需要反射为相应的属性类型。\n\n  - 基础类型的属性值 (`string`，`boolean` 或 `number`) 会被反射为 attribute。\n\n- 当它们被设为 attribute 时 (永远是字符串)，Vue 也会自动将以 `Boolean` 或 `Number` 类型声明的 prop 转换为所期望的类型。比如下面这样的 props 声明：\n\n  ```js\n  props: {\n    selected: Boolean,\n    index: Number\n  }\n  ```\n\n  并以下面这样的方式使用自定义元素：\n\n  ```vue-html\n  <my-element selected index=\"1\"></my-element>\n  ```\n\n  在组件中，`selected` 会被转换为 `true` (boolean 类型值) 而 `index` 会被转换为 `1` (number 类型值)。\n\n#### 事件 {#events}\n\n通过 `this.$emit` 或者 setup 中的 `emit` 触发的事件都会通过以 [CustomEvents](https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events#adding_custom_data_%E2%80%93_customevent) 的形式从自定义元素上派发。额外的事件参数 (payload) 将会被暴露为 CustomEvent 对象上的一个 `detail` 数组。\n\n#### 插槽 {#slots}\n\n在一个组件中，插槽将会照常使用 `<slot/>` 渲染。然而，当使用最终的元素时，它只接受[原生插槽的语法](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots)：\n\n- 不支持[作用域插槽](/guide/components/slots#scoped-slots)。\n\n- 当传递具名插槽时，应使用 `slot` attribute 而不是 `v-slot` 指令：\n\n  ```vue-html\n  <my-element>\n    <div slot=\"named\">hello</div>\n  </my-element>\n  ```\n\n#### 依赖注入 {#provide-inject}\n\n[Provide / Inject API](/guide/components/provide-inject#provide-inject) 和[相应的组合式 API](/api/composition-api-dependency-injection#provide) 在 Vue 定义的自定义元素中都可以正常工作。但是请注意，依赖关系**只在自定义元素之间**起作用。例如一个 Vue 定义的自定义元素就无法注入一个由常规 Vue 组件所提供的属性。\n\n#### 应用级配置 <sup class=\"vt-badge\" data-text=\"3.5+\" /> {#app-level-config}\n\n你可以使用 `configureApp` 选项来配置 Vue 自定义元素的应用实例：\n\n```js\ndefineCustomElement(MyComponent, {\n  configureApp(app) {\n    app.config.errorHandler = (err) => {\n      /* ... */\n    }\n  }\n})\n```\n\n### 将单文件组件编译为自定义元素 {#sfc-as-custom-element}\n\n`defineCustomElement` 也可以搭配 Vue 单文件组件 (SFC) 使用。但是，根据默认的工具链配置，SFC 中的 `<style>` 在生产环境构建时仍然会被抽取和合并到一个单独的 CSS 文件中。当正在使用单文件组件编写自定义元素时，通常需要改为注入 `<style>` 标签到自定义元素的 shadow root 上。\n\n官方的单文件组件工具链支持以“自定义元素模式”导入单文件组件 (需要 `@vitejs/plugin-vue@^1.4.0` 或 `vue-loader@^16.5.0`)。一个以自定义元素模式加载的单文件组件将会内联其 `<style>` 标签为 CSS 字符串，并将其暴露为组件的 `styles` 选项。这会被 `defineCustomElement` 提取使用，并在初始化时注入到元素的 shadow root 上。\n\n要开启这个模式，只需要将你的组件文件以 `.ce.vue` 结尾即可：\n\n```js\nimport { defineCustomElement } from 'vue'\nimport Example from './Example.ce.vue'\n\nconsole.log(Example.styles) // [\"/* 内联 css */\"]\n\n// 转换为自定义元素构造器\nconst ExampleElement = defineCustomElement(Example)\n\n// 注册\ncustomElements.define('my-example', ExampleElement)\n```\n\n如果你想要自定义如何判断是否将文件作为自定义元素导入 (例如将所有的单文件组件都视为用作自定义元素)，你可以通过给构建插件传递相应插件的 `customElement` 选项来实现：\n\n- [@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#using-vue-sfcs-as-custom-elements)\n- [vue-loader](https://github.com/vuejs/vue-loader/tree/next#v16-only-options)\n\n### 基于 Vue 构建自定义元素库 {#tips-for-a-vue-custom-elements-library}\n\n当使用 Vue 构建自定义元素时，该元素将依赖于 Vue 的运行时。这会有大约 16kb 的基本打包大小，并视功能的使用情况而增长。这意味着如果只编写一个自定义元素，那么使用 Vue 并不是理想的选择。你可能想要使用原生 JavaScript、[petite-vue](https://github.com/vuejs/petite-vue)，或其他框架以追求更小的运行时体积。但是，如果你需要编写的是一组具有复杂逻辑的自定义元素，那么这个基本体积是非常合理的，因为 Vue 允许用更少的代码编写每个组件。在一起发布的元素越多，收益就会越高。\n\n如果自定义元素将在同样使用 Vue 的应用中使用，那么你可以选择将构建包中的 Vue 外部化 (externalize)，这样这些自定义元素将与宿主应用使用同一份 Vue。\n\n建议按元素分别导出构造函数，以便用户可以灵活地按需导入它们，并使用期望的标签名称注册它们。你还可以导出一个函数来方便用户自动注册所有元素。下面是一个 Vue 自定义元素库的入口文件示例：\n\n```js [elements.js]\n\nimport { defineCustomElement } from 'vue'\nimport Foo from './MyFoo.ce.vue'\nimport Bar from './MyBar.ce.vue'\n\nconst MyFoo = defineCustomElement(Foo)\nconst MyBar = defineCustomElement(Bar)\n\n// 分别导出元素\nexport { MyFoo, MyBar }\n\nexport function register() {\n  customElements.define('my-foo', MyFoo)\n  customElements.define('my-bar', MyBar)\n}\n```\n\n消费者可以使用 Vue 文件中的元素：\n\n```vue\n<script setup>\nimport { register } from 'path/to/elements.js'\nregister()\n</script>\n\n<template>\n  <my-foo ...>\n    <my-bar ...></my-bar>\n  </my-foo>\n</template>\n```\n\n或在任何其他框架中，如 JSX，使用自定义名称：\n\n```jsx\nimport { MyFoo, MyBar } from 'path/to/elements.js'\n\ncustomElements.define('some-foo', MyFoo)\ncustomElements.define('some-bar', MyBar)\n\nexport function MyComponent() {\n  return <>\n    <some-foo ... >\n      <some-bar ... ></some-bar>\n    </some-foo>\n  </>\n}\n```\n\n### 基于 Vue 的 Web Components 和 TypeScript {#web-components-and-typescript}\n\n在编写 Vue SFC 模板时，你可能想要为你的 Vue 组件添加[类型检查](/guide/scaling-up/tooling.html#typescript)，包括那些被定义为自定义元素的组件。\n\n自定义元素是使用原生 API 全局注册的，所以默认情况下，当在 Vue 模板中使用时，它们不会有类型推断。为了给注册为自定义元素的 Vue 组件提供类型支持，我们可以通过扩充 [`GlobalComponents` 接口](https://github.com/vuejs/language-tools/blob/master/packages/vscode-vue/README.md#usage)来注册全局组件类型定义，以便在 Vue 模板中进行类型检查 (JSX 用户可以改为扩充 [`JSX.IntrinsicElements`](https://www.typescriptlang.org/docs/handbook/jsx.html#intrinsic-elements) 类型，此处省略这部分内容)。\n\n下面介绍如何使用 Vue 创建的自定义元素定义类型的方法：\n\n```typescript\nimport { defineCustomElement } from 'vue'\n\n// 导入 Vue 组件。\nimport SomeComponent from './src/components/SomeComponent.ce.vue'\n\n// 将 Vue 组件转为自定义元素类。\nexport const SomeElement = defineCustomElement(SomeComponent)\n\n// 记得在浏览器中注册元素类。\ncustomElements.define('some-element', SomeElement)\n\n// 将新元素类型添加到 Vue 的 GlobalComponents 类型中。\ndeclare module 'vue' {\n  interface GlobalComponents {\n    // 请务必在此处输入 Vue 组件类型\n    // (SomeComponent，*而不是* SomeElement)。\n    // 自定义元素的名称中需要连字符，\n    // 因此请在此处使用连字符元素名称。\n    'some-element': typeof SomeComponent\n  }\n}\n```\n\n## 非 Vue Web Components 和 TypeScript {#non-vue-web-components-and-typescript}\n\n以下是在非 Vue 构建的自定义元素的 SFC 模板中启用类型检查的推荐方法。\n\n:::tip 注意\n这种方法是实现该功能的一种可能方式，但具体实现可能因创建自定义元素所用的框架而异。\n:::\n\n假设我们有一个自定义元素，其中定义了一些 JS 属性和事件，并且它发布在名为 `some-lib` 的库中：\n\n```ts [some-lib/src/SomeElement.ts]\n// 定义一个带有类型化 JS 属性的类\nexport class SomeElement extends HTMLElement {\n  foo: number = 123\n  bar: string = 'blah'\n\n  lorem: boolean = false\n\n  // 这个方法不应该暴露给模板类型\n  someMethod() {\n    /* ... */\n  }\n\n  // ... 省略实现细节 ...\n  // ... 假设元素会分派名为 \"apple-fell\" 的事件 ...\n}\n\ncustomElements.define('some-element', SomeElement)\n\n// 这是一个包含 SomeElement 属性列表的类型定义\n// 这些属性将用于框架模板 (如 Vue SFC 模板 的类型检查\n// 其他属性将不会暴露\nexport type SomeElementAttributes = 'foo' | 'bar'\n\n// 定义 SomeElement 分派的事件类型\nexport type SomeElementEvents = {\n  'apple-fell': AppleFellEvent\n}\n\nexport class AppleFellEvent extends Event {\n  /* ... 省略细节 ... */\n}\n```\n\n实现细节已省略，重点是我们为两个东西提供了类型定义：prop 类型和事件类型。\n\n让我们创建一个类型工具，以便在 Vue 中轻松注册自定义元素类型定义：\n\n```ts [some-lib/src/DefineCustomElement.ts]\n// 我们可以为每个需要定义的元素重复使用这个类型助手\ntype DefineCustomElement<\n  ElementType extends HTMLElement,\n  Events extends EventMap = {},\n  SelectedAttributes extends keyof ElementType = keyof ElementType\n> = new () => ElementType & {\n\n  // 使用 $props 定义暴露给模板类型检查的属性\n  // Vue 特别从 `$props` 类型读取属性定义\n  // 请注意，我们将元素的属性与全局 HTML 属性和 Vue 的特殊属性结合在一起\n  /** @deprecated 不要在自定义元素引用上使用 $props 属性，\n    这仅用于模板属性类型检查 */\n  $props: HTMLAttributes &\n    Partial<Pick<ElementType, SelectedAttributes>> &\n    PublicProps\n\n  // 使用 $emit 专门定义事件类型\n  // Vue 特别从 `$emit` 类型读取事件类型\n  // 请注意，`$emit` 期望我们将 `Events` 映射到特定格式\n  /** @deprecated 不要在自定义元素引用上使用 $emit 属性，\n    这仅用于模板属性类型检查 */\n  $emit: VueEmit<Events>\n}\n\ntype EventMap = {\n  [event: string]: Event\n}\n\n// 这将 EventMap 映射到 Vue 的 $emit 类型期望的格式\ntype VueEmit<T extends EventMap> = EmitFn<{\n  [K in keyof T]: (event: T[K]) => void\n}>\n```\n\n:::tip 注意\n我们将 `$props` 和 `$emit` 标记为已弃用，以便当我们获取自定义元素的 `ref` 时，我们不会被诱导使用这些属性，因为这些属性在自定义元素的情况下仅用于类型检查。这些属性实际上并不存在于自定义元素实例上。\n:::\n\n使用类型助手，我们现在可以选择对在 Vue 模板中暴露的 JS 属性进行类型检查：\n\n```ts [some-lib/src/SomeElement.vue.ts]\nimport {\n  SomeElement,\n  SomeElementAttributes,\n  SomeElementEvents\n} from './SomeElement.js'\nimport type { Component } from 'vue'\nimport type { DefineCustomElement } from './DefineCustomElement'\n\n// 将新元素类型添加到 Vue 的 GlobalComponents 类型中\ndeclare module 'vue' {\n  interface GlobalComponents {\n    'some-element': DefineCustomElement<\n      SomeElement,\n      SomeElementAttributes,\n      SomeElementEvents\n    >\n  }\n}\n```\n\n假设 some-lib 将其 TypeScript 源文件构建到 dist/ 文件夹中。some-lib 的用户可以像这样导入 SomeElement 并在 Vue SFC 中使用它：\n\n```vue [SomeElementImpl.vue]\n<script setup lang=\"ts\">\n// 这将创建并在浏览器中注册元素\nimport 'some-lib/dist/SomeElement.js'\n\n// 使用 TypeScript 和 Vue 的用户应另外导入 Vue 特定的类型定义\n//(使用其他框架的用户可以导入其他框架特定的类型定义)\n\nimport type {} from 'some-lib/dist/SomeElement.vue.js'\n\nimport { useTemplateRef, onMounted } from 'vue'\n\nconst el = useTemplateRef('el')\n\nonMounted(() => {\n  console.log(\n    el.value!.foo,\n    el.value!.bar,\n    el.value!.lorem,\n    el.value!.someMethod()\n  )\n\n  // 不要使用这些属性，它们是 `undefined` \n  // IDE 会将它们显示为删除线\n  el.$props\n  el.$emit\n})\n</script>\n\n<template>\n  <!-- 现在我们可以使用这个元素，并进行类型检查： -->\n  <some-element\n    ref=\"el\"\n    :foo=\"456\"\n    :blah=\"'hello'\"\n    @apple-fell=\"\n      (event) => {\n        // 这里 `event` 的类型被推断为 `AppleFellEvent`\n      }\n    \"\n  ></some-element>\n</template>\n```\n\n如果一个元素没有类型定义，可以通过更手动的方式定义属性和事件的类型：\n\n```vue [SomeElementImpl.vue]\n<script setup lang=\"ts\">\n// 假设 `some-lib` 是纯 JavaScript，没有类型定义，并且 TypeScript 无法推断类型：\n\nimport { SomeElement } from 'some-lib'\n\n// 我们将使用之前相同的类型助手\nimport { DefineCustomElement } from './DefineCustomElement'\n\ntype SomeElementProps = { foo?: number; bar?: string }\ntype SomeElementEvents = { 'apple-fell': AppleFellEvent }\ninterface AppleFellEvent extends Event {\n  /* ... */\n}\n\n// 将新元素类型添加到 Vue 的 GlobalComponents 类型中\ndeclare module 'vue' {\n  interface GlobalComponents {\n    'some-element': DefineCustomElement<\n      SomeElementProps,\n      SomeElementEvents\n    >\n  }\n}\n\n// ... 与之前相同，使用元素引用 ...\n</script>\n\n<template>\n  <!-- ... 与之前相同，在模板中使用元素 ... -->\n</template>\n```\n\n自定义元素的作者不应该从他们的库中自动导出特定框架的自定义元素类型定义，例如他们不应该同时从 `index.ts` 文件中导出它们以及库的其余部分，否则用户将会遇到意外的模块扩展错误。用户应该导入他们需要的特定框架的类型定义文件。\n\n## Web Components vs. Vue Components {#web-components-vs-vue-components}\n\n一些开发者认为应该避免使用框架专有的组件模型，而改为全部使用自定义元素来构建应用，因为这样可以使应用“永不过时”。在这里，我们将解释为什么我们认为这样的想法过于简单。\n\n自定义元素和 Vue 组件之间确实存在一定程度的功能重叠：它们都允许我们定义具有数据传递、事件发射和生命周期管理的可重用组件。然而，Web Components 的 API 相对来说是更底层的和更基础的。要构建一个实际的应用，我们需要相当多平台没有涵盖的附加功能：\n\n- 一个声明式的、高效的模板系统；\n\n- 一个响应式的，利于跨组件逻辑提取和重用的状态管理系统；\n\n- 一种在服务器上呈现组件并在客户端“激活”(hydrate) 组件的高性能方法 (SSR)，这对 SEO 和 [LCP 这样的 Web 关键指标](https://web.dev/vitals/)非常重要。原生自定义元素 SSR 通常需要在 Node.js 中模拟 DOM，然后序列化更改后的 DOM，而 Vue SSR 则尽可能地将其编译为拼接起来的字符串，这会高效得多。\n\nVue 的组件模型在设计时同时兼顾了这些需求，因此是一个更内聚的系统。\n\n当你的团队有足够的技术水平时，可能可以在原生自定义元素的基础上构建具备同等功能的组件。但这也意味着你将承担长期维护内部框架的负担，同时失去了像 Vue 这样成熟的框架生态社区所带来的收益。\n\n也有一些框架使用自定义元素作为其组件模型的基础，但它们都不可避免地要引入自己的专有解决方案来解决上面列出的问题。使用这些框架便意味着对它们针对这些问题的技术决策买单。不管这类框架怎么宣传它们“永不过时”，它们其实都无法保证你以后永远不需要重构。\n\n除此之外，我们还发现自定义元素存在以下限制：\n\n- 贪婪 (eager) 的插槽求值会阻碍组件之间的可组合性。Vue 的[作用域插槽](/guide/components/slots#scoped-slots)是一套强大的组件组合机制，而由于原生插槽的贪婪求值性质，自定义元素无法支持这样的设计。贪婪求值的插槽也意味着接收组件时不能控制何时或是否创建插槽内容的节点。\n\n- 在当下要想使用 shadow DOM 书写局部作用域的 CSS，必须将样式嵌入到 JavaScript 中才可以在运行时将其注入到 shadow root 上。这也导致了 SSR 场景下需要渲染大量重复的样式标签。虽然有一些[平台功能](https://github.com/whatwg/html/pull/4898/)在尝试解决这一领域的问题，但是直到现在还没有达到通用支持的状态，而且仍有生产性能 / SSR 方面的问题需要解决。可与此同时，Vue 的单文件组件本身就提供了 [CSS 局域化机制](/api/sfc-css-features)，并支持抽取样式到纯 CSS 文件中。\n\nVue 将始终紧跟 Web 平台的最新标准，如果平台的新功能能让我们的工作变得更简单，我们将非常乐于利用它们。但是，我们的目标是提供“好用，且现在就能用”的解决方案。这意味着我们在采用新的原生功能时需要保持客观、批判性的态度，并在原生功能完成度不足的时候选择更适当的解决方案。\n\n\n\n================================================\nFILE: src/guide/extras/demos/AnimateWatcher.vue\n================================================\n<script setup>\nimport { ref, reactive, watch } from 'vue'\nimport gsap from 'gsap'\n\nconst number = ref(0)\nconst tweened = reactive({\n  number: 0\n})\n\nwatch(\n  number,\n  (n) => {\n    gsap.to(tweened, { duration: 0.5, number: Number(n) || 0 })\n  }\n)\n</script>\n\n<template>\n  <div class=\"demo\">\n    Type a number: <input v-model.number=\"number\" />\n    <p class=\"big-number\">{{ tweened.number.toFixed(0) }}</p>\n  </div>\n</template>\n\n<style>\n.big-number {\n  font-weight: bold;\n  font-size: 2em;\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/extras/demos/Colors.vue\n================================================\n<script setup>\nimport { ref } from 'vue'\n\nconst x = ref(0)\n\nfunction onMousemove(e) {\n  x.value = e.clientX\n}\n</script>\n\n<template>\n  <div\n    @mousemove=\"onMousemove\"\n    :style=\"{ backgroundColor: `hsl(${x}, 80%, 50%)` }\"\n    class=\"demo movearea\"\n  >\n    <p>Move your mouse across this div...</p>\n    <p>x: {{ x }}</p>\n  </div>\n</template>\n\n<style>\n.movearea {\n  color: #fff;\n  transition: 0.3s background-color ease;\n  border: none;\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/extras/demos/DisabledButton.vue\n================================================\n<script setup>\nimport { ref } from 'vue'\n\nconst notActivated = ref(false)\n\nfunction warnNotActivated() {\n  notActivated.value = true\n  setTimeout(() => {\n    notActivated.value = false\n  }, 1500)\n}\n</script>\n\n<template>\n  <div class=\"demo\">\n    <div :class=\"{ shake: notActivated }\">\n      <button @click=\"warnNotActivated\">Click me</button>\n      <span v-if=\"notActivated\" style=\"margin-left: 20px\"\n        >This feature is disabled!</span\n      >\n    </div>\n  </div>\n</template>\n\n<style>\n.shake {\n  animation: shake 0.82s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;\n  transform: translate3d(0, 0, 0);\n}\n\n@keyframes shake {\n  10%,\n  90% {\n    transform: translate3d(-1px, 0, 0);\n  }\n\n  20%,\n  80% {\n    transform: translate3d(2px, 0, 0);\n  }\n\n  30%,\n  50%,\n  70% {\n    transform: translate3d(-4px, 0, 0);\n  }\n\n  40%,\n  60% {\n    transform: translate3d(4px, 0, 0);\n  }\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/extras/demos/ElasticHeader.vue\n================================================\n<script setup>\nimport { reactive, computed } from 'vue'\nimport dynamics from 'dynamics.js'\n\nconst headerHeight = 120\n\nlet isDragging = false\nconst start = { x: 0, y: 0 }\nconst c = reactive({ x: headerHeight, y: headerHeight })\n\nconst headerPath = computed(() => {\n  return `M0,0 L320,0 320,${headerHeight}Q${c.x},${c.y} 0,${headerHeight}`\n})\n\nconst contentPosition = computed(() => {\n  const dy = c.y - headerHeight\n  const dampen = dy > 0 ? 2 : 4\n  return {\n    transform: `translate(0,${dy / dampen}px)`\n  }\n})\n\nfunction startDrag(e) {\n  e = e.changedTouches ? e.changedTouches[0] : e\n  isDragging = true\n  start.x = e.pageX\n  start.y = e.pageY\n}\n\nfunction onDrag(e) {\n  e = e.changedTouches ? e.changedTouches[0] : e\n  if (isDragging) {\n    c.x = headerHeight + (e.pageX - start.x)\n    const dy = e.pageY - start.y\n    const dampen = dy > 0 ? 1.5 : 4\n    c.y = headerHeight + dy / dampen\n  }\n}\n\nfunction stopDrag() {\n  if (isDragging) {\n    isDragging = false\n    dynamics.animate(\n      c,\n      { x: headerHeight, y: headerHeight },\n      { type: dynamics.spring, duration: 700, friction: 280 }\n    )\n  }\n}\n</script>\n\n<template>\n  <div\n    class=\"draggable\"\n    @mousedown=\"startDrag\"\n    @mousemove=\"onDrag\"\n    @mouseup=\"stopDrag\"\n    @mouseleave=\"stopDrag\"\n    @touchstart.prevent=\"startDrag\"\n    @touchmove.prevent=\"onDrag\"\n    @touchend.prevent=\"stopDrag\"\n  >\n    <svg class=\"bg\" width=\"320\" height=\"560\">\n      <path :d=\"headerPath\" fill=\"#3F51B5\"></path>\n    </svg>\n    <div class=\"header\">Drag Me</div>\n    <div class=\"content\" :style=\"contentPosition\">\n      <a\n        href=\"https://play.vuejs.org/#eNqlVmtv2zYU/SsXboE6mC3bSdwVmpM9MAz9sAIdsA8b5gGhRUrWKpEESTl2DP/3HZKSbbkuUKBA4Ij3ce65D15pP/hZ62TTiEE6WNjMlNqRFa7Rj0tZ1loZR3sygmWu3IgRZarWjROcDpQbVdMbeL45WvKdZHWZ2VbXHZP/LGyWMlPSOloLxoV5L8pi7eiBZrdTr6uEo9L+alhRlLKAPGeVFZ2PdQzwD6CyTWk6oh1+6dBpM2g6isNgch4jWPeCHm4u2Xxkbg2QLrvh8IYeHmm/lARg1xhJTx+moyn9fnfr//nf1/tzzMMfr/dZsj1AnCW7Azhe6J+W8jwsfp2Q7qOypSuV/ELsaMt3Xp3saNxL48yA1Vp4DFg+ojA/0i2ldH/GPqAROcOkzZWpU3oKzxVzYui5wnPS4hz09gZsydc3Us4bidqCZWiD79FQ3ERMgagiydZMFoL/qZpsLSziX4r+mf4LRmgn9ZvsTBOEATjZBjDNCvHXSeiTj8K/wadHR8lv5ZLT8MSnhUFVA5PeyHxHw5YZutCyRW2C9alJLc+jya5n8VmXZsm865MP6hEugp61pevIRUOUDjVouX8hoWsXy8uPF5ThBvtRiGKQGXVPX3OdzozdTov0hGu1QdAR8cYwTzil76e4vrkpA/+Ubt+Fe+ydQzljhotJ3ETYQTg4UWs/qDgRLXi5aQtWMWsflgPuU2OrSiwHUfFTrRoruHqW0B5H9qh1fgyC+Ko6ONdqI6CNA9b3vK4KXo0OiLElfS8h+TVdcKsEC5B9bcgW+dpNcUx1BR09l9ytccASwmkdeoDj/C2OrRPctN9oqQ962nAwz8uqguzV3W/z2S9zOCwm3rILNkG07hmFPgaOGDD3/OiDWEygvWbY7jVESq3bVT6ti1UHkPeiqtQJontaTM46jWMAIJspLTgkybHRcaxXLPtUGNVIPs5UpUxKr/I8/yGo1HZs1wwj4N8T93pLs7f4McWKYdv5F4j/S2bzm2AeKpr6ra63QRCLium87yRouskrj7cuORcyCGtmcKfgCCtijVNBqttEUyxfJIN3UhA7sXVjVpUFFBnqIUwQ56jO2JYvuDUzED3JnlsOd9NpEGJQzNgPSwahVDKirpRBY8aG8bKxKb0LCLhByaqIVTqxYSurKrxhIhulUZrwWIkciPH5ZVxKLvw7toWJjccFT9o2XqL2cjy6z2IlGOe4/rFAp8aUL0HYUoeoF6t78/U72nUEXwvnRYqFuxX153VbqYpHYEy1nySM0GA0iF8q45ppfJUoia+eEG/ZKuxykHZbE6vl9AHj5bgHzmmbTiYZl4n9tNMYwYSLzaRn2O2xweF/7cIdbA==\"\n        target=\"_blank\"\n        >Source code</a\n      >\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.draggable {\n  background-color: #fff;\n  box-shadow: var(--vt-shadow-2);\n  width: 320px;\n  height: 240px;\n  overflow: hidden;\n  margin: 30px auto;\n  position: relative;\n  text-align: center;\n  font-size: 14px;\n  font-weight: 300;\n  user-select: none;\n  border-radius: 8px;\n}\n.bg {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 0;\n}\n.header,\n.content {\n  position: relative;\n  z-index: 1;\n  padding: 30px;\n  box-sizing: border-box;\n}\n.header {\n  color: #fff;\n  height: 120px;\n  font-size: 2em;\n  font-weight: bold;\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/extras/demos/SpreadSheet.vue\n================================================\n<script setup>\nimport Cell from './SpreadSheetCell.vue'\nimport { cells } from './spreadSheetStore.js'\n\nconst cols = cells.map((_, i) => String.fromCharCode(65 + i))\n</script>\n\n<template>\n  <table>\n    <thead>\n      <tr>\n        <th></th>\n        <th v-for=\"c in cols\">{{ c }}</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr v-for=\"i in cells[0].length\">\n        <th>{{ i - 1 }}</th>\n        <td v-for=\"(c, j) in cols\">\n          <Cell :r=\"i - 1\" :c=\"j\"></Cell>\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</template>\n\n<style scoped>\nth {\n  color: var(--vt-c-text-1);\n  background-color: var(--vt-c-bg-mute);\n  padding: 0 1em;\n}\n\ntr:first-of-type th {\n  width: 100px;\n}\n\ntr:first-of-type th:first-of-type {\n  width: 25px;\n}\n\ntd {\n  border: 1px solid var(--vt-c-bg-mute);\n  padding: 0;\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/extras/demos/SpreadSheetCell.vue\n================================================\n<script setup>\nimport { ref } from 'vue'\nimport { cells, evalCell } from './spreadSheetStore.js'\n\nconst props = defineProps({\n  c: Number,\n  r: Number\n})\n\nconst editing = ref(false)\n\nfunction update(e) {\n  editing.value = false\n  cells[props.c][props.r] = e.target.value.trim()\n}\n</script>\n\n<template>\n  <div class=\"cell\" :title=\"cells[c][r]\" @click=\"editing = true\">\n    <input\n      v-if=\"editing\"\n      :value=\"cells[c][r]\"\n      @change=\"update\"\n      @blur=\"update\"\n      @vue:mounted=\"({ el }) => el.focus()\"\n    />\n    <span v-else>{{ evalCell(cells[c][r]) }}</span>\n  </div>\n</template>\n\n<style scoped>\n.cell, .cell input {\n  height: 1.5em;\n  line-height: 1.5;\n  font-size: 15px;\n  color: var(--vt-c-text-1);\n}\n\n.cell span {\n  padding: 0 6px;\n}\n\n.cell input {\n  width: 100%;\n  box-sizing: border-box;\n  padding: 0 4px;\n}\n\n.cell input:focus {\n  border: 2px solid var(--vt-c-divider);\n  color: var(--vt-c-text-1);\n}\n</style>\n\n\n\n================================================\nFILE: src/guide/extras/demos/spreadSheetStore.js\n================================================\nimport { reactive } from 'vue'\n\nconst COLS = 3\nconst ROWS = 3\n\nexport const cells = reactive(\n  Array.from(Array(COLS).keys()).map((i) =>\n    Array.from(Array(ROWS).keys()).map((i) => '')\n  )\n)\n\n// initial state for demo\ncells[0][0] = '1'\ncells[0][1] = '2'\ncells[0][2] = '= A0 + A1'\n\n// adapted from https://codesandbox.io/s/jotai-7guis-task7-cells-mzoit?file=/src/atoms.ts\n// by @dai-shi\nexport function evalCell(exp) {\n  if (!exp.startsWith('=')) {\n    return exp\n  }\n\n  // = A1 + B2 ---> get(0,1) + get(1,2)\n  exp = exp\n    .slice(1)\n    .replace(\n      /\\b([A-Z])(\\d{1,2})\\b/g,\n      (_, c, r) => `get(${c.charCodeAt(0) - 65},${r})`\n    )\n\n  try {\n    return new Function('get', `return ${exp}`)(getCellValue)\n  } catch (e) {\n    return `#ERROR ${e}`\n  }\n}\n\nfunction getCellValue(c, r) {\n  const val = evalCell(cells[c][r])\n  const num = Number(val)\n  return Number.isFinite(num) ? num : val\n}\n\n\n\n================================================\nFILE: src/guide/reusability/composables.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/reusability/custom-directives.md\n================================================\n# 自定义指令 {#custom-directives}\n\n<script setup>\nconst vHighlight = {\n  mounted: el => {\n    el.classList.add('is-highlight')\n  }\n}\n</script>\n\n<style>\n.vt-doc p.is-highlight {\n  margin-bottom: 0;\n}\n\n.is-highlight {\n  background-color: yellow;\n  color: black;\n}\n</style>\n\n## 介绍 {#introduction}\n\n除了 Vue 内置的一系列指令 (比如 `v-model` 或 `v-show`) 之外，Vue 还允许你注册自定义的指令 (Custom Directives)。\n\n我们已经介绍了两种在 Vue 中重用代码的方式：[组件](/guide/essentials/component-basics)和[组合式函数](./composables)。组件是主要的构建模块，而组合式函数则侧重于有状态的逻辑。另一方面，自定义指令主要是为了重用涉及普通元素的底层 DOM 访问的逻辑。\n\n一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。钩子函数会接收到指令所绑定元素作为其参数。下面是一个自定义指令的例子，当 Vue 将元素插入到 DOM 中后，该指令会将一个 class 添加到元素中：\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\n// 在模板中启用 v-highlight\nconst vHighlight = {\n  mounted: (el) => {\n    el.classList.add('is-highlight')\n  }\n}\n</script>\n\n<template>\n  <p v-highlight>This sentence is important!</p>\n</template>\n```\n\n</div>\n\n<div class=\"options-api\">\n\n```js\nconst highlight = {\n  mounted: (el) => el.classList.add('is-highlight')\n}\n\nexport default {\n  directives: {\n    // 在模板中启用 v-highlight\n    highlight\n  }\n}\n```\n\n```vue-html\n<p v-highlight>This sentence is important!</p>\n```\n\n</div>\n\n<div class=\"demo\">\n  <p v-highlight>This sentence is important!</p>\n</div>\n\n<div class=\"composition-api\">\n\n在 `<script setup>` 中，任何以 `v` 开头的驼峰式命名的变量都可以当作自定义指令使用。在上述例子中，`vHighlight` 可以在模板中以 `v-highlight` 的形式使用。\n\n在不使用 `<script setup>` 的情况下，自定义指令需要通过 `directives` 选项注册：\n\n```js\nexport default {\n  setup() {\n    /*...*/\n  },\n  directives: {\n    // 在模板中启用 v-highlight\n    highlight: {\n      /* ... */\n    }\n  }\n}\n```\n\n</div>\n\n<div class=\"options-api\">\n\n和组件类似，自定义指令在模板中使用前必须先注册。在上面的例子中，我们使用 `directives` 选项完成了指令的局部注册。\n\n</div>\n\n将一个自定义指令全局注册到应用层级也是一种常见的做法：\n\n```js\nconst app = createApp({})\n\n// 使 v-highlight 在所有组件中都可用\napp.directive('highlight', {\n  /* ... */\n})\n```\n\n通过扩展 `vue` 中的 `ComponentCustomProperties` 接口，可以为自定义的全局指令添加类型。\n\n更多细节参考：[为自定义全局指令添加类型](/guide/typescript/composition-api#typing-global-custom-directives) <sup class=\"vt-badge ts\" />\n\n## 自定义指令的使用时机 {#when-to-use}\n\n只有当所需功能只能通过直接的 DOM 操作来实现时，才应该使用自定义指令。\n\n一个常见例子是使元素获取焦点的 `v-focus` 指令。\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\n// 在模板中启用 v-focus\nconst vFocus = {\n  mounted: (el) => el.focus()\n}\n</script>\n\n<template>\n  <input v-focus />\n</template>\n```\n\n</div>\n\n<div class=\"options-api\">\n\n```js\nconst focus = {\n  mounted: (el) => el.focus()\n}\n\nexport default {\n  directives: {\n    // 在模板中启用 v-focus\n    focus\n  }\n}\n```\n\n```vue-html\n<input v-focus />\n```\n\n</div>\n\n该指令比 `autofocus` 属性更有用，因为它不仅在页面加载时有效，而且在 Vue 动态插入元素时也有效！\n\n建议尽可能使用 `v-bind` 等内置指令声明模板，因为它们更高效，对服务端渲染也更友好。\n\n## 指令钩子 {#directive-hooks}\n\n一个指令的定义对象可以提供几种钩子函数 (都是可选的)：\n\n```js\nconst myDirective = {\n  // 在绑定元素的 attribute 前\n  // 或事件监听器应用前调用\n  created(el, binding, vnode) {\n    // 下面会介绍各个参数的细节\n  },\n  // 在元素被插入到 DOM 前调用\n  beforeMount(el, binding, vnode) {},\n  // 在绑定元素的父组件\n  // 及他自己的所有子节点都挂载完成后调用\n  mounted(el, binding, vnode) {},\n  // 绑定元素的父组件更新前调用\n  beforeUpdate(el, binding, vnode, prevVnode) {},\n  // 在绑定元素的父组件\n  // 及他自己的所有子节点都更新后调用\n  updated(el, binding, vnode, prevVnode) {},\n  // 绑定元素的父组件卸载前调用\n  beforeUnmount(el, binding, vnode) {},\n  // 绑定元素的父组件卸载后调用\n  unmounted(el, binding, vnode) {}\n}\n```\n\n### 钩子参数 {#hook-arguments}\n\n指令的钩子会传递以下几种参数：\n\n- `el`：指令绑定到的元素。这可以用于直接操作 DOM。\n\n- `binding`：一个对象，包含以下属性。\n\n  - `value`：传递给指令的值。例如在 `v-my-directive=\"1 + 1\"` 中，值是 `2`。\n  - `oldValue`：之前的值，仅在 `beforeUpdate` 和 `updated` 中可用。无论值是否更改，它都可用。\n  - `arg`：传递给指令的参数 (如果有的话)。例如在 `v-my-directive:foo` 中，参数是 `\"foo\"`。\n  - `modifiers`：一个包含修饰符的对象 (如果有的话)。例如在 `v-my-directive.foo.bar` 中，修饰符对象是 `{ foo: true, bar: true }`。\n  - `instance`：使用该指令的组件实例。\n  - `dir`：指令的定义对象。\n\n- `vnode`：代表绑定元素的底层 VNode。\n- `prevVnode`：代表之前的渲染中指令所绑定元素的 VNode。仅在 `beforeUpdate` 和 `updated` 钩子中可用。\n\n举例来说，像下面这样使用指令：\n\n```vue-html\n<div v-example:foo.bar=\"baz\">\n```\n\n`binding` 参数会是一个这样的对象：\n\n```js\n{\n  arg: 'foo',\n  modifiers: { bar: true },\n  value: /* `baz` 的值 */,\n  oldValue: /* 上一次更新时 `baz` 的值 */\n}\n```\n\n和内置指令类似，自定义指令的参数也可以是动态的。举例来说：\n\n```vue-html\n<div v-example:[arg]=\"value\"></div>\n```\n\n这里指令的参数会基于组件的 `arg` 数据属性响应式地更新。\n\n:::tip Note\n除了 `el` 外，其他参数都是只读的，不要更改它们。若你需要在不同的钩子间共享信息，推荐通过元素的 [dataset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset) attribute 实现。\n:::\n\n## 简化形式 {#function-shorthand}\n\n对于自定义指令来说，一个很常见的情况是仅仅需要在 `mounted` 和 `updated` 上实现相同的行为，除此之外并不需要其他钩子。这种情况下我们可以直接用一个函数来定义指令，如下所示：\n\n```vue-html\n<div v-color=\"color\"></div>\n```\n\n```js\napp.directive('color', (el, binding) => {\n  // 这会在 `mounted` 和 `updated` 时都调用\n  el.style.color = binding.value\n})\n```\n\n## 对象字面量 {#object-literals}\n\n如果你的指令需要多个值，你可以向它传递一个 JavaScript 对象字面量。别忘了，指令也可以接收任何合法的 JavaScript 表达式。\n\n```vue-html\n<div v-demo=\"{ color: 'white', text: 'hello!' }\"></div>\n```\n\n```js\napp.directive('demo', (el, binding) => {\n  console.log(binding.value.color) // => \"white\"\n  console.log(binding.value.text) // => \"hello!\"\n})\n```\n\n## 在组件上使用 {#usage-on-components}\n\n:::warning 不推荐\n不推荐在组件上使用自定义指令。当组件具有多个根节点时可能会出现预期外的行为。\n:::\n\n当在组件上使用自定义指令时，它会始终应用于组件的根节点，和[透传 attributes](/guide/components/attrs) 类似。\n\n```vue-html\n<MyComponent v-demo=\"test\" />\n```\n\n```vue-html\n<!-- MyComponent 的模板 -->\n\n<div> <!-- v-demo 指令会被应用在此处 -->\n  <span>My component content</span>\n</div>\n```\n\n需要注意的是组件可能含有多个根节点。当应用到一个多根组件时，指令将会被忽略且抛出一个警告。和 attribute 不同，指令不能通过 `v-bind=\"$attrs\"` 来传递给一个不同的元素。\n\n\n\n================================================\nFILE: src/guide/reusability/mouse.js\n================================================\nimport { ref, onMounted, onUnmounted } from 'vue'\n\nexport function useMouse() {\n  const x = ref(0)\n  const y = ref(0)\n\n  function update(event) {\n    x.value = event.pageX\n    y.value = event.pageY\n  }\n\n  onMounted(() => window.addEventListener('mousemove', update))\n  onUnmounted(() => window.removeEventListener('mousemove', update))\n\n  return { x, y }\n}\n\n\n\n================================================\nFILE: src/guide/reusability/plugins.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/scaling-up/routing.md\n================================================\n# 路由 {#routing}\n\n## 客户端 vs. 服务端路由 {#client-side-vs-server-side-routing}\n\n服务端路由指的是服务器根据用户访问的 URL 路径返回不同的响应结果。当我们在一个传统的服务端渲染的 web 应用中点击一个链接时，浏览器会从服务端获得全新的 HTML，然后重新加载整个页面。\n\n然而，在[单页面应用](https://developer.mozilla.org/en-US/docs/Glossary/SPA)中，客户端的 JavaScript 可以拦截页面的跳转请求，动态获取新的数据，然后在无需重新加载的情况下更新当前页面。这样通常可以带来更顺滑的用户体验，尤其是在更偏向“应用”的场景下，因为这类场景下用户通常会在很长的一段时间中做出多次交互。\n\n在这类单页应用中，“路由”是在客户端执行的。一个客户端路由器的职责就是利用诸如 [History API](https://developer.mozilla.org/en-US/docs/Web/API/History) 或是 [`hashchange` 事件](https://developer.mozilla.org/en-US/docs/Web/API/Window/hashchange_event)这样的浏览器 API 来管理应用当前应该渲染的视图。\n\n## 官方路由 {#official-router}\n\n<!-- TODO update links -->\n<div>\n  <VueSchoolLink href=\"https://vueschool.io/courses/vue-router-4-for-everyone\" title=\"免费的 Vue Router 课程\">\n    在 Vue School 上观看免费的视频课程\n  </VueSchoolLink>\n</div>\n\nVue 很适合用来构建单页面应用。对于大多数此类应用，都推荐使用官方支持的[路由库](https://github.com/vuejs/router)。要了解更多细节，请查看 [Vue Router 的文档](https://router.vuejs.org/zh/)。\n\n## 从头开始实现一个简单的路由 {#simple-routing-from-scratch}\n\n如果你只需要一个简单的页面路由，而不想为此引入一整个路由库，你可以通过[动态组件](/guide/essentials/component-basics#dynamic-components)的方式，监听浏览器 [`hashchange` 事件](https://developer.mozilla.org/en-US/docs/Web/API/Window/hashchange_event)或使用 [History API](https://developer.mozilla.org/en-US/docs/Web/API/History) 来更新当前组件。\n\n下面是一个简单的例子：\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nimport { ref, computed } from 'vue'\nimport Home from './Home.vue'\nimport About from './About.vue'\nimport NotFound from './NotFound.vue'\nconst routes = {\n  '/': Home,\n  '/about': About\n}\nconst currentPath = ref(window.location.hash)\nwindow.addEventListener('hashchange', () => {\n  currentPath.value = window.location.hash\n})\nconst currentView = computed(() => {\n  return routes[currentPath.value.slice(1) || '/'] || NotFound\n})\n</script>\n<template>\n  <a href=\"#/\">Home</a> |\n  <a href=\"#/about\">About</a> |\n  <a href=\"#/non-existent-path\">Broken Link</a>\n  <component :is=\"currentView\" />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNptUk1vgkAQ/SsTegAThZp4MmhikzY9mKanXkoPWxjLRpgly6JN1P/eWb5Eywlm572ZN2/m5GyKwj9U6CydsIy1LAyUaKpiHZHMC6UNnEDjbgqxyovKYAIX2GmVg8sktwe9qhzbdz+wga15TW++VWX6fB3dAt6UeVEVJT2me2hhEcWKSgOamVjCCk4RAbiBu6xbT5tI2ML8VDeI6HLlxZXWSOZdmJTJPJB3lJSoo5+pWBipyE9FmU4soU2IJHk+MGUrS4OE2nMtIk4F/aA7BW8Cq3WjYlDbP4isQu4wVp0F1Q1uFH1IPDK+c9cb1NW8B03tyJ//uvhlJmP05hM4n60TX/bb2db0CoNmpbxMDgzmRSYMcgQQCkjZhlXkPASRs7YmhoFYw/k+WXvKiNrTcQgpmuFv7ZOZFSyQ4U9a7ZFgK2lvSTXFDqmIQbCUJTMHFkQOBAwKg16kM3W6O7K3eSs+nbeK+eee1V/XKK0dY4Q3vLhR6uJxMUK8/AFKaB6k)\n\n</div>\n\n<div class=\"options-api\">\n\n```vue\n<script>\nimport Home from './Home.vue'\nimport About from './About.vue'\nimport NotFound from './NotFound.vue'\nconst routes = {\n  '/': Home,\n  '/about': About\n}\nexport default {\n  data() {\n    return {\n      currentPath: window.location.hash\n    }\n  },\n  computed: {\n    currentView() {\n      return routes[this.currentPath.slice(1) || '/'] || NotFound\n    }\n  },\n  mounted() {\n    window.addEventListener('hashchange', () => {\n\t\t  this.currentPath = window.location.hash\n\t\t})\n  }\n}\n</script>\n<template>\n  <a href=\"#/\">Home</a> |\n  <a href=\"#/about\">About</a> |\n  <a href=\"#/non-existent-path\">Broken Link</a>\n  <component :is=\"currentView\" />\n</template>\n```\n\n[在演练场中尝试一下](https://play.vuejs.org/#eNptUstO6zAQ/ZVR7iKtVJKLxCpKK3Gli1ggxIoNZmGSKbFoxpEzoUi0/87YeVBKNonHPmfOmcdndN00yXuHURblbeFMwxtFpm6sY7i1NcLW2RriJPWBB8bT8/WL7Xh6D9FPwL3lG9tROWHGiwGmqLDUMjhhYgtr+FQEEKdxFqRXfaR9YrkKAoqOnocfQaDEre523PNKzXqx7M8ADrlzNEYAReccEj9orjLYGyrtPtnZQrOxlFS6rXqgZJdPUC5s3YivMhuTDCkeDe6/dSalvognrkybnIgl7c4UuLhcwuHgS3v2/7EPvzRruRXJ7/SDU12W/98l451pGQndIvaWi0rTK8YrEPx64ymKFQOce5DOzlfs4cdlkA+NzdNpBSRgrJudZpQIINdQOdyuVfQnVdHGzydP9QYO549hXIII45qHkKUL/Ail8EUjBgX+z9k3JLgz9OZJgeInYElAkJlWmCcDUBGkAsrTyWS0isYV9bv803x1OTiWwzlrWtxZ2lDGDO90mWepV3+vZojHL3QQKQE=)\n\n</div>\n\n\n\n================================================\nFILE: src/guide/scaling-up/sfc.md\n================================================\n# 单文件组件 {#single-file-components}\n\n## 介绍 {#introduction}\n\nVue 的单文件组件 (即 `*.vue` 文件，英文 Single-File Component，简称 **SFC**) 是一种特殊的文件格式，使我们能够将一个 Vue 组件的模板、逻辑与样式封装在单个文件中。下面是一个单文件组件的示例：\n\n<div class=\"options-api\">\n\n```vue\n<script>\nexport default {\n  data() {\n    return {\n      greeting: 'Hello World!'\n    }\n  }\n}\n</script>\n\n<template>\n  <p class=\"greeting\">{{ greeting }}</p>\n</template>\n\n<style>\n.greeting {\n  color: red;\n  font-weight: bold;\n}\n</style>\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n```vue\n<script setup>\nimport { ref } from 'vue'\nconst greeting = ref('Hello World!')\n</script>\n\n<template>\n  <p class=\"greeting\">{{ greeting }}</p>\n</template>\n\n<style>\n.greeting {\n  color: red;\n  font-weight: bold;\n}\n</style>\n```\n\n</div>\n\n如你所见，Vue 的单文件组件是网页开发中 HTML、CSS 和 JavaScript 三种语言经典组合的自然延伸。`<template>`、`<script>` 和 `<style>` 三个块在同一个文件中封装、组合了组件的视图、逻辑和样式。完整的语法定义可以查阅[单文件组件语法说明](/api/sfc-spec)。\n\n## 为什么要使用单文件组件 {#why-sfc}\n\n使用单文件组件必须使用构建工具，但作为回报带来了以下优点：\n\n- 使用熟悉的 HTML、CSS 和 JavaScript 语法编写模块化的组件\n- [让本来就强相关的关注点自然内聚](#what-about-separation-of-concerns)\n- 预编译模板，避免运行时的编译开销\n- [组件作用域的 CSS](/api/sfc-css-features)\n- [在使用组合式 API 时语法更简单](/api/sfc-script-setup)\n- 通过交叉分析模板和逻辑代码能进行更多编译时优化\n- [更好的 IDE 支持](/guide/scaling-up/tooling#ide-support)，提供自动补全和对模板中表达式的类型检查\n- 开箱即用的模块热更新 (HMR) 支持\n\n单文件组件是 Vue 框架提供的一个功能，并且在下列场景中都是官方推荐的项目组织方式：\n\n- 单页面应用 (SPA)\n- 静态站点生成 (SSG)\n- 任何值得引入构建步骤以获得更好的开发体验 (DX) 的项目\n\n当然，在一些轻量级场景下使用单文件组件会显得有些杀鸡用牛刀。因此 Vue 同样也可以在无构建步骤的情况下以纯 JavaScript 方式使用。如果你的用例只需要给静态 HTML 添加一些简单的交互，你可以看看 [petite-vue](https://github.com/vuejs/petite-vue)，它是一个 6 kB 左右、预优化过的 Vue 子集，更适合渐进式增强的需求。\n\n## 单文件组件是如何工作的 {#how-it-works}\n\nVue 单文件组件是一个框架指定的文件格式，因此必须交由 [@vue/compiler-sfc](https://github.com/vuejs/core/tree/main/packages/compiler-sfc) 编译为标准的 JavaScript 和 CSS，一个编译后的单文件组件是一个标准的 JavaScript(ES) 模块，这也意味着在构建配置正确的前提下，你可以像导入其他 ES 模块一样导入单文件组件：\n\n```js\nimport MyComponent from './MyComponent.vue'\n\nexport default {\n  components: {\n    MyComponent\n  }\n}\n```\n\n单文件组件中的 `<style>` 标签一般会在开发时注入成原生的 `<style>` 标签以支持热更新，而生产环境下它们会被抽取、合并成单独的 CSS 文件。\n\n你可以在 [Vue 单文件组件演练场](https://play.vuejs.org/)中实际使用一下单文件组件，同时可以看到它们最终被编译后的样子。\n\n在实际项目中，我们一般会使用集成了单文件组件编译器的构建工具，比如 [Vite](https://cn.vitejs.dev/) 或者 [Vue CLI](https://cli.vuejs.org/zh/) (基于 [webpack](https://webpack.js.org/))，Vue 官方也提供了脚手架工具来帮助你尽可能快速地上手开发单文件组件。更多细节请查看[单文件组件工具链](/guide/scaling-up/tooling)章节。\n\n## 如何看待关注点分离？ {#what-about-separation-of-concerns}\n\n一些有着传统 Web 开发背景的用户可能会因为单文件组件将不同的关注点集合在一处而有所顾虑，觉得 HTML/CSS/JS 应当是分离开的！\n\n要回答这个问题，我们必须对这一点达成共识：**前端开发的关注点不是完全基于文件类型分离的**。前端工程化的最终目的都是为了能够更好地维护代码。关注点分离不应该是教条式地将其视为文件类型的区别和分离，仅仅这样并不够帮我们在日益复杂的前端应用的背景下提高开发效率。\n\n在现代的 UI 开发中，我们发现与其将代码库划分为三个巨大的层，相互交织在一起，不如将它们划分为松散耦合的组件，再按需组合起来。在一个组件中，其模板、逻辑和样式本就是有内在联系的、是耦合的，将它们放在一起，实际上使组件更有内聚性和可维护性。\n\n即使你不喜欢单文件组件这样的形式而仍然选择拆分单独的 JavaScript 和 CSS 文件，也没关系，你还是可以通过[资源导入](/api/sfc-spec#src-imports)功能获得热更新和预编译等功能的支持。\n\n\n\n================================================\nFILE: src/guide/scaling-up/ssr.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/scaling-up/state-management.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/scaling-up/testing.md\n================================================\n<script setup>\nimport { VTCodeGroup, VTCodeGroupTab } from '@vue/theme'\n</script>\n<style>\n.lambdatest {\n  background-color: var(--vt-c-bg-soft);\n  border-radius: 8px;\n  padding: 12px 16px 12px 12px;\n  font-size: 13px;\n  a {\n    display: flex;\n    color: var(--vt-c-text-2);\n  }\n  img {\n    background-color: #fff;\n    padding: 12px 16px;\n    border-radius: 6px;\n    margin-right: 24px;\n  }\n  .testing-partner {\n    color: var(--vt-c-text-1);\n    font-size: 15px;\n    font-weight: 600;\n  }\n}\n</style>\n\n# 测试 {#testing}\n\n## 为什么需要测试 {#why-test}\n\n自动化测试能够预防无意引入的 bug，并鼓励开发者将应用分解为可测试、可维护的函数、模块、类和组件。这能够帮助你和你的团队更快速、自信地构建复杂的 Vue 应用。与任何应用一样，新的 Vue 应用可能会以多种方式崩溃，因此，在发布前发现并解决这些问题就变得十分重要。\n\n在本篇指引中，我们将介绍一些基本术语，并就你的 Vue 3 应用应选择哪些工具提供一些建议。\n\n还有一个特定用于 Vue 的小节，介绍了组合式函数的测试，详情请参阅[测试组合式函数](#testing-composables)。\n\n## 何时测试 {#when-to-test}\n\n越早越好！我们建议你尽快开始编写测试。拖得越久，应用就会有越多的依赖和复杂性，想要开始添加测试也就越困难。\n\n## 测试的类型 {#testing-types}\n\n当设计你的 Vue 应用的测试策略时，你应该利用以下几种测试类型：\n\n- **单元测试**：检查给定函数、类或组合式函数的输入是否产生预期的输出或副作用。\n- **组件测试**：检查你的组件是否正常挂载和渲染、是否可以与之互动，以及表现是否符合预期。这些测试比单元测试导入了更多的代码，更复杂，需要更多时间来执行。\n- **端到端测试**：检查跨越多个页面的功能，并对生产构建的 Vue 应用进行实际的网络请求。这些测试通常涉及到建立一个数据库或其他后端。\n\n每种测试类型在你的应用的测试策略中都发挥着作用，保护你免受不同类型的问题的影响。\n\n## 总览 {#overview}\n\n我们将简要地讨论这些测试是什么，以及如何在 Vue 应用中实现它们，并提供一些普适性建议。\n\n## 单元测试 {#unit-testing}\n\n编写单元测试是为了验证小的、独立的代码单元是否按预期工作。一个单元测试通常覆盖一个单个函数、类、组合式函数或模块。单元测试侧重于逻辑上的正确性，只关注应用整体功能的一小部分。他们可能会模拟你的应用环境的很大一部分(如初始状态、复杂的类、第三方模块和网络请求)。\n\n一般来说，单元测试将捕获函数的业务逻辑和逻辑正确性的问题。\n\n以这个 `increment` 函数为例：\n\n```js [helpers.js]\nexport function increment(current, max = 10) {\n  if (current < max) {\n    return current + 1\n  }\n  return current\n}\n```\n\n因为它很独立，可以很容易地调用 `increment` 函数并断言它是否返回了所期望的内容，所以我们将编写一个单元测试。\n\n如果任何一条断言失败了，那么问题一定是出在 `increment` 函数上。\n\n```js{3-15} [helpers.spec.js]\nimport { increment } from './helpers'\n\ndescribe('increment', () => {\n  test('increments the current number by 1', () => {\n    expect(increment(0, 10)).toBe(1)\n  })\n\n  test('does not increment the current number over the max', () => {\n    expect(increment(10, 10)).toBe(10)\n  })\n\n  test('has a default max of 10', () => {\n    expect(increment(10)).toBe(10)\n  })\n})\n```\n\n如前所述，单元测试通常适用于独立的业务逻辑、组件、类、模块或函数，不涉及 UI 渲染、网络请求或其他环境问题。\n\n这些通常是与 Vue 无关的纯 JavaScript/TypeScript 模块。一般来说，在 Vue 应用中为业务逻辑编写单元测试与使用其他框架的应用没有明显区别。\n\n但有两种情况，你必须对 Vue 的特定功能进行单元测试：\n\n1. 组合式函数\n2. 组件\n\n### 组合式函数 {#composables}\n\n有一类 Vue 应用中特有的函数被称为 [组合式函数](/guide/reusability/composables)，在测试过程中可能需要特殊处理。\n你可以跳转到下方查看 [测试组合式函数](#testing-composables) 了解更多细节。\n\n### 组件的单元测试 {#unit-testing-components}\n\n一个组件可以通过两种方式测试：\n\n1. 白盒：单元测试\n\n   白盒测试知晓一个组件的实现细节和依赖关系。它们更专注于将组件进行更 **独立** 的测试。这些测试通常会涉及到模拟一些组件的部分子组件，以及设置插件的状态和依赖性(例如 Pinia)。\n\n2. 黑盒：组件测试\n\n   黑盒测试不知晓一个组件的实现细节。这些测试尽可能少地模拟，以测试组件在整个系统中的集成情况。它们通常会渲染所有子组件，因而会被认为更像一种“集成测试”。请查看下方的[组件测试建议](#component-testing)作进一步了解。\n\n### 推荐方案 {#recommendation}\n\n- [Vitest](https://vitest.dev/)\n\n  因为由 `create-vue` 创建的官方项目配置是基于 [Vite](https://cn.vitejs.dev/) 的，所以我们推荐你使用一个可以利用同一套 Vite 配置和转换管道的单元测试框架。[Vitest](https://cn.vitest.dev/) 正是一个针对此目标设计的单元测试框架，它由 Vue / Vite 团队成员开发和维护。在 Vite 的项目集成它会非常简单，而且速度非常快。\n\n### 其他选择 {#other-options}\n\n- [Jest](https://jestjs.io/) 是一个广受欢迎的单元测试框架。不过，我们只推荐你在已有一套 Jest 测试配置、且需要迁移到基于 Vite 的项目时使用它，因为 Vitest 提供了更无缝的集成和更好的性能。\n\n## 组件测试 {#component-testing}\n\n在 Vue 应用中，主要用组件来构建用户界面。因此，当验证应用的行为时，组件是一个很自然的独立单元。从粒度的角度来看，组件测试位于单元测试之上，可以被认为是集成测试的一种形式。你的 Vue 应用中大部分内容都应该由组件测试来覆盖，我们建议每个 Vue 组件都应有自己的组件测试文件。\n\n组件测试应该捕捉组件中的 prop、事件、提供的插槽、样式、CSS class 名、生命周期钩子，和其他相关的问题。\n\n组件测试不应该模拟子组件，而应该像用户一样，通过与组件互动来测试组件和其子组件之间的交互。例如，组件测试应该像用户那样点击一个元素，而不是编程式地与组件进行交互。\n\n组件测试主要需要关心组件的公开接口而不是内部实现细节。对于大部分的组件来说，公开接口包括触发的事件、prop 和插槽。当进行测试时，请记住，**测试这个组件做了什么，而不是测试它是怎么做到的**。\n\n- **推荐的做法**\n\n  - 对于 **视图** 的测试：根据输入 prop 和插槽断言渲染输出是否正确。\n  - 对于 **交互** 的测试：断言渲染的更新是否正确或触发的事件是否正确地响应了用户输入事件。\n\n  在下面的例子中，我们展示了一个步进器 (Stepper) 组件，它拥有一个标记为 `increment` 的可点击的 DOM 元素。我们还传入了一个名为 `max` 的 prop 防止步进器增长超过 `2`，因此如果我们点击了按钮 3 次，视图将仍然显示 `2`。\n\n  我们不了解这个步进器的实现细节，只知道“输入”是这个 `max` prop，“输出”是这个组件状态所呈现出的视图。\n\n::: code-group\n\n```js [Vue Test Utils]\nconst valueSelector = '[data-testid=stepper-value]'\nconst buttonSelector = '[data-testid=increment]'\n\nconst wrapper = mount(Stepper, {\n  props: {\n    max: 1\n  }\n})\n\nexpect(wrapper.find(valueSelector).text()).toContain('0')\n\nawait wrapper.find(buttonSelector).trigger('click')\n\nexpect(wrapper.find(valueSelector).text()).toContain('1')\n```\n\n```js [Cypress]\nconst valueSelector = '[data-testid=stepper-value]'\nconst buttonSelector = '[data-testid=increment]'\n\nmount(Stepper, {\n  props: {\n    max: 1\n  }\n})\n\ncy.get(valueSelector)\n  .should('be.visible')\n  .and('contain.text', '0')\n  .get(buttonSelector)\n  .click()\n  .get(valueSelector)\n  .should('contain.text', '1')\n```\n\n```js [Testing Library]\nconst { getByText } = render(Stepper, {\n  props: {\n    max: 1\n  }\n})\n\ngetByText('0') // Implicit assertion that \"0\" is within the component\n\nconst button = getByRole('button', { name: /increment/i })\n\n// Dispatch a click event to our increment button.\nawait fireEvent.click(button)\n\ngetByText('1')\n\nawait fireEvent.click(button)\n```\n\n:::\n\n**应避免的做法**\n\n- 不要去断言一个组件实例的私有状态或测试一个组件的私有方法。测试实现细节会使测试代码太脆弱，因为当实现发生变化时，它们更有可能失败并需要更新重写。\n\n  组件的最终工作是渲染正确的 DOM 输出，所以专注于 DOM 输出的测试提供了足够的正确性保证(如果你不需要更多其他方面测试的话)，同时更加健壮、需要的改动更少。\n\n  不要完全依赖快照测试。断言 HTML 字符串并不能完全说明正确性。应当编写有意图的测试。\n\n  如果一个方法需要测试，把它提取到一个独立的实用函数中，并为它写一个专门的单元测试。如果它不能被直截了当地抽离出来，那么对它的调用应该作为交互测试的一部分。\n\n### 推荐方案 {#recommendation-1}\n\n- [Vitest](https://vitest.dev/) 对于组件和组合式函数都采用无头渲染的方式 (例如 VueUse 中的 [`useFavicon`](https://vueuse.org/core/useFavicon/#usefavicon) 函数)。组件和 DOM 都可以通过 [@vue/test-utils](https://github.com/vuejs/test-utils) 来测试。\n\n- [Cypress 组件测试](https://on.cypress.io/component) 会预期其准确地渲染样式或者触发原生 DOM 事件。它可以搭配 [@testing-library/cypress](https://testing-library.com/docs/cypress-testing-library/intro) 这个库一同进行测试。\n\nVitest 和基于浏览器的运行器之间的主要区别是速度和执行上下文。简而言之，基于浏览器的运行器，如 Cypress，可以捕捉到基于 Node 的运行器(如 Vitest) 所不能捕捉的问题(比如样式问题、原生 DOM 事件、Cookies、本地存储和网络故障)，但基于浏览器的运行器比 Vitest *慢几个数量级*，因为它们要执行打开浏览器，编译样式表以及其他步骤。Cypress 是一个基于浏览器的运行器，支持组件测试。请阅读 [Vitest 文档的“比较”这一章](https://vitest.dev/guide/comparisons.html#cypress) 了解 Vitest 和 Cypress 最新的比较信息。\n\n### 组件挂载库 {#mounting-libraries}\n\n组件测试通常涉及到单独挂载被测试的组件，触发模拟的用户输入事件，并对渲染的 DOM 输出进行断言。有一些专门的工具库可以使这些任务变得更简单。\n\n- [`@vue/test-utils`](https://github.com/vuejs/test-utils) 是官方的底层组件测试库，用来提供给用户访问 Vue 特有的 API。`@testing-library/vue` 也是基于此库构建的。\n\n- [`@testing-library/vue`](https://github.com/testing-library/vue-testing-library) 是一个专注于测试组件而不依赖于实现细节的 Vue 测试库。它的指导原则是：测试越是类似于软件的使用方式，它们就能提供越多的信心。\n\n我们推荐在应用中使用 `@vue/test-utils` 测试组件。`@testing-library/vue` 在测试带有 Suspense 的异步组件时存在问题，在使用时需要谨慎。\n\n### 其他选择 {#other-options-1}\n\n- [Nightwatch](https://v2.nightwatchjs.org/) 是一个端到端测试运行器，支持 Vue 的组件测试。(Nightwatch v2 版本的 [示例项目](https://github.com/nightwatchjs-community/todo-vue))\n\n- [WebdriverIO](https://webdriver.io/docs/component-testing/vue) 用于跨浏览器组件测试，该测试依赖于基于标准自动化的原生用户交互。它也可以与测试库一起使用。\n\n## 端到端 (E2E) 测试 {#e2e-testing}\n\n虽然单元测试为所写的代码提供了一定程度的验证，但单元测试和组件测试在部署到生产时，对应用整体覆盖的能力有限。因此，端到端测试针对的可以说是应用最重要的方面：当用户实际使用你的应用时发生了什么。\n\n端到端测试的重点是多页面的应用表现，针对你的应用在生产环境下进行网络请求。他们通常需要建立一个数据库或其他形式的后端，甚至可能针对一个预备上线的环境运行。\n\n端到端测试通常会捕捉到路由、状态管理库、顶级组件(常见为 App 或 Layout)、公共资源或任何请求处理方面的问题。如上所述，它们可以捕捉到单元测试或组件测试无法捕捉的关键问题。\n\n端到端测试不导入任何 Vue 应用的代码，而是完全依靠在真实浏览器中浏览整个页面来测试你的应用。\n\n端到端测试验证了你的应用中的许多层。可以在你的本地构建的应用中，甚至是一个预上线的环境中运行。针对预上线环境的测试不仅包括你的前端代码和静态服务器，还包括所有相关的后端服务和基础设施。\n\n> 你的测试越是类似于你的软件的使用方式，它们就越能值得你信赖。- [Kent C. Dodds](https://twitter.com/kentcdodds/status/977018512689455106) - Testing Library 的作者\n\n通过测试用户操作如何影响你的应用，端到端测试通常是提高应用能否正常运行的置信度的关键。\n\n### 选择一个端到端测试解决方案 {#choosing-an-e2e-testing-solution}\n\n虽然因为不可靠且拖慢了开发过程，市面上对 Web 上的端到端测试的评价并不好，但现代端到端工具已经在创建更可靠、更有用和交互性更好的测试方面取得了很大进步。在选择端到端测试框架时，以下小节会为你给应用选择测试框架时需要注意的事项提供一些指导。\n\n#### 跨浏览器测试 {#cross-browser-testing}\n\n端到端测试的一个主要优点是你可以了解你的应用在多个不同浏览器上运行的情况。尽管理想情况应该是 100% 的跨浏览器覆盖率，但很重要的一点是跨浏览器测试对团队资源的回报是递减的，因为需要额外的时间和机器来持续运行它们。因此，在选择应用所需的跨浏览器测试的数量时，注意权衡是很有必要的。\n\n#### 更快的反馈 {#faster-feedback-loops}\n\n端到端测试和相应开发过程的主要问题之一是，运行整个套件需要很长的时间。通常情况下，这只在持续集成和部署 (CI/CD) 管道中进行。现代的端到端测试框架通过增加并行化等功能来帮助解决这个问题，这使得 CI/CD 管道的运行速度比以前快了几倍。此外，在本地开发时，能够有选择地为你正在工作的页面运行单个测试，同时还提供测试的热重载，大大提高了开发者的工作流程和生产力。\n\n#### 第一优先级的调试体验 {#first-class-debugging-experience}\n\n传统上，开发者依靠扫描终端窗口中的日志来帮助确定测试中出现的问题，而现代端到端测试框架允许开发者利用他们已经熟悉的工具，例如浏览器开发工具。\n\n#### 无头模式下的可见性 {#visibility-in-headless-mode}\n\n当端到端测试在 CI/CD 管道中运行时，它们通常在无头浏览器(即不带界面的浏览器)中运行。因此，当错误发生时，现代端到端测试框架的一个关键特性是能够在不同的测试阶段查看应用的快照、视频，从而深入了解错误的原因。而在很早以前，要手动维护这些集成是非常繁琐的。\n\n### 推荐方案 {#recommendation-2}\n\n- [Playwright](https://playwright.dev/) 是一个非常好的端到端测试解决方案，支持 Chromium、WebKit 和 Firefox。在 Windows、Linux 和 macOS 上进行本地或 CI 测试、无头测试，或使用适用于 Android 和 Mobile Safari 的 Google Chrome 的原生移动端模拟测试。它拥有信息丰富的用户界面、出色的调试能力、内置断言、并行处理功能以及追踪功能，旨在消除不稳定的测试。它还提供对[组件测试](https://playwright.dev/docs/test-components)的支持，但目前处于实验阶段。Playwright 由微软开源并维护。\n\n- [Cypress](https://www.cypress.io/) 具有信息丰富的图形界面、出色的调试性、内置断言、存根、抗剥落性、并行化和快照等诸多特性。而且如上所述，它还提供对 [组件测试](https://docs.cypress.io/guides/component-testing/introduction) 的支持。它支持基于 Chromium 的浏览器、Firefox 和 Electron。但 WebKit 被标记为实验性支持。Cypress 采用 MIT 许可，但并行化等部分功能需要订阅 Cypress Cloud。\n\n<div class=\"lambdatest\">\n  <a href=\"https://lambdatest.com\" target=\"_blank\">\n    <img src=\"/images/lambdatest.svg\">\n    <div>\n      <div class=\"testing-partner\">测试赞助商</div>\n      <div>Lambdatest 是一个云平台，用于在所有主流浏览器和真实设备上运行 E2E、可访问性和可视化回归测试，并提供人工智能辅助测试生成！</div>\n    </div>\n  </a>\n</div>\n\n### 其他选项 {#other-options-2}\n\n- [Nightwatch](https://nightwatchjs.org/) 是一个基于 [Selenium WebDriver](https://www.npmjs.com/package/selenium-webdriver) 的端到端测试解决方案。它的浏览器品类支持范围是最广的，包括原生移动测试。基于 Selenium 的解决方案将比 Playwright 或 Cypress 慢。\n\n- [WebdriverIO](https://webdriver.io/) 是一个基于 WebDriver 协议的网络和移动测试的自动化测试框架。\n\n## 用例指南 {#recipes}\n\n### 添加 Vitest 到项目中 {#adding-vitest-to-a-project}\n\n在一个基于 Vite 的 Vue 项目中，运行如下命令：\n\n```sh\n> npm install -D vitest happy-dom @testing-library/vue\n```\n\n接着，更新你的 Vite 配置，添加上 `test` 选项：\n\n```js{5-11} [vite.config.js]\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  // ...\n  test: {\n    // 启用类似 jest 的全局测试 API\n    globals: true,\n    // 使用 happy-dom 模拟 DOM\n    // 这需要你安装 happy-dom 作为对等依赖 (peer dependency)\n    environment: 'happy-dom'\n  }\n})\n```\n\n:::tip\n如果使用 TypeScript，请将 `vitest/globals` 添加到 `tsconfig.json` 的 `types` 字段当中。\n\n```json [tsconfig.json]\n{\n  \"compilerOptions\": {\n    \"types\": [\"vitest/globals\"]\n  }\n}\n```\n\n:::\n\n接着，在你的项目中创建名字以 `*.test.js` 结尾的文件。你可以把所有的测试文件放在项目根目录下的 `test` 目录中，或者放在源文件旁边的 `test` 目录中。Vitest 会使用命名规则自动搜索它们。\n\n```js [MyComponent.test.js]\nimport { render } from '@testing-library/vue'\nimport MyComponent from './MyComponent.vue'\n\ntest('it should work', () => {\n  const { getByText } = render(MyComponent, {\n    props: {\n      /* ... */\n    }\n  })\n\n  // 断言输出\n  getByText('...')\n})\n```\n\n最后，在 `package.json` 之中添加测试命令，然后运行它：\n\n```json{4} [package.json]\n{\n  // ...\n  \"scripts\": {\n    \"test\": \"vitest\"\n  }\n}\n```\n\n```sh\n> npm test\n```\n\n### 测试组合式函数 {#testing-composables}\n\n> 这一小节假设你已经读过了[组合式函数](/guide/reusability/composables)这一章。\n\n当涉及到测试组合式函数时，我们可以根据是否依赖宿主组件实例把它们分为两类。\n\n当一个组合式函数使用以下 API 时，它依赖于一个宿主组件实例：\n\n- 生命周期钩子\n- 供给/注入\n\n如果一个组合式程序只使用响应式 API，那么它可以通过直接调用并断言其返回的状态或方法来进行测试。\n\n```js [counter.js]\nimport { ref } from 'vue'\n\nexport function useCounter() {\n  const count = ref(0)\n  const increment = () => count.value++\n\n  return {\n    count,\n    increment\n  }\n}\n```\n\n```js [counter.test.js]\nimport { useCounter } from './counter.js'\n\ntest('useCounter', () => {\n  const { count, increment } = useCounter()\n  expect(count.value).toBe(0)\n\n  increment()\n  expect(count.value).toBe(1)\n})\n```\n\n一个依赖生命周期钩子或供给/注入的组合式函数需要被包装在一个宿主组件中才可以测试。我们可以创建下面这样的帮手函数：\n\n```js [test-utils.js]\nimport { createApp } from 'vue'\n\nexport function withSetup(composable) {\n  let result\n  const app = createApp({\n    setup() {\n      result = composable()\n      // 忽略模板警告\n      return () => {}\n    }\n  })\n  app.mount(document.createElement('div'))\n  // 返回结果与应用实例\n  // 用来测试供给和组件卸载\n  return [result, app]\n}\n```\n\n```js [foo.test.js]\nimport { withSetup } from './test-utils'\nimport { useFoo } from './foo'\n\ntest('useFoo', () => {\n  const [result, app] = withSetup(() => useFoo(123))\n  // 为注入的测试模拟一方供给\n  app.provide(...)\n  // 执行断言\n  expect(result.foo.value).toBe(1)\n  // 如果需要的话可以这样触发\n  app.unmount()\n})\n```\n\n对于更复杂的组合式函数，通过使用[组件测试](#component-testing)编写针对这个包装器组件的测试，这会容易很多。\n\n<!--\nTODO more testing recipes can be added in the future e.g.\n- How to set up CI via GitHub actions\n- How to do mocking in component testing\n-->\n\n<!-- zhlint disabled -->\n\n\n\n================================================\nFILE: src/guide/scaling-up/tooling.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/guide/typescript/composition-api.md\n================================================\n# TypeScript 与组合式 API {#typescript-with-composition-api}\n\n<ScrimbaLink href=\"https://scrimba.com/links/vue-ts-composition-api\" title=\"Free Vue.js TypeScript with Composition API Lesson\" type=\"scrimba\">\n  观看 Scrimba 的互动视频课程\n</ScrimbaLink>\n\n> 这一章假设你已经阅读了[搭配 TypeScript 使用 Vue](./overview) 的概览。\n\n## 为组件的 props 标注类型 {#typing-component-props}\n\n### 使用 `<script setup>` {#using-script-setup}\n\n当使用 `<script setup>` 时，`defineProps()` 宏函数支持从它的参数中推导类型：\n\n```vue\n<script setup lang=\"ts\">\nconst props = defineProps({\n  foo: { type: String, required: true },\n  bar: Number\n})\n\nprops.foo // string\nprops.bar // number | undefined\n</script>\n```\n\n这被称之为“运行时声明”，因为传递给 `defineProps()` 的参数会作为运行时的 `props` 选项使用。\n\n然而，通过泛型参数来定义 props 的类型通常更直接：\n\n```vue\n<script setup lang=\"ts\">\nconst props = defineProps<{\n  foo: string\n  bar?: number\n}>()\n</script>\n```\n\n这被称之为“基于类型的声明”。编译器会尽可能地尝试根据类型参数推导出等价的运行时选项。在这种场景下，我们第二个例子中编译出的运行时选项和第一个是完全一致的。\n\n基于类型的声明或者运行时声明可以择一使用，但是不能同时使用。\n\n我们也可以将 props 的类型移入一个单独的接口中：\n\n```vue\n<script setup lang=\"ts\">\ninterface Props {\n  foo: string\n  bar?: number\n}\n\nconst props = defineProps<Props>()\n</script>\n```\n\n这同样适用于 `Props` 从另一个源文件中导入的情况。该功能要求 TypeScript 作为 Vue 的一个 peer dependency。\n\n```vue\n<script setup lang=\"ts\">\nimport type { Props } from './foo'\n\nconst props = defineProps<Props>()\n</script>\n```\n\n#### 语法限制 {#syntax-limitations}\n\n在 3.2 及以下版本中，`defineProps()` 的泛型类型参数仅限于类型字面量或对本地接口的引用。\n\n这个限制在 3.3 中得到了解决。最新版本的 Vue 支持在类型参数位置引用导入和有限的复杂类型。但是，由于类型到运行时转换仍然基于 AST，一些需要实际类型分析的复杂类型，例如条件类型，还未支持。你可以使用条件类型来指定单个 prop 的类型，但不能用于整个 props 对象的类型。\n\n### Props 解构默认值 {#props-default-values}\n\n当使用基于类型的声明时，我们失去了为 props 声明默认值的能力。可以通过使用[响应式 Props 解构](/guide/components/props#reactive-props-destructure)解决这个问题。 <sup class=\"vt-badge\" data-text=\"3.5+\" />：\n\n```ts\ninterface Props {\n  msg?: string\n  labels?: string[]\n}\n\nconst { msg = 'hello', labels = ['one', 'two'] } = defineProps<Props>()\n```\n\n在 3.4 及更低版本，响应式 Props 解构不会被默认启用。另一种选择是使用 `withDefaults` 编译器宏：\n\n```ts\ninterface Props {\n  msg?: string\n  labels?: string[]\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  msg: 'hello',\n  labels: () => ['one', 'two']\n})\n```\n\n这将被编译为等效的运行时 props `default` 选项。此外，`withDefaults` 帮助程序为默认值提供类型检查，并确保返回的 props 类型删除了已声明默认值的属性的可选标志。\n\n:::info\n请注意，在使用 `withDefaults` 时，默认值的可变引用类型 (如数组或对象) 应该在函数中进行包装，以避免意外修改和外部副作用。这样可以确保每个组件实例都会获得自己默认值的副本。当使用解构时，这**不**是必要的。\n:::\n\n### 非 `<script setup>` 场景下 {#without-script-setup}\n\n如果没有使用 `<script setup>`，那么为了开启 props 的类型推导，必须使用 `defineComponent()`。传入 `setup()` 的 props 对象类型是从 `props` 选项中推导而来。\n\n```ts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  props: {\n    message: String\n  },\n  setup(props) {\n    props.message // <-- 类型：string\n  }\n})\n```\n\n### 复杂的 prop 类型 {#complex-prop-types}\n\n通过基于类型的声明，一个 prop 可以像使用其他任何类型一样使用一个复杂类型：\n\n```vue\n<script setup lang=\"ts\">\ninterface Book {\n  title: string\n  author: string\n  year: number\n}\n\nconst props = defineProps<{\n  book: Book\n}>()\n</script>\n```\n\n对于运行时声明，我们可以使用 `PropType` 工具类型：\n\n```ts\nimport type { PropType } from 'vue'\n\nconst props = defineProps({\n  book: Object as PropType<Book>\n})\n```\n\n其工作方式与直接指定 `props` 选项基本相同：\n\n```ts\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\n\nexport default defineComponent({\n  props: {\n    book: Object as PropType<Book>\n  }\n})\n```\n\n`props` 选项通常用于 Options API，因此你会在[选项式 API 与 TypeScript](/guide/typescript/options-api#typing-component-props) 指南中找到更详细的例子。这些例子中展示的技术也适用于使用 `defineProps()` 的运行时声明。\n\n## 为组件的 emits 标注类型 {#typing-component-emits}\n\n在 `<script setup>` 中，`emit` 函数的类型标注也可以通过运行时声明或是类型声明进行：\n\n```vue\n<script setup lang=\"ts\">\n// 运行时\nconst emit = defineEmits(['change', 'update'])\n\n// 基于选项\nconst emit = defineEmits({\n  change: (id: number) => {\n    // 返回 `true` 或 `false`\n    // 表明验证通过或失败\n  },\n  update: (value: string) => {\n    // 返回 `true` 或 `false`\n    // 表明验证通过或失败\n  }\n})\n\n// 基于类型\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n\n// 3.3+: 可选的、更简洁的语法\nconst emit = defineEmits<{\n  change: [id: number]\n  update: [value: string]\n}>()\n</script>\n```\n\n类型参数可以是以下的一种：\n\n1. 一个可调用的函数类型，但是写作一个包含[调用签名](https://www.typescriptlang.org/docs/handbook/2/functions.html#call-signatures)的类型字面量。它将被用作返回的 `emit` 函数的类型。\n2. 一个类型字面量，其中键是事件名称，值是数组或元组类型，表示事件的附加接受参数。上面的示例使用了具名元组，因此每个参数都可以有一个显式的名称。\n\n我们可以看到，基于类型的声明使我们可以对所触发事件的类型进行更细粒度的控制。\n\n若没有使用 `<script setup>`，`defineComponent()` 也可以根据 `emits` 选项推导暴露在 setup 上下文中的 `emit` 函数的类型：\n\n```ts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  emits: ['change'],\n  setup(props, { emit }) {\n    emit('change') // <-- 类型检查 / 自动补全\n  }\n})\n```\n\n## 为 `ref()` 标注类型 {#typing-ref}\n\nref 会根据初始化时的值推导其类型：\n\n```ts\nimport { ref } from 'vue'\n\n// 推导出的类型：Ref<number>\nconst year = ref(2020)\n\n// => TS Error: Type 'string' is not assignable to type 'number'.\nyear.value = '2020'\n```\n\n有时我们可能想为 ref 内的值指定一个更复杂的类型，可以通过使用 `Ref` 这个类型：\n\n```ts\nimport { ref } from 'vue'\nimport type { Ref } from 'vue'\n\nconst year: Ref<string | number> = ref('2020')\n\nyear.value = 2020 // 成功！\n```\n\n或者，在调用 `ref()` 时传入一个泛型参数，来覆盖默认的推导行为：\n\n```ts\n// 得到的类型：Ref<string | number>\nconst year = ref<string | number>('2020')\n\nyear.value = 2020 // 成功！\n```\n\n如果你指定了一个泛型参数但没有给出初始值，那么最后得到的就将是一个包含 `undefined` 的联合类型：\n\n```ts\n// 推导得到的类型：Ref<number | undefined>\nconst n = ref<number>()\n```\n\n## 为 `reactive()` 标注类型 {#typing-reactive}\n\n`reactive()` 也会隐式地从它的参数中推导类型：\n\n```ts\nimport { reactive } from 'vue'\n\n// 推导得到的类型：{ title: string }\nconst book = reactive({ title: 'Vue 3 指引' })\n```\n\n要显式地标注一个 `reactive` 变量的类型，我们可以使用接口：\n\n```ts\nimport { reactive } from 'vue'\n\ninterface Book {\n  title: string\n  year?: number\n}\n\nconst book: Book = reactive({ title: 'Vue 3 指引' })\n```\n\n:::tip\n不推荐使用 `reactive()` 的泛型参数，因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。\n:::\n\n## 为 `computed()` 标注类型 {#typing-computed}\n\n`computed()` 会自动从其计算函数的返回值上推导出类型：\n\n```ts\nimport { ref, computed } from 'vue'\n\nconst count = ref(0)\n\n// 推导得到的类型：ComputedRef<number>\nconst double = computed(() => count.value * 2)\n\n// => TS Error: Property 'split' does not exist on type 'number'\nconst result = double.value.split('')\n```\n\n你还可以通过泛型参数显式指定类型：\n\n```ts\nconst double = computed<number>(() => {\n  // 若返回值不是 number 类型则会报错\n})\n```\n\n## 为事件处理函数标注类型 {#typing-event-handlers}\n\n在处理原生 DOM 事件时，应该为我们传递给事件处理函数的参数正确地标注类型。让我们看一下这个例子：\n\n```vue\n<script setup lang=\"ts\">\nfunction handleChange(event) {\n  // `event` 隐式地标注为 `any` 类型\n  console.log(event.target.value)\n}\n</script>\n\n<template>\n  <input type=\"text\" @change=\"handleChange\" />\n</template>\n```\n\n没有类型标注时，这个 `event` 参数会隐式地标注为 `any` 类型。这也会在 `tsconfig.json` 中配置了 `\"strict\": true` 或 `\"noImplicitAny\": true` 时报出一个 TS 错误。因此，建议显式地为事件处理函数的参数标注类型。此外，你在访问 `event` 上的属性时可能需要使用类型断言：\n\n```ts\nfunction handleChange(event: Event) {\n  console.log((event.target as HTMLInputElement).value)\n}\n```\n\n## 为 provide / inject 标注类型 {#typing-provide-inject}\n\nprovide 和 inject 通常会在不同的组件中运行。要正确地为注入的值标记类型，Vue 提供了一个 `InjectionKey` 接口，它是一个继承自 `Symbol` 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型：\n\n```ts\nimport { provide, inject } from 'vue'\nimport type { InjectionKey } from 'vue'\n\nconst key = Symbol() as InjectionKey<string>\n\nprovide(key, 'foo') // 若提供的是非字符串值会导致错误\n\nconst foo = inject(key) // foo 的类型：string | undefined\n```\n\n建议将注入 key 的类型放在一个单独的文件中，这样它就可以被多个组件导入。\n\n当使用字符串注入 key 时，注入值的类型是 `unknown`，需要通过泛型参数显式声明：\n\n```ts\nconst foo = inject<string>('foo') // 类型：string | undefined\n```\n\n注意注入的值仍然可以是 `undefined`，因为无法保证提供者一定会在运行时 provide 这个值。\n\n当提供了一个默认值后，这个 `undefined` 类型就可以被移除：\n\n```ts\nconst foo = inject<string>('foo', 'bar') // 类型：string\n```\n\n如果你确定该值将始终被提供，则还可以强制转换该值：\n\n```ts\nconst foo = inject('foo') as string\n```\n\n## 为模板引用标注类型 {#typing-template-refs}\n\n在 Vue 3.5 和 @vue/language-tools 2.1 (为 IDE 语言服务和 vue-tsc 提供支持) 中，在单文件组件中由 `useTemplateRef()` 创建的 ref 类型可以基于匹配的 ref attribute 所在的元素**自动推断**为静态类型。\n\n在无法自动推断的情况下，仍然可以通过泛型参数将模板 ref 转换为显式类型。\n\n```ts\nconst el = useTemplateRef<HTMLInputElement>('el')\n```\n\n<details>\n<summary>3.5 前的用法</summary>\n\n模板引用需要通过一个显式指定的泛型参数和一个初始值 `null` 来创建：\n\n```vue\n<script setup lang=\"ts\">\nimport { ref, onMounted } from 'vue'\n\nconst el = ref<HTMLInputElement | null>(null)\n\nonMounted(() => {\n  el.value?.focus()\n})\n</script>\n\n<template>\n  <input ref=\"el\" />\n</template>\n```\n\n</details>\n\n可以通过类似于 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input#technical_summary) 的页面来获取正确的 DOM 接口。\n\n注意为了严格的类型安全，有必要在访问 `el.value` 时使用可选链或类型守卫。这是因为直到组件被挂载前，这个 ref 的值都是初始的 `null`，并且在由于 `v-if` 的行为将引用的元素卸载时也可以被设置为 `null`。\n\n## 为组件模板引用标注类型 {#typing-component-template-refs}\n\n在 Vue 3.5 和 @vue/language-tools 2.1 (为 IDE 语言服务和 vue-tsc 提供支持) 中，在单文件组件中由 `useTemplateRef()` 创建的 ref 类型可以基于匹配的 ref attribute 所在的元素**自动推断**为静态类型。\n\n在无法自动推断的情况下 (如非单文件组件使用或动态组件)，仍然可以通过泛型参数将模板 ref 强制转换为显式类型。\n\n为了获取导入组件的实例类型，我们需要先通过 `typeof` 获取其类型，然后使用 TypeScript 的内置 `InstanceType` 工具提取其实例类型：\n\n```vue{6,7} [App.vue]\n<script setup lang=\"ts\">\nimport { useTemplateRef } from 'vue'\nimport Foo from './Foo.vue'\nimport Bar from './Bar.vue'\n\ntype FooType = InstanceType<typeof Foo>\ntype BarType = InstanceType<typeof Bar>\n\nconst compRef = useTemplateRef<FooType | BarType>('comp')\n</script>\n\n<template>\n  <component :is=\"Math.random() > 0.5 ? Foo : Bar\" ref=\"comp\" />\n</template>\n```\n\n如果组件的具体类型无法获得，或者你并不关心组件的具体类型，那么可以使用 `ComponentPublicInstance`。这只会包含所有组件都共享的属性，比如 `$el`。\n\n```ts\nimport { useTemplateRef } from 'vue'\nimport type { ComponentPublicInstance } from 'vue'\n\nconst child = useTemplateRef<ComponentPublicInstance>('child')\n```\n\n如果引用的组件是一个[泛型组件](/guide/typescript/overview.html#generic-components)，例如 `MyGenericModal`：\n\n```vue [MyGenericModal.vue]\n<script setup lang=\"ts\" generic=\"ContentType extends string | number\">\nimport { ref } from 'vue'\n\nconst content = ref<ContentType | null>(null)\n\nconst open = (newContent: ContentType) => (content.value = newContent)\n\ndefineExpose({\n  open\n})\n</script>\n```\n\n则需要使用 [`vue-component-type-helpers`](https://www.npmjs.com/package/vue-component-type-helpers) 库中的 `ComponentExposed` 来引用组件类型，因为 `InstanceType` 在这种场景下不起作用。\n\n```vue [App.vue]\n<script setup lang=\"ts\">\nimport { useTemplateRef } from 'vue'\nimport MyGenericModal from './MyGenericModal.vue'\nimport type { ComponentExposed } from 'vue-component-type-helpers'\n\nconst modal =\n  useTemplateRef<ComponentExposed<typeof MyGenericModal>>('modal')\n\nconst openModal = () => {\n  modal.value?.open('newValue')\n}\n</script>\n```\n\n请注意在 `@vue/language-tools` 2.1 以上版本中，静态模板 ref 的类型可以被自动推导，上述这些仅在极端情况下需要。\n\n## 为自定义全局指令添加类型 {#typing-global-custom-directives}\n\n可以通过扩展 `ComponentCustomProperties` 来为使用 `app.directive()` 声明的全局自定义指令获取类型提示和类型检查\n\n```ts [src/directives/highlight.ts]\nimport type { Directive } from 'vue'\n\nexport type HighlightDirective = Directive<HTMLElement, string>\n\ndeclare module 'vue' {\n  export interface ComponentCustomProperties {\n    // 使用 v 作为前缀 (v-highlight)\n    vHighlight: HighlightDirective\n  }\n}\n\nexport default {\n  mounted: (el, binding) => {\n    el.style.backgroundColor = binding.value\n  }\n} satisfies HighlightDirective\n```\n\n```ts [main.ts]\nimport highlight from './directives/highlight'\n// ...其它代码\nconst app = createApp(App)\napp.directive('highlight', highlight)\n```\n\n在组件中使用\n\n```vue [App.vue]\n<template>\n  <p v-highlight=\"'blue'\">This sentence is important!</p>\n</template>\n```\n\n\n\n================================================\nFILE: src/guide/typescript/options-api.md\n================================================\n# TypeScript 与选项式 API {#typescript-with-options-api}\n\n> 这一章假设你已经阅读了[搭配 TypeScript 使用 Vue](./overview) 的概览。\n\n:::tip\n虽然 Vue 的确支持在选项式 API 中使用 TypeScript，但在使用 TypeScript 的前提下更推荐使用组合式 API，因为它提供了更简单、高效和可靠的类型推导。\n:::\n\n## 为组件的 props 标注类型 {#typing-component-props}\n\n选项式 API 中对 props 的类型推导需要用 `defineComponent()` 来包装组件。有了它，Vue 才可以通过 `props` 以及一些额外的选项，比如 `required: true` 和 `default` 来推导出 props 的类型：\n\n```ts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  // 启用了类型推导\n  props: {\n    name: String,\n    id: [Number, String],\n    msg: { type: String, required: true },\n    metadata: null\n  },\n  mounted() {\n    this.name // 类型：string | undefined\n    this.id // 类型：number | string | undefined\n    this.msg // 类型：string\n    this.metadata // 类型：any\n  }\n})\n```\n\n然而，这种运行时 `props` 选项仅支持使用构造函数来作为一个 prop 的类型——没有办法指定多层级对象或函数签名之类的复杂类型。\n\n我们可以使用 `PropType` 这个工具类型来标记更复杂的 props 类型：\n\n```ts\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\n\ninterface Book {\n  title: string\n  author: string\n  year: number\n}\n\nexport default defineComponent({\n  props: {\n    book: {\n      // 提供相对 `Object` 更确定的类型\n      type: Object as PropType<Book>,\n      required: true\n    },\n    // 也可以标记函数\n    callback: Function as PropType<(id: number) => void>\n  },\n  mounted() {\n    this.book.title // string\n    this.book.year // number\n\n    // TS Error: argument of type 'string' is not\n    // assignable to parameter of type 'number'\n    this.callback?.('123')\n  }\n})\n```\n\n### 注意事项 {#caveats}\n\n如果你的 TypeScript 版本低于 `4.7`，在使用函数作为 prop 的 `validator` 和 `default` 选项值时需要格外小心——确保使用箭头函数：\n\n```ts\nimport { defineComponent } from 'vue'\nimport type { PropType } from 'vue'\n\ninterface Book {\n  title: string\n  year?: number\n}\n\nexport default defineComponent({\n  props: {\n    bookA: {\n      type: Object as PropType<Book>,\n      // 如果你的 TypeScript 版本低于 4.7，确保使用箭头函数\n      default: () => ({\n        title: 'Arrow Function Expression'\n      }),\n      validator: (book: Book) => !!book.title\n    }\n  }\n})\n```\n\n这会防止 TypeScript 将 `this` 根据函数内的环境作出不符合我们期望的类型推导。这是之前版本的一个[设计限制](https://github.com/microsoft/TypeScript/issues/38845)，不过现在已经在 [TypeScript 4.7](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#improved-function-inference-in-objects-and-methods) 中解决了。\n\n## 为组件的 emits 标注类型 {#typing-component-emits}\n\n我们可以给 `emits` 选项提供一个对象来声明组件所触发的事件，以及这些事件所期望的参数类型。试图触发未声明的事件会抛出一个类型错误：\n\n```ts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  emits: {\n    addBook(payload: { bookName: string }) {\n      // 执行运行时校验\n      return payload.bookName.length > 0\n    }\n  },\n  methods: {\n    onSubmit() {\n      this.$emit('addBook', {\n        bookName: 123 // 类型错误\n      })\n\n      this.$emit('non-declared-event') // 类型错误\n    }\n  }\n})\n```\n\n## 为计算属性标记类型 {#typing-computed-properties}\n\n计算属性会自动根据其返回值来推导其类型：\n\n```ts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  data() {\n    return {\n      message: 'Hello!'\n    }\n  },\n  computed: {\n    greeting() {\n      return this.message + '!'\n    }\n  },\n  mounted() {\n    this.greeting // 类型：string\n  }\n})\n```\n\n在某些场景中，你可能想要显式地标记出计算属性的类型以确保其实现是正确的：\n\n```ts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  data() {\n    return {\n      message: 'Hello!'\n    }\n  },\n  computed: {\n    // 显式标注返回类型\n    greeting(): string {\n      return this.message + '!'\n    },\n\n    // 标注一个可写的计算属性\n    greetingUppercased: {\n      get(): string {\n        return this.greeting.toUpperCase()\n      },\n      set(newValue: string) {\n        this.message = newValue.toUpperCase()\n      }\n    }\n  }\n})\n```\n\n在某些 TypeScript 因循环引用而无法推导类型的情况下，可能必须进行显式的类型标注。\n\n## 为事件处理函数标注类型 {#typing-event-handlers}\n\n在处理原生 DOM 事件时，应该为我们传递给事件处理函数的参数正确地标注类型。让我们看一下这个例子：\n\n```vue\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  methods: {\n    handleChange(event) {\n      // `event` 隐式地标注为 `any` 类型\n      console.log(event.target.value)\n    }\n  }\n})\n</script>\n\n<template>\n  <input type=\"text\" @change=\"handleChange\" />\n</template>\n```\n\n没有类型标注时，这个 `event` 参数会隐式地标注为 `any` 类型。这也会在 `tsconfig.json` 中配置了 `\"strict\": true` 或 `\"noImplicitAny\": true` 时抛出一个 TS 错误。因此，建议显式地为事件处理函数的参数标注类型。此外，在访问 `event` 上的属性时你可能需要使用类型断言：\n\n```ts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  methods: {\n    handleChange(event: Event) {\n      console.log((event.target as HTMLInputElement).value)\n    }\n  }\n})\n```\n\n## 扩展全局属性 {#augmenting-global-properties}\n\n某些插件会通过 [`app.config.globalProperties`](/api/application#app-config-globalproperties) 为所有组件都安装全局可用的属性。举例来说，我们可能为了请求数据而安装了 `this.$http`，或者为了国际化而安装了 `this.$translate`。为了使 TypeScript 更好地支持这个行为，Vue 暴露了一个被设计为可以通过 [TypeScript 模块扩展](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation)来扩展的 `ComponentCustomProperties` 接口：\n\n```ts\nimport axios from 'axios'\n\ndeclare module 'vue' {\n  interface ComponentCustomProperties {\n    $http: typeof axios\n    $translate: (key: string) => string\n  }\n}\n```\n\n参考：\n\n- [对组件类型扩展的 TypeScript 单元测试](https://github.com/vuejs/core/blob/main/packages-private/dts-test/componentTypeExtensions.test-d.tsx)\n\n### 类型扩展的位置 {#type-augmentation-placement}\n\n我们可以将这些类型扩展放在一个 `.ts` 文件，或是一个影响整个项目的 `*.d.ts` 文件中。无论哪一种，都应确保在 `tsconfig.json` 中包括了此文件。对于库或插件作者，这个文件应该在 `package.json` 的 `types` 属性中被列出。\n\n为了利用模块扩展的优势，你需要确保将扩展的模块放在 [TypeScript 模块](https://www.typescriptlang.org/docs/handbook/modules.html) 中。 也就是说，该文件需要包含至少一个顶级的 `import` 或 `export`，即使它只是 `export {}`。如果扩展被放在模块之外，它将覆盖原始类型，而不是扩展!\n\n```ts\n// 不工作，将覆盖原始类型。\ndeclare module 'vue' {\n  interface ComponentCustomProperties {\n    $translate: (key: string) => string\n  }\n}\n```\n\n```ts\n// 正常工作。\nexport {}\n\ndeclare module 'vue' {\n  interface ComponentCustomProperties {\n    $translate: (key: string) => string\n  }\n}\n```\n\n## 扩展自定义选项 {#augmenting-custom-options}\n\n某些插件，比如 `vue-router`，提供了一些自定义的组件选项，比如 `beforeRouteEnter`：\n\n```ts\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n  beforeRouteEnter(to, from, next) {\n    // ...\n  }\n})\n```\n\n如果没有确切的类型标注，这个钩子函数的参数会隐式地标注为 `any` 类型。我们可以为 `ComponentCustomOptions` 接口扩展自定义的选项来支持：\n\n```ts\nimport { Route } from 'vue-router'\n\ndeclare module 'vue' {\n  interface ComponentCustomOptions {\n    beforeRouteEnter?(to: Route, from: Route, next: () => void): void\n  }\n}\n```\n\n现在这个 `beforeRouteEnter` 选项会被准确地标注类型。注意这只是一个例子——像 `vue-router` 这种类型完备的库应该在它们自己的类型定义中自动执行这些扩展。\n\n这种类型扩展和全局属性扩展受到[相同的限制](#type-augmentation-placement)。\n\n参考：\n\n- [对组件类型扩展的 TypeScript 单元测试](https://github.com/vuejs/core/blob/main/packages-private/dts-test/componentTypeExtensions.test-d.tsx)\n\n<!-- zhlint disabled -->\n\n## Typing Global Custom Directives {#typing-global-custom-directives}\n\nSee: [Typing Custom Global Directives](/guide/typescript/composition-api#typing-global-custom-directives) <sup class=\"vt-badge ts\" />\n\n\n\n================================================\nFILE: src/guide/typescript/overview.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/partners/[partnerId].md\n================================================\n---\npage: true\nfooter: false\n---\n\n<script setup>\nimport { useData } from 'vitepress'\nimport Page from './components/PartnerPage.vue'\n\nconst { page } = useData()\n</script>\n\n<Page :partner=\"page.params.partnerId\" />\n\n\n\n================================================\nFILE: src/partners/[partnerId].paths.ts\n================================================\nimport partners from './partners.json'\nimport { normalizeName } from './components/utils'\n\nexport default {\n  paths: partners.map((p) => {\n    return {\n      params: {\n        partnerId: normalizeName(p.name)\n      }\n    }\n  })\n}\n\n\n\n================================================\nFILE: src/partners/all.md\n================================================\n---\npage: true\nfooter: false\n---\n\n<script setup>\nimport PartnerAll from './components/PartnerAll.vue'\n</script>\n\n<PartnerAll />\n\n\n\n================================================\nFILE: src/partners/index.md\n================================================\n---\npage: true\nfooter: false\ntitle: Vue Partners\n---\n\n<script setup>\nimport PartnerLanding from './components/PartnerLanding.vue'\n</script>\n\n<PartnerLanding />\n\n\n\n================================================\nFILE: src/partners/partners.json\n================================================\n[\n  {\n    \"name\": \"Vehikl\",\n    \"logo\": \"vehikl.svg\",\n    \"flipLogo\": true,\n    \"intro\": \"Vehikl has deep knowledge of Vue and will act as an extension of your team. We focus on writing clean, maintainable code. We are passionate about continual improvement, and we practice Mob Programming and Pair Programming on a daily basis.\",\n    \"description\": [\n      \"Vehikl is a Team that values Caring, Growing, and Delivering. We instill those values in everything we do, and everyone we work with. Our goal is to be an extension of your development efforts, and build exceptional web and mobile applications.\",\n      \"Our Team has a strong specialty and deep knowledge of Vue, Laravel, and React frameworks. In addition to this, our Team of 75 has worked with every tech stack you can imagine. We’re proud test-driven developers who focus on writing clean, maintainable code. Our Team is passionate about continual improvement, and we practice Mob Programming and Pair Programming on a daily basis.\",\n      \"We’ve worked on projects from a wide range of companies ranging from startups to enterprise-level organizations. We are one team with our clients and we share in their successes.\",\n      \"So what does working with us look like?\",\n      \"- Daily communication with your team\",\n      \"- Collaborate with you on weekly or bi-weekly Sprint Planning\",\n      \"- Demos & Retrospectives at the end of each Sprint\",\n      \"- Collaborative PR reviews\",\n      \"- Daily Pairing and Mobbing sessions\",\n      \"We’re always looking for opportunities to learn new things and refine our skills using lean Agile development, open communication, and collaboration. We combine one-on-one communication, and the iterative values of the Agile methodology to deliver high quality code.\",\n      \"We’re active members of the JavaScript and PHP community, and love to collaborate with other enthusiasts.\"\n    ],\n    \"proficiencies\": [\"Vue\", \"Laravel\", \"React\", \"Node.js\", \"Unity\"],\n    \"region\": [\"North America\"],\n    \"location\": [\"Ontario, Canada\"],\n    \"website\": {\n      \"text\": \"www.vehikl.com\",\n      \"url\": \"https://www.vehikl.com?utm_source=vue_partners_page\"\n    },\n    \"contact\": \"go+vuepartner@vehikl.com\",\n    \"hiring\": \"https://vehikl.com/jobs/developer/\",\n    \"platinum\": true\n  },\n  {\n    \"name\": \"Passionate People\",\n    \"logo\": \"passionatepeople.png\",\n    \"flipLogo\": true,\n    \"intro\": \"We provide you with additional technical capacity to power-up your digital transformation journeys with our teams of first-class engineers and consultants. Full stack JavaScript Cloud Engineers ready to work with you and your teams.\",\n    \"description\": [\n      \"Founded in October 2017, Passionate People is the leading JavaScript consultancy in the Netherlands.\",\n      \"Our aim is to help our customers speed up their digital transformation initiatives at scale, and our standard is the highest in the sector.\",\n      \"We have a wide client base spanning industries such as FinTech, E-commerce, Logistics, Supply Chain, Industrial Automation, etc. To achieve their digital goals and to make their products scalable and secure for millions of users, companies such as Albert Heijn Digital, GrandVision, Nationale Nederlanden, Talpa and AKQA have trusted us to deliver top-notch work.\",\n      \"Besides being the leading JavaScript Consultancy in the Netherlands, Passionate People is also proud to host the largest tech conferences and community events in the world.\",\n      \"Starting in February 2018 with Frontend Love and Vue.js Amsterdam, we are now responsible for many other conferences in Europe under the Frontend Love brand: React Live, AngularNL, Vue.js Amsterdam, and JS World Conference.\"\n    ],\n    \"proficiencies\": [\"Vue\", \"Nuxt\", \"Node.js\", \"JAMStack\"],\n    \"region\": [\"Europe\"],\n    \"location\": [\"Amsterdam, Netherlands\"],\n    \"website\": {\n      \"text\": \"passionatepeople.io\",\n      \"url\": \"https://passionatepeople.io/\"\n    },\n    \"contact\": \"info@passionatepeople.io\",\n    \"platinum\": true\n  },\n  {\n    \"name\": \"Monterail\",\n    \"logo\": \"monterail.png\",\n    \"hero\": \"monterail-hero.png\",\n    \"flipLogo\": true,\n    \"intro\": \"Monterail is a full-service software development company from Poland. Since 2010, we have been building innovative software for start-ups, SMBs, and enterprises from various industries globally. Our Vue experts, using battle-tested technologies and frameworks, have delivered more than 30 Vue-based projects.\",\n    \"description\": [\n      \"At a full-service consultancy like Monterail, you get every competence under one roof. From concept, to design, and product release. Depending on the product lifecycle stage, we guide clients through building applications from scratch or scaling them quickly.\",\n      \"A diverse pool of experts, including Product Designers, QA specialists and Business Analysts, take care of professional tech stack consultation and business idea validation. We work within the Agile methodology ensuring smooth communication flow and aim for long-term partnerships. We've developed all kinds of Vue applications from virtual real estate tours to donation platforms.\",\n      \"Why Monterail?\",\n      \"- Listed in the Financial Times 1000 rank twice in a row (2018 & 2019)\",\n      \"- Recognized by Deloitte as one of the fastest-growing tech companies in Central Europe (2016 & 2017)\",\n      \"- Rated 4.7/5 on Clutch.\",\n      \"- NPS Score - 71\",\n      \"- Experts in software development and design with solid business experience\",\n      \"- A team experienced with remote work in a multicultural environment\",\n      \"- Detailed budget estimation received in weeks, not months\"\n    ],\n    \"proficiencies\": [\n      \"Vue.js\",\n      \"Ruby on Rails\",\n      \"Node.js\",\n      \"React Native\",\n      \"Flutter\"\n    ],\n    \"region\": [\"Europe\"],\n    \"website\": {\n      \"text\": \"www.monterail.com\",\n      \"url\": \"https://www.monterail.com/services/vue-js-development?utm_source=partnership&utm_medium=logo&utm_campaign=Vue\"\n    },\n    \"contact\": \"hello@monterail.com\",\n    \"hiring\": \"https://www.monterail.com/careers?utm_source=vuejs.org&utm_medium=referral&utm_campaign=partner-hiring-link\",\n    \"platinum\": true\n  },\n  {\n    \"name\": \"Curotec\",\n    \"logo\": \"curotec.png\",\n    \"intro\": \"Work with a team that understands Vue.js inside and out. SaaS and enterprise teams leverage Curotec for best-in-class project execution and staff augmentation services focused on Vue.js.\",\n    \"description\": [\n      \"Whether you need a firm to build your idea, support an existing codebase, or augment your front-end dev team, we’ve got you covered. SaaS and enterprise product teams turn to Curotec for a firm that can get the job done right.\",\n      \"We've got an all-shores model with team members in the US, LATAM, and South Asia. We'll create a flexible engagement for your needs aligned with your budget, timezone, and project goals. We also cover three main focus areas which include:\",\n      \"- Enterprise software development\",\n      \"- SaaS product development\",\n      \"- Headless / Jamstack website development\",\n      \"If you're looking for a Vue.js-focused front-end development team that writes great quality code and gets stuff done, click the contact button below and get in touch!\"\n    ],\n    \"region\": [\"North America\", \"Latin America\"],\n    \"proficiencies\": [\n      \"Vue.js\",\n      \"Nuxt\",\n      \"Laravel\",\n      \"Headless\",\n      \"Node.js\",\n      \"Python\",\n      \"WordPress\"\n    ],\n    \"website\": {\n      \"text\": \"www.curotec.com\",\n      \"url\": \"https://www.curotec.com/services/technologies/vuejs/\"\n    },\n    \"contact\": \"sales@curotec.com\",\n    \"hiring\": \"https://www.curotec.com/careers?source=vuejs-partner\",\n    \"platinum\": true\n  },\n  {\n    \"name\": \"Redberry\",\n    \"logo\": \"redberry.png\",\n    \"intro\": \"We are the 100+ award-winning Vue and Laravel development agency you couldn't afford at home. But we are based in Georgia, the country. So you can.\",\n    \"description\": [\n      \"We’re Redberry — an official Vue Partner agency, based in Tbilisi, Georgia. We’re a 200-person team that’s shipped 300+ products across the EU, UK, US, and the Middle East. Founded in 2014 by four friends to build reliable, scalable software, we still live that mission—now at scale, with Vue at the heart of our front end.\",\n      \"We choose the best option for your product: Nuxt when search visibility and first-load speed matter most, and Inertia + Vue when you want to move quickly on a Laravel backend. Either way, you get a fast, SEO-friendly interface that feels instant. We also set up a reusable design system so new features ship in days, stay on-brand, and remain easy to maintain. If your users need live data or work with spotty connectivity, we design for real-time updates and offline use.\",\n      \"Every engagement starts with clarity—goals, users, constraints. In Discovery & Planning, we align on architecture, roadmap, backlog, and risks. Then we run dual-track delivery (design and engineering in parallel) so learning feeds building without slowing momentum.\",\n      \"Our engineering playbook de-risks delivery. Each task starts on a feature branch off main, and we keep main in a releasable state. Changes move through a structured pipeline—Local → Development → Staging → Prerelease → Production—with automated CI/CD, review gates, and client validation in prerelease, so you see progress early and handoffs are clean. We bake in quality from day one: strict code standards, automated tests, measurable performance and accessibility targets, and clear API contracts. After launch, we monitor and trace real usage, fix issues before customers notice, and use data to guide what we improve next.\",\n      \"How we work:\",\n      \"Staff Augmentation — embed our Vue engineers into your team.\",\n      \"Managed Projects — we own delivery end-to-end (discovery → build → launch → evolve).\",\n      \"Stuck product? We specialize in rescue projects—stabilizing codebases and accelerating delivery. First we audit, then prioritize and fix.\",\n      \"We typically pair Vue with a robust Laravel backend (we’re one of only 8 diamond-tier Laravel Partners worldwide), and being based in Georgia (the country) lets us deliver top-tier engineering with unbeatable value for price.\"\n    ],\n    \"region\": [\"Europe\"],\n    \"proficiencies\": [\n      \"Vue\",\n      \"Laravel\",\n      \"Node.js\",\n      \"React\",\n      \"React Native\"\n    ],\n    \"website\": {\n      \"text\": \"redberry.international\",\n      \"url\": \"https://redberry.international?utm_source=vuepartners&utm_campaign=partners_page\"\n    },\n    \"contact\": \"nini.doggo@redberry.ge\"\n  },\n  {\n    \"name\": \"WebReinvent\",\n    \"logo\": \"webreinvent.png\",\n    \"intro\": \"WebReinvent is a software development company that provides a range of end-to-end software products, real-time apps, multi-tenant SaaS applications, low latency API & mobile app development services. We have delivered MVP to enterprise-level software globally from startup to MNC. Email us, and let's build your software product.\",\n    \"description\": [\n      \"WebReinvent is a process-oriented software development company that provides a range of end-to-end software products, real-time apps, multi-tenant SaaS applications, low latency API & mobile apps development services. Our team is well versed with VueJs and its ecosystem. We have delivered MVP to enterprise-level software from startup to MNC. Not only client projects we have developed multiple open-source products which are based on VueJs. We are proud to mention that we are one of the few official Laravel & Nuxt partners too.\",\n      \"Our team loves to follow the industry standards, some of which are managing git repo, code review, release deployments via CI/CD (DevOps), automated software testing, maintaining detailed technical documentation, application performance monitoring, etc.\",\n      \"Email us, and let's build your software product.\"\n    ],\n    \"region\": [\"North America\", \"Asia\", \"Europe\"],\n    \"proficiencies\": [\"Vue\", \"Laravel\", \"Nuxt\", \"Ionic\", \"Node.js\"],\n    \"website\": {\n      \"text\": \"webreinvent.com\",\n      \"url\": \"https://webreinvent.com/?utm_source=vuejs.org&utm_medium=website&utm_campaign=partners\"\n    },\n    \"contact\": \"we@webreinvent.com\",\n    \"hiring\": \"https://webreinvent.com/career?utm_source=vuejs.org&utm_medium=website&utm_campaign=partner-hiring-link\"\n  },\n  {\n    \"name\": \"HeroDevs\",\n    \"logo\": \"herodevs.png\",\n    \"flipLogo\": true,\n    \"hero\": \"herodevs-hero.png\",\n    \"intro\": \"End-of-life of open source software versions creates massive challenges for companies. HeroDevs offers two solutions: (1) We provide never-ending support for sunsetted open source software, and (2)  we provide consulting and engineering to help companies migrate to in-support open source software.\",\n    \"description\": [\n      \"When open source software is reaching end-of-life, you’re faced with a difficult decision: do you spend months or years of dev time migrating your code, or do you risk being non-compliant with industry regulations and your company’s SLAs?\",\n      \"At HeroDevs we pride ourselves in being the experts that help you navigate end-of-life events in your technology stack. Companies offering enterprise support for open source libraries stop at the end of life. That’s where our value prop begins with our Never-Ending Support (NES) products. Our team has not only provided over 450 organizations with supported, secured versions of open source software beyond their end of life, but has also helped dozens of companies migrate their codebase to a modern, supported open source stack.\",\n      \"With all NES Products we offer: continuous source code scanning for vulnerabilities, 5-minute installation without leaving your network, scanning for possible IP infringement in your code, and checks for platform, browser and 3rd-party library compatibility.\",\n      \"Need to migrate? HeroDevs can help with that too. Hire our team of experts to help you navigate the challenges that come with migrating your code.\",\n      \"Want to learn more? Find us at herodevs.com or send us a note at hello@herodevs.com.\"\n    ],\n    \"proficiencies\": [\"Vue\", \"Angular\", \"Migration\", \"EOL Support\"],\n    \"region\": [\"North America\"],\n    \"website\": {\n      \"text\": \"herodevs.com\",\n      \"url\": \"https://www.herodevs.com/support/vue\"\n    },\n    \"platinum\": true,\n    \"contact\": \"hello@herodevs.com\",\n    \"hiring\": \"https://www.herodevs.com/job-board\"\n  },\n  {\n    \"name\": \"Proxify\",\n    \"logo\": \"proxify.svg\",\n    \"flipLogo\": true,\n    \"intro\": \"With Proxify, you can hire expert Vue.js developers, at a fair price and with zero risk, in just a few days. The quality and commitment of an in-house team, with the flexibility of contractors. Augment your existing team or build a new one, without the risks and admin of permanent employment.\",\n    \"description\": [\n      \"Proxify is an end-to-end partner that connects businesses with thoroughly vetted developers, matching you with perfect-fit developers in just two days.\",\n      \"Our network includes over 4,000 developers with expertise in 500+ tech skills. We accept only 2% of applicants to ensure the highest quality standards. Thousands of businesses worldwide trust our rigorous selection process.\",\n      \"- <b>Time-to-hire</b>: Ideal candidates are presented within just two days.\",\n      \"- <b>A core team member, not just a freelancer</b>: Proxify developers deliver quality on business-critical code and fit seamlessly with your team’s culture. No different to your in-house staff.\",\n      \"- <b>Fair pricing</b>: Our model of working with top-tier talent remotely across the world is both cost-effective for our clients, and lucrative for our developers. Everybody wins.\",\n      \"- <b>Risk-free and adaptable</b>: Enjoy a team that can quickly adjust as your priorities shift, without the risks and limitations of permanent employment.\"\n    ],\n    \"proficiencies\": [\n      \"Vue\",\n      \"Ruby on Rails\",\n      \"Node.js\",\n      \"React Native\",\n      \"Flutter\"\n    ],\n    \"region\": [\"Europe\"],\n    \"location\": [\"Europe\"],\n    \"website\": {\n      \"text\": \"proxify.io\",\n      \"url\": \"https://proxify.io?utm_source=partnership&utm_medium=vuejs&utm_campaign=partners-proxify.html\"\n    },\n    \"contactPage\": \"https://proxify.io/hire-vuejs?utm_source=partnership&utm_medium=vuejs&utm_campaign=partners-proxify.html\",\n    \"hiring\": \"https://career.proxify.io/apply?utm_source=partnership&utm_medium=vuejs&utm_campaign=partners-proxify.html\",\n    \"platinum\": true\n  }\n]\n\n\n\n================================================\nFILE: src/partners/components/PartnerAll.vue\n================================================\n<script setup lang=\"ts\">\nimport { ref } from 'vue'\nimport PartnerHero from './PartnerHero.vue'\nimport PartnerList from './PartnerList.vue'\nimport PartnerJoin from './PartnerJoin.vue'\nimport { Partner } from './type'\nimport { VTIconSearch } from '@vue/theme'\n\nconst query = ref('')\n\nfunction filter(p: Partner): boolean {\n  return (\n    includes(p.name, query.value) ||\n    p.region.some((r) => includes(r, query.value))\n  )\n}\n\nfunction includes(a: string, b: string) {\n  return a.toLowerCase().includes(b.toLowerCase())\n}\n</script>\n\n<template>\n  <PartnerHero title=\"浏览所有合作伙伴\" />\n  <div class=\"container\">\n    <VTIconSearch class=\"icon\" />\n    <input\n      placeholder=\"通过名称或地区搜索合作伙伴\"\n      v-model=\"query\"\n    />\n    <PartnerList :filter=\"filter\" />\n  </div>\n  <PartnerJoin />\n</template>\n\n<style scoped>\ninput {\n  width: 100%;\n  padding: 8px 12px 8px 32px;\n  border-bottom: 1px solid var(--vt-c-divider-light);\n  margin-bottom: 2em;\n}\n\n.container {\n  max-width: 960px;\n  margin: 1em auto 2em;\n  padding: 0 28px;\n  position: relative;\n}\n\n.icon {\n  width: 18px;\n  height: 18px;\n  fill: var(--vt-c-text-3);\n  position: absolute;\n  top: 12px;\n  left: 32px;\n}\n</style>\n\n\n\n================================================\nFILE: src/partners/components/PartnerCard.vue\n================================================\n<script setup lang=\"ts\">\nimport { Partner } from './type'\nimport { normalizeName, getHero, getLogo, track } from './utils'\nimport Location from './PartnerLocation.vue'\n\nconst props = defineProps<{\n  data: Partner\n  hero?: boolean\n  page?: boolean\n}>()\n\nconst {\n  name,\n  intro,\n  region,\n  logo,\n  hero: heroImg,\n  proficiencies,\n  flipLogo,\n  website\n} = props.data\n</script>\n\n<template>\n  <component\n    :is=\"page ? 'div' : 'a'\"\n    class=\"partner-card\"\n    :class=\"{ hero, page, flipLogo }\"\n    :href=\"'/partners/' + normalizeName(name) + '.html'\"\n  >\n    <div class=\"info\">\n      <a :href=\"website.url\" target=\"_blank\" @click=\"track\">\n        <img\n          class=\"logo dark\"\n          v-if=\"hero && flipLogo\"\n          :src=\"getLogo(logo, flipLogo)\"\n        />\n        <img class=\"logo\" v-if=\"hero\" :src=\"getLogo(logo)\" />\n        <h3 v-else>{{ name }}</h3>\n      </a>\n\n      <p class=\"region\"><Location /> {{ region.join(', ') }}</p>\n\n      <p>{{ intro }}</p>\n\n      <h4 v-if=\"hero\">精通的领域</h4>\n      <p v-if=\"hero\">\n        <span class=\"proficiency\" v-for=\"p in proficiencies\">{{ p }}</span>\n      </p>\n    </div>\n    <img class=\"big\" :src=\"getHero(heroImg, name)\" :alt=\"name + ' hero'\" />\n  </component>\n</template>\n\n<style scoped>\n.partner-card {\n  background-color: var(--vt-c-bg);\n  padding: 24px 28px;\n  border-radius: 4px;\n  box-shadow: 0 12px 12px rgba(0, 0, 0, 0.05);\n  display: flex;\n  flex-direction: column;\n  width: 48.5%;\n  margin-bottom: 36px;\n  font-size: 15px;\n  transition: background-color 0.5s, box-shadow 0.25s ease,\n    border-color 0.25s ease;\n}\n\n.partner-card.hero {\n  font-size: 16px;\n  flex-direction: row;\n  width: 100%;\n}\n\n.partner-card.page {\n  padding: 0;\n}\n\nh3 {\n  font-size: 1.3em;\n  font-weight: 700;\n  letter-spacing: -0.1px;\n  margin-bottom: 1em;\n}\n\n.logo {\n  margin-bottom: 1em;\n  max-width: 240px;\n  max-height: 120px;\n}\n\n.logo.dark,\n.dark .flipLogo .logo:not(.dark) {\n  display: none;\n}\n\n.dark .logo.dark {\n  display: inline-block;\n}\n\n.partner-card:not(.hero) .big {\n  margin-top: auto;\n}\n\n.partner-card.hero .info {\n  margin-right: 2em;\n}\n.partner-card.hero .big {\n  display: inline-block;\n  margin-left: auto;\n  max-width: 60%;\n  max-height: 360px;\n  object-fit: cover;\n}\n\n@media (max-width: 768px) {\n  .partner-card {\n    width: 100%;\n  }\n  .partner-card.hero {\n    flex-direction: column;\n  }\n  .logo {\n    max-width: 200px;\n  }\n  .partner-card.hero .big {\n    width: 100%;\n    max-width: 100%;\n  }\n}\n\n.partner-card:hover {\n  box-shadow: 0 12px 12px rgba(0, 0, 0, 0.1);\n}\n\n.partner-card:hover h3 {\n  color: var(--vt-c-green);\n}\n\n.partner-card h3 {\n  transition: color 0.25s ease;\n}\n\n.dark .partner-card,\n.partner-card.page {\n  box-shadow: none !important;\n}\n\n.dark .partner-card:not(.hero) {\n  border: 1px solid var(--vt-c-divider-light);\n}\n\n.dark .partner-card:not(.hero):hover {\n  border-color: #555;\n}\n\n.partner-card h3 {\n  font-size: 1.5em;\n  font-weight: 700;\n  letter-spacing: -0.1px;\n  margin-bottom: 0.4em;\n}\n\n.partner-card p {\n  margin-bottom: 1.6em;\n}\n\n.region {\n  color: var(--vt-c-text-2);\n  font-size: 0.9em;\n}\n\n.region svg {\n  display: inline-block;\n  opacity: 0.5;\n  position: relative;\n  top: -1px;\n  left: -2px;\n}\n\nh4 {\n  font-size: 1.2em;\n  font-weight: 600;\n  margin-bottom: 0.6em;\n}\n\n.proficiency {\n  display: inline-block;\n  color: var(--vt-c-text-code);\n  font-weight: 600;\n  font-size: 0.85em;\n  margin: 2px;\n  background-color: var(--vt-c-bg-mute);\n  padding: 4px 10px;\n  border-radius: 6px;\n}\n</style>\n\n\n\n================================================\nFILE: src/partners/components/PartnerHero.vue\n================================================\n<script setup lang=\"ts\">\nimport PageHero from '@theme/components/PageHero.vue'\n\ndefineProps<{ title?: string }>()\n</script>\n\n<template>\n  <PageHero>\n    <template #title>{{ title || 'Vue 合作伙伴' }}</template>\n    <template #lead>\n      <p >\n        Vue 合作伙伴是 Vue 团队认可提供一流 Vue 咨询和开发服务的机构。如果你的公司有兴趣被列为合作伙伴，请<a href=\"https://airtable.com/shrCQhat57SApJI2l\"\n        target=\"_blank\">在此注册</a>。\n      </p>\n    </template>\n  </PageHero>\n</template>\n\n\n\n================================================\nFILE: src/partners/components/PartnerJoin.vue\n================================================\n<script setup lang=\"ts\">\nimport CallToActionSection from '@theme/components/CallToActionSection.vue'\n</script>\n\n<template>\n  <CallToActionSection\n    title=\"通过 Vue 发展你的业务\"\n    description=\"引领新的项目，赢得客户的信任，并支持 Vue.js 及其生态系统的长期可持续性。\"\n    link=\"https://airtable.com/shrCQhat57SApJI2l\"\n    linkText=\"成为合作伙伴\"\n  />\n</template>\n\n\n\n================================================\nFILE: src/partners/components/PartnerLanding.vue\n================================================\n<script setup lang=\"ts\">\nimport { ref, onMounted } from 'vue'\nimport PartnerHero from './PartnerHero.vue'\nimport PartnerCard from './PartnerCard.vue'\nimport PartnerList from './PartnerList.vue'\nimport PartnerJoin from './PartnerJoin.vue'\nimport PageShowcaseListLayout from '@theme/components/PageShowcaseListLayout.vue'\nimport data from '../partners.json'\nimport { Partner } from './type'\n\nconst spotlighted = ref<Partner | null>(null)\n\nonMounted(() => {\n  const plat = (data as Partner[]).filter((d) => d.platinum)\n  spotlighted.value = plat[Math.floor(Math.random() * plat.length)]\n})\n</script>\n\n<template>\n  <PageShowcaseListLayout\n    spotlightTitle=\"Partner Spotlight\"\n    featuredTitle=\"Featured Partners\"\n    browseLinkText=\"Browse All Partners\"\n    browseLinkUrl=\"./all.html\"\n  >\n    <template #hero>\n      <PartnerHero />\n    </template>\n\n    <template #spotlight>\n      <PartnerCard v-if=\"spotlighted\" hero :data=\"spotlighted\" />\n    </template>\n\n    <template #featured-list>\n      <PartnerList :filter=\"(p) => p.platinum\" showLinkToAll />\n    </template>\n\n    <template #join>\n      <PartnerJoin />\n    </template>\n  </PageShowcaseListLayout>\n</template>\n\n\n\n================================================\nFILE: src/partners/components/PartnerList.vue\n================================================\n<script setup lang=\"ts\">\nimport partnersRaw from '../partners.json'\nimport PartnerCard from './PartnerCard.vue'\nimport { Partner } from './type'\nimport CardList from '@theme/components/CardList.vue'\n\nconst props = defineProps<{\n  filter?: (p: Partner) => boolean | undefined\n  showLinkToAll?: boolean\n}>()\n\n</script>\n\n<template>\n  <CardList\n    :items=\"partnersRaw\"\n    :filter=\"props.filter\"\n    :cardComponent=\"PartnerCard\"\n    :showLinkToAll=\"props.showLinkToAll\"\n    browseLinkText=\"Browse More Developers\"\n    browseLinkUrl=\"./all.html\"\n    shuffleItems\n  />\n</template>\n\n\n\n================================================\nFILE: src/partners/components/PartnerLocation.vue\n================================================\n<template>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    class=\"h-6 w-6\"\n    fill=\"none\"\n    viewBox=\"0 0 24 24\"\n    stroke=\"currentColor\"\n    stroke-width=\"2\"\n    width=\"20\"\n    height=\"20\"\n  >\n    <path\n      stroke-linecap=\"round\"\n      stroke-linejoin=\"round\"\n      d=\"M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z\"\n    />\n    <path\n      stroke-linecap=\"round\"\n      stroke-linejoin=\"round\"\n      d=\"M15 11a3 3 0 11-6 0 3 3 0 016 0z\"\n    />\n  </svg>\n</template>\n\n\n\n================================================\nFILE: src/partners/components/PartnerPage.vue\n================================================\n<script setup lang=\"ts\">\nimport { computed } from 'vue'\nimport data from '../partners.json'\nimport { Partner } from './type'\nimport { normalizeName, track } from './utils'\nimport PartnerCard from './PartnerCard.vue'\nimport { VTIconChevronLeft } from '@vue/theme'\n\nconst props = defineProps<{\n  partner: string\n}>()\n\nconst p = (data as Partner[]).find(\n  (p) => normalizeName(p.name) === props.partner\n)!\n\nconst { name, description, hiring, contact, contactPage, website } = p\n\nconst contactLink = computed(() => {\n  return contact ? `mailto:${contact}?subject=Looking for a Vue.js Partner` : contactPage\n})\n</script>\n\n<template>\n  <div class=\"partner-page\">\n    <div class=\"back\">\n      <a href=\"/partners/all.html\"\n        ><VTIconChevronLeft class=\"icon\" />返回所有合作伙伴</a\n      >\n    </div>\n\n    <PartnerCard hero page :data=\"p\" />\n\n    <div class=\"description\">\n      <h2>About {{ name }}</h2>\n      <p v-for=\"(desc, index) in description\" :key=\"index\" v-html=\"desc\"></p>\n    </div>\n\n    <div class=\"actions\">\n      <a :href=\"website.url\" target=\"_blank\" @click=\"track\"\n        >访问网站</a\n      >\n      <a\n        v-if=\"contact || contactPage\"\n        class=\"contact\"\n        :href=\"contactLink\"\n        target=\"_blank\"\n        @click=\"track\"\n        >联系方式</a\n      >\n    </div>\n\n    <div class=\"hiring\" v-if=\"hiring\">\n      <a :href=\"hiring\" @click=\"track\">{{ name }} 正在招聘中！</a>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.partner-page {\n  max-width: 1080px;\n  margin: 2em auto;\n  padding: 0 28px 64px;\n}\n\n.back {\n  display: block;\n  font-size: 0.9em;\n  font-weight: 600;\n  margin: 24px 0 96px;\n}\n\n.back a {\n  color: var(--vt-c-text-3);\n  transition: color 0.5s;\n}\n\n.back a:hover {\n  color: var(--vt-c-text-2);\n}\n\n.icon {\n  width: 22px;\n  height: 22px;\n  display: inline-block;\n  fill: var(--vt-c-text-3);\n  position: relative;\n  top: -1px;\n  margin-right: 4px;\n}\n\n.description {\n  max-width: 688px;\n  margin: 4em auto;\n}\n\nh2 {\n  font-size: 1.8em;\n  font-weight: 700;\n  margin-top: 96px;\n  margin-bottom: 48px;\n  text-align: center;\n}\n\n.description p {\n  margin-bottom: 1em;\n  font-size: 17px;\n  line-height: 1.6em;\n  color: var(--vt-c-text-2);\n}\n\n.actions {\n  text-align: center;\n  margin-bottom: 24px;\n}\n\n.actions a {\n  text-align: center;\n  background-color: var(--vt-c-brand);\n  color: var(--vt-c-bg);\n  padding: 12px 24px;\n  font-weight: 600;\n  border-radius: 6px;\n  transition: background-color 0.5s, color 0.5s;\n  margin: 0 8px;\n}\n\n.actions a:hover {\n  background-color: var(--vt-c-brand-dark);\n}\n\n.actions a.contact {\n  color: var(--vt-c-text-code);\n  background-color: var(--vt-c-bg-mute);\n}\n\n.actions a.contact:hover {\n  background-color: var(--vt-c-gray-light-4);\n}\n\n.dark .actions a.contact:hover {\n  background-color: var(--vt-c-gray-dark-3);\n}\n\n.hiring {\n  text-align: center;\n}\n\n.hiring a {\n  display: inline-block;\n  font-size: 15px;\n  font-weight: 500;\n  color: var(--vt-c-text-2);\n  border-top: 1px solid var(--vt-c-divider-light);\n  margin-top: 16px;\n  padding-top: 20px;\n}\n\n.hiring a:hover {\n  color: var(--vt-c-green);\n}\n\n@media (max-width: 768px) {\n  .back {\n    margin-bottom: 48px;\n  }\n  h2 {\n    margin-top: 48px;\n  }\n}\n</style>\n\n\n\n================================================\nFILE: src/partners/components/type.ts\n================================================\nexport interface Partner {\n  name: string\n  logo: string\n  hero?: string\n  flipLogo?: boolean\n  intro: string\n  description: string[]\n  proficiencies: string[]\n  region: string[]\n  location: string[]\n  website: {\n    text: string\n    url: string\n  }\n  contact?: string\n  contactPage?: string;\n  hiring?: string\n  platinum?: boolean\n}\n\n\n\n================================================\nFILE: src/partners/components/utils.ts\n================================================\nexport function track() {\n  fathom.trackGoal('TTDUIE6G', 0)\n}\n\nexport function normalizeName(name: string) {\n  return name.toLowerCase().replace(/\\s+/g, '')\n}\n\nexport function getHero(img: string | undefined, name: string) {\n  return `/images/partners/${img || `${normalizeName(name)}-hero.jpg`}`\n}\n\nexport function getLogo(img: string, flip = false) {\n  if (flip) img = img.replace(/(\\.\\w+$)/, '-dark$1')\n  return `/images/partners/${img}`\n}\n\n\n\n================================================\nFILE: src/public/404.html\n================================================\n<h1 id=\"title\"></h1>\n\n<script>\n  if (location.pathname.startsWith('/v2/')) {\n    document.getElementById('title').textContent =\n      '重定向到 v2 文档中...'\n    location.replace(`https://v2.cn.vuejs.org${location.pathname}`)\n  } else {\n    document.getElementById('title').textContent = '404 Not Found'\n  }\n</script>\n\n\n\n================================================\nFILE: src/public/_headers\n================================================\n/*\n  X-Frame-Options: ALLOW-FROM https://staging.certification.vuejs.org https://certification.vuejs.org https://certificates.dev https://staging.certificates.dev https://alemira.com https://*.alemira.com\n  Content-Security-Policy: frame-ancestors https://staging.certification.vuejs.org https://certification.vuejs.org https://certificates.dev https://staging.certificates.dev https://alemira.com https://*.alemira.com\n\n/assets/*\n  cache-control: max-age=31536000\n  cache-control: immutable\n\n\n\n================================================\nFILE: src/public/_redirects\n================================================\n/guide/                   /guide/introduction.html\n/support-vuejs/           /sponsor/\n/ecosystem/partners.html  /partners/\n/resources/*              /ecosystem/:splat\n# From Vue v2 runtime warnings\n/guide/computed.html                https://v2.vuejs.org/v2/guide/computed.html\n/guide/custom-directive.html        https://v2.vuejs.org/v2/guide/custom-directive.html\n/guide/deployment.html              https://v2.vuejs.org/v2/guide/deployment.html\n/guide/list.html                    https://v2.vuejs.org/v2/guide/list.html\n# https://vuejs.org/v2/api/#data\n# /v2/api/                            https://v2.vuejs.org/v2/api/\n# https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties\n# /v2/guide/reactivity.html           https://v2.vuejs.org/v2/guide/reactivity.html\n# https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function\n# /v2/guide/components.html           https://v2.vuejs.org/v2/guide/components.html\n/v2/guide/team.html                 /about/team.html\n/v2/guide/join.html                 /about/community-guide.html\n/v2/examples/                       https://vuejs.org/examples/#markdown\n/v2/examples/commits.html           https://vuejs.org/examples/#fetching-data\n/v2/examples/modal.html             https://vuejs.org/examples/#modal\n/v2/examples/grid-component.html    https://vuejs.org/examples/#grid\n/v2/examples/svg.html               https://vuejs.org/examples/#svg\n/v2/examples/todomvc.html           https://vuejs.org/examples/#todomvc\n/v2/examples/tree-view.html         https://vuejs.org/examples/#tree\n/v2/api/                                            /api/\n/v2/api/index.html                                  /api/\n/v2/guide/                                          /guide/introduction.html\n/v2/guide/index.html                                /guide/introduction.html\n/v2/guide/installation.html                         /guide/quick-start.html\n/v2/guide/instance.html             /guide/essentials/application.html\n/v2/guide/syntax.html               /guide/essentials/template-syntax.html\n/v2/guide/computed.html             /guide/essentials/computed.html\n/v2/guide/class-and-style.html      /guide/essentials/class-and-style.html\n/v2/guide/conditional.html          /guide/essentials/conditional.html\n/v2/guide/list.html                 /guide/essentials/list.html\n/v2/guide/events.html               /guide/essentials/event-handling.html\n/v2/guide/forms.html                /guide/essentials/forms.html\n/v2/guide/components.html           /guide/essentials/component-basics.html\n/v2/guide/components-registration.html                      /guide/components/registration.html\n/v2/guide/components-props.html                             /guide/components/props.html\n/v2/guide/components-custom-events.html                     /guide/components/events.html\n/v2/guide/components-slots.html                             /guide/components/slots.html\n/v2/guide/components-dynamic-async.html                     /guide/built-ins/keep-alive.html\n/v2/guide/transitions.html              /guide/built-ins/transition.html\n/v2/guide/transitioning-state.html      /guide/extras/animation.html\n/v2/guide/custom-directive.html         /guide/reusability/custom-directives.html\n/v2/guide/render-function.html          /guide/extras/render-function.html\n/v2/guide/plugins.html                  /guide/reusability/plugins.html\n/v2/guide/single-file-components.html   /guide/scaling-up/sfc.html\n/v2/guide/testing.html                  /guide/scaling-up/testing.html\n/v2/guide/typescript.html               /guide/typescript/overview.html\n/v2/guide/deployment.html               /guide/best-practices/production-deployment.html\n/v2/guide/routing.html                  /guide/scaling-up/routing.html\n/v2/guide/state-management.html         /guide/scaling-up/state-management.html\n/v2/guide/ssr.html                      /guide/scaling-up/ssr.html\n/v2/guide/security.html                 /guide/best-practices/security.html\n/v2/guide/reactivity.html               /guide/extras/reactivity-in-depth.html\n\n/v2/*                                   https://v2.vuejs.org/v2/:splat?redirect=true    302\n\n# llms\n/llms.md         /llms.txt 200\n/llms-full.md    /llms-full.txt 200\n\n\n\n================================================\nFILE: src/public/CNAME\n================================================\ncn.vuejs.org\n\n\n\n================================================\nFILE: src/public/funding.json\n================================================\n{\n  \"version\": \"v1.0.0\",\n\n  \"entity\": {\n    \"type\": \"organisation\",\n    \"role\": \"owner\",\n    \"name\": \"Vue Technology LLC\",\n    \"email\": \"evan@vuejs.org\",\n    \"phone\": \"\",\n    \"description\": \"Vue Technology LLC is the legal entity representing Vue's business operations and fund distribution to team members\",\n    \"webpageUrl\": {\n      \"url\": \"https://vuejs.org\",\n      \"wellKnown\": \"\"\n    }\n  },\n\n  \"projects\": [\n    {\n      \"guid\": \"vuejs\",\n      \"name\": \"Vue.js\",\n      \"description\": \"Vue.js is one of the most widely adopted frontend frameworks, with over 5.5 million weekly downloads and 2 million weekly active users. It is also the technology powering Zerodha's frontend.\",\n      \"webpageUrl\": {\n        \"url\": \"https://vuejs.org\",\n        \"wellKnown\": \"\"\n      },\n      \"repositoryUrl\": {\n        \"url\": \"https://github.com/vuejs/core\",\n        \"wellKnown\": \"https://github.com/vuejs/core/blob/main/.well-known/funding-manifest-urls\"\n      },\n      \"licenses\": [\"spdx:MIT\"],\n      \"tags\": [\"frontend\", \"javascript\", \"web-development\", \"ui\"]\n    }\n  ],\n\n  \"funding\": {\n    \"channels\": [\n      {\n        \"guid\": \"github-sponsors\",\n        \"type\": \"other\",\n        \"address\": \"https://github.com/sponsors/yyx990803\",\n        \"description\": \"GitHub supports payment via credit card or invoice-based billing.\"\n      },\n      {\n        \"guid\": \"open-collective\",\n        \"type\": \"other\",\n        \"address\": \"https://opencollective.com/vuejs\",\n        \"description\": \"OpenCollective supports payment via credit card, Google Pay, or US bank ACH transfer.\"\n      },\n      {\n        \"guid\": \"bank-of-america\",\n        \"type\": \"bank\",\n        \"address\": \"\",\n        \"description\": \"For donations via bank transfers, please get in touch for bank details.\"\n      }\n    ],\n\n    \"plans\": [\n      {\n        \"guid\": \"special\",\n        \"status\": \"active\",\n        \"name\": \"Global Special Sponsor\",\n        \"description\": \"Exclusive above-the-fold logo placement on vuejs.org home page / Most prominent logo placement in on the right sidebar of every content page on vuejs.org (3M+ page views per month / 500k+ unique MAU) / Most prominent logo placement in the README and BACKERS files of the vuejs/core repo.\",\n        \"amount\": 5000,\n        \"currency\": \"USD\",\n        \"frequency\": \"monthly\",\n        \"channels\": [\n          \"github-sponsors\",\n          \"open-collective\",\n          \"bank-of-america\"\n        ]\n      },\n      {\n        \"guid\": \"platinum\",\n        \"status\": \"active\",\n        \"name\": \"Platinum Sponsor\",\n        \"description\": \"Logo on the right sidebar of every content page on vuejs.org (3M+ page views per month / 500k+ unique MAU) / Large logo placement on vuejs.org front page + sponsors page + in the README and BACKERS files of the vuejs/core repo.\",\n        \"amount\": 2000,\n        \"currency\": \"USD\",\n        \"frequency\": \"monthly\",\n        \"channels\": [\n          \"github-sponsors\",\n          \"open-collective\",\n          \"bank-of-america\"\n        ]\n      },\n      {\n        \"guid\": \"gold\",\n        \"status\": \"active\",\n        \"name\": \"Gold Sponsor\",\n        \"description\": \"Medium logo placement on vuejs.org front page + sponsors page + in the README and BACKERS files of the vuejs/core repo.\",\n        \"amount\": 500,\n        \"currency\": \"USD\",\n        \"frequency\": \"monthly\",\n        \"channels\": [\"github-sponsors\", \"open-collective\"]\n      },\n      {\n        \"guid\": \"silver\",\n        \"status\": \"active\",\n        \"name\": \"Silver Sponsor\",\n        \"description\": \"Small logo placement on vuejs.org sponsors page + in the README and BACKERS files of the vuejs/core repo.\",\n        \"amount\": 250,\n        \"currency\": \"USD\",\n        \"frequency\": \"monthly\",\n        \"channels\": [\"github-sponsors\", \"open-collective\"]\n      },\n      {\n        \"guid\": \"bronze\",\n        \"status\": \"active\",\n        \"name\": \"Bronze Sponsor\",\n        \"description\": \"Small logo placement in the README and BACKERS files of the vuejs/core repo.\",\n        \"amount\": 100,\n        \"currency\": \"USD\",\n        \"frequency\": \"monthly\",\n        \"channels\": [\"github-sponsors\", \"open-collective\"]\n      }\n    ],\n\n    \"history\": []\n  }\n}\n\n\n\n================================================\nFILE: src/public/service-worker.js\n================================================\n// force clearing previous service worker\nself.addEventListener('install', function (e) {\n  self.skipWaiting()\n})\n\nself.addEventListener('activate', function (e) {\n  self.registration\n    .unregister()\n    .then(function () {\n      return self.clients.matchAll()\n    })\n    .then(function (clients) {\n      clients.forEach((client) => client.navigate(client.url))\n    })\n})\n\n\n\n================================================\nFILE: src/sponsor/index.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/style-guide/PLEADE_DO_NOT_TRANSLATE.md\n================================================\n# Please DO NOT Translate\n\nPlease do not translate the style guide docs until further consideration since:\n\n1. The English version still needs to be revamped.\n2. Currently there is no entry link on the doc site.\n\nThanks.\n\nRef: https://github.com/vuejs-translations/docs-zh-cn/pull/237#issuecomment-1148418220\n\n\n\n================================================\nFILE: src/translations/index.md\n================================================\n---\naside: false\n---\n\n# 多语言及翻译 {#translations}\n\n## 多语言版本 {#available-languages}\n\n- [简体中文](https://cn.vuejs.org/) [[源码](https://github.com/vuejs-translations/docs-zh-cn)]\n- [English / 英语](https://vuejs.org/) [[源码](https://github.com/vuejs/docs)]\n- [日本語 / 日语](https://ja.vuejs.org/) [[源码](https://github.com/vuejs-translations/docs-ja)]\n- [Українська / 乌克兰语](https://ua.vuejs.org/) [[源码](https://github.com/vuejs-translations/docs-uk)]\n- [Français / 法语](https://fr.vuejs.org) [[源码](https://github.com/vuejs-translations/docs-fr)]\n- [한국어 / 韩语](https://ko.vuejs.org) [[源码](https://github.com/vuejs-translations/docs-ko)]\n- [Português / 葡萄牙语](https://pt.vuejs.org) [[源码](https://github.com/vuejs-translations/docs-pt)]\n- [বাংলা / 孟加拉语](https://bn.vuejs.org) [[源码](https://github.com/vuejs-translations/docs-bn)]\n- [Italiano / 意大利语](https://it.vuejs.org) [[源码](https://github.com/vuejs-translations/docs-it)]\n- [فارسی / 波斯语](https://fa.vuejs.org) [[source](https://github.com/vuejs-translations/docs-fa)]\n- [Русский / 俄罗斯语](https://ru.vuejs.org/) [[source](https://github.com/vuejs-translations/docs-ru)]\n- [Čeština / 捷克语](https://cs.vuejs.org/) [[source](https://github.com/vuejs-translations/docs-cs)]\n- [繁體中文 / 繁体中文](https://zh-hk.vuejs.org/) [[source](https://github.com/vuejs-translations/docs-zh-hk)]\n- [Polski / 波兰语](https://pl.vuejs.org/) [[source](https://github.com/vuejs-translations/docs-pl)]\n\n## 翻译中的语言 {#work-in-progress-languages}\n\n- [العربية / 阿拉伯语](https://ar.vuejs.org/) [[源码](https://github.com/vuejs-translations/docs-ar)]\n\n- [Español / 西班牙语](https://vue3-spanish-docs.netlify.app/) [[source](https://github.com/icarusgk/vuejs-spanish-docs)]\n\n- [Deutsch / 德语](https://de.vuejs.org/) [[source](https://github.com/vuejs-translations/docs-de)]\n\n## 启动新的翻译 {#starting-a-new-translation}\n\n近期 Vue 的文档经历了一次大的版本升级，所以其他语言的翻译版本仍不可用或进行中。\n\n我们希望通过社区的努力提供更多语言的翻译。这些工作是在 [vuejs-translations](https://github.com/vuejs-translations/) GitHub 组织进行的。如果你对此感兴趣，请查看[翻译指南](https://github.com/vuejs-translations/guidelines/blob/main/README.md)。\n\n\n\n================================================\nFILE: src/tutorial/index.md\n================================================\n---\npage: true\ntitle: 教程\nsidebar: false\naside: false\nfooter: false\nreturnToTop: false\n---\n\n<script>\nimport { defineAsyncComponent } from 'vue'\nimport ReplLoading from '@theme/components/ReplLoading.vue'\n\nexport default {\n  components: {\n    TutorialRepl: defineAsyncComponent({\n      loader: () => import('./TutorialRepl.vue'),\n      loadingComponent: ReplLoading\n    })\n  }\n}\n</script>\n\n<ClientOnly>\n  <TutorialRepl />\n</ClientOnly>\n\n\n\n================================================\nFILE: src/tutorial/tutorial.data.ts\n================================================\nimport path from 'path'\nimport { createMarkdownRenderer } from 'vitepress'\nimport { readExamples, ExampleData } from '../examples/examples.data'\n\nexport declare const data: Record<string, ExampleData>\n\nexport default {\n  watch: './src/**',\n  async load() {\n    const md = await createMarkdownRenderer(process.cwd(), {\n        theme: 'github-dark',\n    }, '/')\n    const files = readExamples(path.resolve(__dirname, './src'))\n    for (const step in files) {\n      const stepFiles = files[step]\n      const desc = stepFiles['description.md'] as string\n      if (desc) {\n        stepFiles['description.md'] = md.render(desc)\n      }\n    }\n    return files\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/TutorialRepl.vue\n================================================\n<script setup lang=\"ts\">\nimport { Repl, useStore, useVueImportMap } from '@vue/repl'\nimport CodeMirror from '@vue/repl/codemirror-editor'\nimport { inject, watch, Ref, ref, computed, nextTick } from 'vue'\nimport { data } from './tutorial.data'\nimport {\n  resolveSFCExample,\n  resolveNoBuildExample,\n  onHashChange\n} from '../examples/utils'\nimport PreferenceSwitch from '@theme/components/PreferenceSwitch.vue'\nimport {\n  VTFlyout,\n  VTIconChevronLeft,\n  VTIconChevronRight,\n  VTLink\n} from '@vue/theme'\n\nconst { vueVersion, defaultVersion, importMap } = useVueImportMap({\n  runtimeDev: () =>\n    `https://unpkg.com/vue@${\n      vueVersion.value || defaultVersion\n    }/dist/vue.esm-browser.js`\n})\nconst store = useStore({\n  builtinImportMap: importMap\n})\n\nconst instruction = ref<HTMLElement>()\n\nconst preferComposition = inject('prefer-composition') as Ref<boolean>\nconst preferSFC = inject('prefer-sfc') as Ref<boolean>\n\nconst currentStep = ref('')\nconst keys = Object.keys(data).sort((a, b) => {\n  return Number(a.replace(/^step-/, '')) - Number(b.replace(/^step-/, ''))\n})\nconst totalSteps = keys.length\n\nconst titleRE = /<h1.*?>(.+?)<a class=\"header-anchor/\nconst allSteps = keys.map((key, i) => {\n  const desc = data[key]['description.md'] as string\n  return {\n    text: `${i + 1}. ${desc.match(titleRE)![1]}`,\n    link: `#${key}`\n  }\n})\n\nconst currentDescription = computed(() => {\n  return data[currentStep.value]?.['description.md']\n})\n\nconst currentStepIndex = computed(() => {\n  return keys.indexOf(currentStep.value) + 1\n})\n\nconst prevStep = computed(() => {\n  const match = currentStep.value.match(/\\d+/)\n  const prev = match && `step-${+match[0] - 1}`\n  if (prev && data.hasOwnProperty(prev)) {\n    return prev\n  }\n})\n\nconst nextStep = computed(() => {\n  const match = currentStep.value.match(/\\d+/)\n  const next = match && `step-${+match[0] + 1}`\n  if (next && data.hasOwnProperty(next)) {\n    return next\n  }\n})\n\nconst showingHint = ref(false)\n\nfunction updateExample(scroll = false) {\n  let hash = location.hash.slice(1)\n  if (!data.hasOwnProperty(hash)) {\n    hash = 'step-1'\n    location.replace(`/tutorial/#${hash}`)\n  }\n  currentStep.value = hash\n\n  const content = showingHint.value ? data[hash]._hint! : data[hash]\n\n  store.setFiles(\n    preferSFC.value\n      ? resolveSFCExample(content, preferComposition.value)\n      : resolveNoBuildExample(content, preferComposition.value),\n    preferSFC.value ? 'App.vue' : 'index.html'\n  )\n\n  if (scroll) {\n    nextTick(() => {\n      instruction.value!.scrollTop = 0\n    })\n  }\n}\n\nfunction toggleResult() {\n  showingHint.value = !showingHint.value\n  updateExample()\n}\n\nwatch([preferComposition, preferSFC], () => updateExample())\n\nonHashChange(() => {\n  showingHint.value = false\n  updateExample(true)\n})\n\nupdateExample()\n</script>\n\n<template>\n  <section class=\"tutorial\">\n    <article class=\"instruction\" ref=\"instruction\">\n      <PreferenceSwitch />\n      <VTFlyout :button=\"`${currentStepIndex} / ${totalSteps}`\">\n        <VTLink\n          v-for=\"(step, i) of allSteps\"\n          class=\"vt-menu-link\"\n          :class=\"{ active: i + 1 === currentStepIndex }\"\n          :href=\"step.link\"\n          >{{ step.text }}</VTLink\n        >\n      </VTFlyout>\n      <div class=\"vt-doc\" v-html=\"currentDescription\"></div>\n      <div class=\"hint\" v-if=\"data[currentStep]?._hint\">\n        <button @click=\"toggleResult\">\n          {{ showingHint ? '重置代码' : '看答案！' }}\n        </button>\n      </div>\n      <footer>\n        <a v-if=\"prevStep\" :href=\"`#${prevStep}`\"\n          ><VTIconChevronLeft class=\"vt-link-icon\" style=\"margin: 0\" />\n          上一步</a\n        >\n        <a class=\"next-step\" v-if=\"nextStep\" :href=\"`#${nextStep}`\"\n          >下一步 <VTIconChevronRight class=\"vt-link-icon\"\n        /></a>\n      </footer>\n    </article>\n    <Repl\n      layout=\"vertical\"\n      :editor=\"CodeMirror\"\n      :store=\"store\"\n      :showCompileOutput=\"false\"\n      :clearConsole=\"false\"\n      :showImportMap=\"false\"\n      @keyup=\"showingHint = false\"\n    />\n  </section>\n</template>\n\n<style scoped>\n.tutorial {\n  display: flex;\n  max-width: 1440px;\n  margin: 0 auto;\n  --height: calc(\n    100vh - var(--vt-nav-height) - var(--vt-banner-height, 0px)\n  );\n}\n\n.preference-switch {\n  position: relative;\n}\n\n.instruction {\n  width: 45%;\n  height: var(--height);\n  padding: 0 32px 24px;\n  border-right: 1px solid var(--vt-c-divider-light);\n  font-size: 15px;\n  overflow-y: auto;\n  position: relative;\n  --vt-nav-height: 40px;\n}\n\n.vue-repl {\n  width: 55%;\n  height: var(--height);\n}\n\n.vt-flyout {\n  z-index: 9;\n  position: absolute;\n  right: 20px;\n}\n\n.vt-menu-link.active {\n  font-weight: 500;\n  color: var(--vt-c-brand);\n}\n\nfooter {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  border-top: 1px solid var(--vt-c-divider);\n  margin-top: 1.5em;\n  padding-top: 1em;\n}\n\nfooter a {\n  font-weight: 500;\n  color: var(--vt-c-brand);\n}\n\n.next-step {\n  margin-left: auto;\n}\n\n.vt-doc :deep(h1) {\n  font-size: 1.4em;\n  margin: 1em 0;\n}\n\n.vt-doc :deep(h2) {\n  font-size: 1.1em;\n  margin: 1.2em 0 0.5em;\n  padding: 0;\n  border-top: none;\n}\n\n.vt-doc :deep(.header-anchor) {\n  display: none;\n}\n\n.vt-doc :deep(summary) {\n  cursor: pointer;\n}\n\n.hint {\n  padding-top: 1em;\n}\n\nbutton {\n  background-color: var(--vt-c-brand);\n  color: var(--vt-c-bg);\n  padding: 4px 12px 3px;\n  border-radius: 8px;\n  font-weight: 600;\n  font-size: 14px;\n}\n\n@media (min-width: 1377px) {\n  .vue-repl {\n    border-right: 1px solid var(--vt-c-divider-light);\n  }\n}\n\n@media (min-width: 1441px) {\n  .tutorial {\n    padding-right: 32px;\n  }\n}\n\n:deep(.narrow) {\n  display: none;\n}\n\n@media (max-width: 720px) {\n  .tutorial {\n    display: block;\n  }\n  .instruction {\n    width: 100%;\n    border-right: none;\n    border-bottom: 1px solid var(--vt-c-divider-light);\n    height: 30vh;\n    padding: 0 24px 24px;\n  }\n  .vue-repl {\n    width: 100%;\n    height: calc(\n      70vh - var(--vt-nav-height) - var(--vt-banner-height, 0px)\n    );\n  }\n  :deep(.wide) {\n    display: none;\n  }\n  :deep(.narrow) {\n    display: inline;\n  }\n}\n</style>\n\n\n\n================================================\nFILE: src/tutorial/src/step-1/description.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/tutorial/src/step-1/App/template.html\n================================================\n<h1>Hello World!</h1>\n\n\n\n================================================\nFILE: src/tutorial/src/step-10/description.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/tutorial/src/step-10/_hint/App/composition.js\n================================================\nimport { ref, watch } from 'vue'\n\nexport default {\n  setup() {\n    const todoId = ref(1)\n    const todoData = ref(null)\n\n    async function fetchData() {\n      todoData.value = null\n      const res = await fetch(\n        `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n      )\n      todoData.value = await res.json()\n    }\n\n    fetchData()\n\n    watch(todoId, fetchData)\n\n    return {\n      todoId,\n      todoData\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-10/_hint/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      todoId: 1,\n      todoData: null\n    }\n  },\n  methods: {\n    async fetchData() {\n      this.todoData = null\n      const res = await fetch(\n        `https://jsonplaceholder.typicode.com/todos/${this.todoId}`\n      )\n      this.todoData = await res.json()\n    }\n  },\n  mounted() {\n    this.fetchData()\n  },\n  watch: {\n    todoId() {\n      this.fetchData()\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-10/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const todoId = ref(1)\n    const todoData = ref(null)\n\n    async function fetchData() {\n      todoData.value = null\n      const res = await fetch(\n        `https://jsonplaceholder.typicode.com/todos/${todoId.value}`\n      )\n      todoData.value = await res.json()\n    }\n\n    fetchData()\n\n    return {\n      todoId,\n      todoData\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-10/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      todoId: 1,\n      todoData: null\n    }\n  },\n  methods: {\n    async fetchData() {\n      this.todoData = null\n      const res = await fetch(\n        `https://jsonplaceholder.typicode.com/todos/${this.todoId}`\n      )\n      this.todoData = await res.json()\n    }\n  },\n  mounted() {\n    this.fetchData()\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-10/App/template.html\n================================================\n<p>Todo id: {{ todoId }}</p>\n<button @click=\"todoId++\" :disabled=\"!todoData\">Fetch next todo</button>\n<p v-if=\"!todoData\">Loading...</p>\n<pre v-else>{{ todoData }}</pre>\n\n\n\n================================================\nFILE: src/tutorial/src/step-11/description.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/tutorial/src/step-11/_hint/App/composition.js\n================================================\nimport ChildComp from './ChildComp.vue'\n\nexport default {\n  components: {\n    ChildComp\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-11/_hint/App/options.js\n================================================\nimport ChildComp from './ChildComp.vue'\n\nexport default {\n  components: {\n    ChildComp\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-11/_hint/App/template.html\n================================================\n<ChildComp />\n\n\n\n================================================\nFILE: src/tutorial/src/step-11/App/composition.js\n================================================\nexport default {\n  // 注册子组件\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-11/App/options.js\n================================================\nexport default {\n  // 注册子组件\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-11/App/template.html\n================================================\n<!-- render child component -->\n\n\n\n================================================\nFILE: src/tutorial/src/step-11/ChildComp/template.html\n================================================\n<h2>A Child Component!</h2>\n\n\n\n================================================\nFILE: src/tutorial/src/step-12/description.md\n================================================\n# Props {#props}\n\n子组件可以通过 **props** 从父组件接受动态数据。首先，需要声明它所接受的 props：\n\n<div class=\"composition-api\">\n<div class=\"sfc\">\n\n```vue [ChildComp.vue]\n<script setup>\nconst props = defineProps({\n  msg: String\n})\n</script>\n```\n\n注意 `defineProps()` 是一个编译时宏，并不需要导入。一旦声明，`msg` prop 就可以在子组件的模板中使用。它也可以通过 `defineProps()` 所返回的对象在 JavaScript 中访问。\n\n</div>\n\n<div class=\"html\">\n\n```js\n// 在子组件中\nexport default {\n  props: {\n    msg: String\n  },\n  setup(props) {\n    // 访问 props.msg\n  }\n}\n```\n\n一旦声明，`msg` prop 就会暴露在 `this` 上，并可以在子组件的模板中使用。接收到的 props 会作为第一个参数传递给 `setup()`。\n\n</div>\n\n</div>\n\n<div class=\"options-api\">\n\n```js\n// 在子组件中\nexport default {\n  props: {\n    msg: String\n  }\n}\n```\n\n一旦声明，`msg` prop 就会暴露在 `this` 上，并可以在子组件的模板中使用。\n\n</div>\n\n父组件可以像声明 HTML attributes 一样传递 props。若要传递动态值，也可以使用 `v-bind` 语法：\n\n<div class=\"sfc\">\n\n```vue-html\n<ChildComp :msg=\"greeting\" />\n```\n\n</div>\n<div class=\"html\">\n\n```vue-html\n<child-comp :msg=\"greeting\"></child-comp>\n```\n\n</div>\n\n现在在编辑器中自己尝试一下吧。\n\n\n\n================================================\nFILE: src/tutorial/src/step-12/_hint/App/template.html\n================================================\n<ChildComp :msg=\"greeting\" />\n\n\n\n================================================\nFILE: src/tutorial/src/step-12/App/composition.js\n================================================\nimport { ref } from 'vue'\nimport ChildComp from './ChildComp.vue'\n\nexport default {\n  components: {\n    ChildComp\n  },\n  setup() {\n    const greeting = ref('Hello from parent')\n\n    return {\n      greeting\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-12/App/options.js\n================================================\nimport ChildComp from './ChildComp.vue'\n\nexport default {\n  components: {\n    ChildComp\n  },\n  data() {\n    return {\n      greeting: 'Hello from parent'\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-12/App/template.html\n================================================\n<ChildComp />\n\n\n\n================================================\nFILE: src/tutorial/src/step-12/ChildComp/composition.js\n================================================\nexport default {\n  props: {\n    msg: String\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-12/ChildComp/options.js\n================================================\nexport default {\n  props: {\n    msg: String\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-12/ChildComp/template.html\n================================================\n<h2>{{ msg || 'No props passed yet' }}</h2>\n\n\n\n================================================\nFILE: src/tutorial/src/step-13/description.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/tutorial/src/step-13/_hint/App/template.html\n================================================\n<ChildComp @response=\"(msg) => childMsg = msg\" />\n<p>{{ childMsg }}</p>\n\n\n\n================================================\nFILE: src/tutorial/src/step-13/App/composition.js\n================================================\nimport { ref } from 'vue'\nimport ChildComp from './ChildComp.vue'\n\nexport default {\n  components: {\n    ChildComp\n  },\n  setup() {\n    const childMsg = ref('No child msg yet')\n\n    return {\n      childMsg\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-13/App/options.js\n================================================\nimport ChildComp from './ChildComp.vue'\n\nexport default {\n  components: {\n    ChildComp\n  },\n  data() {\n    return {\n      childMsg: 'No child msg yet'\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-13/App/template.html\n================================================\n<ChildComp />\n<p>{{ childMsg }}</p>\n\n\n\n================================================\nFILE: src/tutorial/src/step-13/ChildComp/composition.js\n================================================\nexport default {\n  emits: ['response'],\n  setup(props, { emit }) {\n    emit('response', 'hello from child')\n    return {}\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-13/ChildComp/options.js\n================================================\nexport default {\n  emits: ['response'],\n  created() {\n    this.$emit('response', 'hello from child')\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-13/ChildComp/template.html\n================================================\n<h2>Child component</h2>\n\n\n\n================================================\nFILE: src/tutorial/src/step-14/description.md\n================================================\n# 插槽 {#slots}\n\n除了通过 props 传递数据外，父组件还可以通过**插槽** (slots) 将模板片段传递给子组件：\n\n<div class=\"sfc\">\n\n```vue-html\n<ChildComp>\n  This is some slot content!\n</ChildComp>\n```\n\n</div>\n<div class=\"html\">\n\n```vue-html\n<child-comp>\n  This is some slot content!\n</child-comp>\n```\n\n</div>\n\n在子组件中，可以使用 `<slot>` 元素作为插槽出口 (slot outlet) 渲染父组件中的插槽内容 (slot content)：\n\n<div class=\"sfc\">\n\n```vue-html\n<!-- 在子组件的模板中 -->\n<slot/>\n```\n\n</div>\n<div class=\"html\">\n\n```vue-html\n<!-- 在子组件的模板中 -->\n<slot></slot>\n```\n\n</div>\n\n`<slot>` 插口中的内容将被当作“默认”内容：它会在父组件没有传递任何插槽内容时显示：\n\n```vue-html\n<slot>Fallback content</slot>\n```\n\n现在我们没有给 `<ChildComp>` 传递任何插槽内容，所以你将看到默认内容。让我们利用父组件的 `msg` 状态为子组件提供一些插槽内容吧。\n\n\n\n================================================\nFILE: src/tutorial/src/step-14/_hint/App/template.html\n================================================\n<ChildComp>Message: {{ msg }}</ChildComp>\n\n\n\n================================================\nFILE: src/tutorial/src/step-14/App/composition.js\n================================================\nimport { ref } from 'vue'\nimport ChildComp from './ChildComp.vue'\n\nexport default {\n  components: {\n    ChildComp\n  },\n  setup() {\n    const msg = ref('from parent')\n\n    return {\n      msg\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-14/App/options.js\n================================================\nimport ChildComp from './ChildComp.vue'\n\nexport default {\n  components: {\n    ChildComp\n  },\n  data() {\n    return {\n      msg: 'from parent'\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-14/App/template.html\n================================================\n<ChildComp></ChildComp>\n\n\n\n================================================\nFILE: src/tutorial/src/step-14/ChildComp/template.html\n================================================\n<slot>Fallback content</slot>\n\n\n\n================================================\nFILE: src/tutorial/src/step-15/description.md\n================================================\n# 你做到了！ {#you-did-it}\n\n你已经完成了整个教程！\n\n现在，你应该大致明白使用 Vue 开发应用是怎样的感觉了。虽然我们飞快地介绍了许多东西，但也因此忽略了大量的细节，所以千万别这样就满足了！接下来，你可以：\n\n- 参考[快速上手](/guide/quick-start)，在你的机器上创建一个真实的 Vue 项目。\n\n- 阅读[深入指南](/guide/essentials/application)——它更详细地探讨了我们目前学过的所有话题，并且还有许多其他更深入的内容。\n\n- 查看一些更加实际的[示例](/examples/)。\n\n我们很期待看到你能用 Vue 打造出怎样的作品，加油！\n\n\n\n================================================\nFILE: src/tutorial/src/step-15/import-map.json\n================================================\n{\n  \"imports\": {\n    \"js-confetti\": \"https://cdn.jsdelivr.net/npm/js-confetti/+esm\"\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-15/App/composition.js\n================================================\nimport JSConfetti from 'js-confetti'\n\nconst confetti = new JSConfetti()\n\nexport default {\n  setup() {\n    function showConfetti() {\n      confetti.addConfetti()\n    }\n\n    showConfetti()\n\n    return {\n      showConfetti\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-15/App/options.js\n================================================\nimport JSConfetti from 'js-confetti'\n\nconst confetti = new JSConfetti()\n\nexport default {\n  mounted() {\n    this.showConfetti()\n  },\n  methods: {\n    showConfetti() {\n      confetti.addConfetti()\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-15/App/style.css\n================================================\nh1 {\n  text-align: center;\n  cursor: pointer;\n  margin-top: 3em;\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-15/App/template.html\n================================================\n<h1 @click=\"showConfetti\">🎉 Congratulations!</h1>\n\n\n\n================================================\nFILE: src/tutorial/src/step-2/description.md\n================================================\n# 声明式渲染 {#declarative-rendering}\n\n<div class=\"sfc\">\n\n你在编辑器中看到的是一个 Vue 单文件组件 (Single-File Component，缩写为 SFC)。单文件组件是一种可复用的代码组织形式，它将从属于同一个组件的 HTML、CSS 和 JavaScript 封装在使用 `.vue` 后缀的文件中。\n\n</div>\n\nVue 的核心功能是**声明式渲染**：通过扩展于标准 HTML 的模板语法，我们可以根据 JavaScript 的状态来描述 HTML 应该是什么样子的。当状态改变时，HTML 会自动更新。\n\n<div class=\"composition-api\">\n\n能在改变时触发更新的状态被称作是**响应式**的。我们可以使用 Vue 的 `reactive()` API 来声明响应式状态。由 `reactive()` 创建的对象都是 JavaScript [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，其行为与普通对象一样：\n\n```js\nimport { reactive } from 'vue'\n\nconst counter = reactive({\n  count: 0\n})\n\nconsole.log(counter.count) // 0\ncounter.count++\n```\n\n`reactive()` 只适用于对象 (包括数组和内置类型，如 `Map` 和 `Set`)。而另一个 API `ref()` 则可以接受任何值类型。`ref` 会返回一个包裹对象，并在 `.value` 属性下暴露内部值。\n\n```js\nimport { ref } from 'vue'\n\nconst message = ref('Hello World!')\n\nconsole.log(message.value) // \"Hello World!\"\nmessage.value = 'Changed'\n```\n\n`reactive()` 和 `ref()` 的细节在<a target=\"_blank\" href=\"/guide/essentials/reactivity-fundamentals.html\">指南 - 响应式基础</a>一节中有进一步讨论。\n\n<div class=\"sfc\">\n\n在组件的 `<script setup>` 块中声明的响应式状态，可以直接在模板中使用。下面展示了我们如何使用双花括号语法，根据 `counter` 对象和 `message` ref 的值渲染动态文本：\n\n</div>\n\n<div class=\"html\">\n\n传入 `createApp()` 的对象是一个 Vue 组件。组件的状态应该在 `setup()` 函数中声明，并使用一个对象返回。\n\n```js{2,5}\nsetup() {\n  const counter = reactive({ count: 0 })\n  const message = ref('Hello World!')\n  return {\n    counter,\n    message\n  }\n}\n```\n\n返回对象中的属性可以在模板中使用。下面展示了我们如何使用双花括号语法，根据 `message` 的值来渲染动态文本：\n\n</div>\n\n```vue-html\n<h1>{{ message }}</h1>\n<p>Count is: {{ counter.count }}</p>\n```\n\n注意我们在模板中访问的 `message` ref 时不需要使用 `.value`：它会被自动解包，让使用更简单。\n\n</div>\n\n<div class=\"options-api\">\n\n能在改变时触发更新的状态被认为是**响应式**的。在 Vue 中，响应式状态被保存在组件中。<span class=\"html\">在示例代码中，传递给 `createApp()` 的对象是一个组件。</span>\n\n我们可以使用 `data` 组件选项来声明响应式状态，该选项应该是一个返回对象的函数：\n\n<div class=\"sfc\">\n\n```js{3-5}\nexport default {\n  data() {\n    return {\n      message: 'Hello World!'\n    }\n  }\n}\n```\n\n</div>\n<div class=\"html\">\n\n```js{3-5}\ncreateApp({\n  data() {\n    return {\n      message: 'Hello World!'\n    }\n  }\n})\n```\n\n</div>\n\n`message` 属性可以在模板中使用。下面展示了我们如何使用双花括号法，根据 `message` 的值来渲染动态文本：\n\n```vue-html\n<h1>{{ message }}</h1>\n```\n\n</div>\n\n在双花括号中的内容并不只限于标识符或路径——我们可以使用任何有效的 JavaScript 表达式。\n\n```vue-html\n<h1>{{ message.split('').reverse().join('') }}</h1>\n```\n\n<div class=\"composition-api\">\n\n现在，试着自己创建一些响应式状态，用它来为模板中的 `<h1>` 渲染动态的文本内容。\n\n</div>\n\n<div class=\"options-api\">\n\n现在，试着自己创建一个数据属性，用它来为模板中的 `<h1>` 渲染动态的文本内容。\n\n</div>\n\n\n\n================================================\nFILE: src/tutorial/src/step-2/_hint/App/composition.js\n================================================\nimport { reactive, ref } from 'vue'\n\nexport default {\n  setup() {\n    const counter = reactive({ count: 0 })\n    const message = ref('Hello World!')\n\n    return {\n      counter,\n      message\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-2/_hint/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      message: 'Hello World!',\n      counter: {\n        count: 0\n      }\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-2/_hint/App/template.html\n================================================\n<h1>{{ message }}</h1>\n<p>Count is: {{ counter.count }}</p>\n\n\n\n================================================\nFILE: src/tutorial/src/step-2/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    // 组件逻辑\n    // 此处声明一些响应式状态\n\n    return {\n      // 暴露给模板\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-2/App/options.js\n================================================\nexport default {\n  // 组件选项\n  // 此处声明一些响应式状态\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-2/App/template.html\n================================================\n<h1>Make me dynamic!</h1>\n\n\n\n================================================\nFILE: src/tutorial/src/step-3/description.md\n================================================\n# Attribute 绑定 {#attribute-bindings}\n\n在 Vue 中，mustache 语法 (即双大括号) 只能用于文本插值。为了给 attribute 绑定一个动态值，需要使用 `v-bind` 指令：\n\n```vue-html\n<div v-bind:id=\"dynamicId\"></div>\n```\n\n**指令**是由 `v-` 开头的一种特殊 attribute。它们是 Vue 模板语法的一部分。和文本插值类似，指令的值是可以访问组件状态的 JavaScript 表达式。关于 `v-bind` 和指令语法的完整细节请详阅<a target=\"_blank\" href=\"/guide/essentials/template-syntax.html\">指南 - 模板语法</a>。\n\n冒号后面的部分 (`:id`) 是指令的“参数”。此处，元素的 `id` attribute 将与组件状态里的 `dynamicId` 属性保持同步。\n\n由于 `v-bind` 使用地非常频繁，它有一个专门的简写语法：\n\n```vue-html\n<div :id=\"dynamicId\"></div>\n```\n\n现在，试着把一个动态的 `class` 绑定添加到这个 `<h1>` 上，并使用 `titleClass` 的<span class=\"options-api\">数据属性</span><span class=\"composition-api\"> ref </span>作为它的值。如果绑定正确，文字将会变为红色。\n\n\n\n================================================\nFILE: src/tutorial/src/step-3/_hint/App/template.html\n================================================\n<h1 :class=\"titleClass\">Make me red</h1>\n\n\n\n================================================\nFILE: src/tutorial/src/step-3/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const titleClass = ref('title')\n\n    return {\n      titleClass\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-3/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      titleClass: 'title'\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-3/App/style.css\n================================================\n.title {\n  color: red;\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-3/App/template.html\n================================================\n<h1>Make me red</h1> <!-- 此处添加一个动态 class 绑定 -->\n\n\n\n================================================\nFILE: src/tutorial/src/step-4/description.md\n================================================\n# 事件监听 {#event-listeners}\n\n我们可以使用 `v-on` 指令监听 DOM 事件：\n\n```vue-html\n<button v-on:click=\"increment\">{{ count }}</button>\n```\n\n因为其经常使用，`v-on` 也有一个简写语法：\n\n```vue-html\n<button @click=\"increment\">{{ count }}</button>\n```\n\n<div class=\"options-api\">\n\n此处，`increment` 引用了一个使用 `methods` 选项声明的函数：\n\n<div class=\"sfc\">\n\n```js{7-12}\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    increment() {\n      // 更新组件状态\n      this.count++\n    }\n  }\n}\n```\n\n</div>\n<div class=\"html\">\n\n```js{7-12}\ncreateApp({\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    increment() {\n      // 更新组件状态\n      this.count++\n    }\n  }\n})\n```\n\n</div>\n\n在方法中，我们可以使用 `this` 来访问组件实例。组件实例会暴露 `data` 中声明的数据属性。我们可以通过改变这些属性的值来更新组件状态。\n\n</div>\n\n<div class=\"composition-api\">\n\n<div class=\"sfc\">\n\n此处，`increment` 引用了一个在 `<script setup>` 中声明的函数：\n\n```vue{6-9}\n<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n\nfunction increment() {\n  // 更新组件状态\n  count.value++\n}\n</script>\n```\n\n</div>\n\n<div class=\"html\">\n\n此处，`increment` 引用了一个从 `setup()` 对象返回的方法：\n\n```js{$}\nsetup() {\n  const count = ref(0)\n\n  function increment(e) {\n    // 更新组件状态\n    count.value++\n  }\n\n  return {\n    count,\n    increment\n  }\n}\n```\n\n</div>\n\n在函数中，我们可以通过修改 ref 来更新组件状态。\n\n</div>\n\n事件处理函数也可以使用内置表达式，并且可以使用修饰符简化常见任务。这些细节包含在<a target=\"_blank\" href=\"/guide/essentials/event-handling.html\">指南 - 事件处理</a>。\n\n现在，尝试自行实现 `increment` <span class=\"options-api\">方法</span><span class=\"composition-api\">函数</span>并通过使用 `v-on` 将其绑定到按钮上。\n\n\n\n================================================\nFILE: src/tutorial/src/step-4/_hint/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    function increment() {\n      count.value++\n    }\n\n    return {\n      count,\n      increment\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-4/_hint/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    increment() {\n      this.count++\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-4/_hint/App/template.html\n================================================\n<button @click=\"increment\">Count is: {{ count }}</button>\n\n\n\n================================================\nFILE: src/tutorial/src/step-4/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    return {\n      count\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-4/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-4/App/template.html\n================================================\n<!-- 使此按钮生效 -->\n<button>Count is: {{ count }}</button>\n\n\n\n================================================\nFILE: src/tutorial/src/step-5/description.md\n================================================\n# 表单绑定 {#form-bindings}\n\n我们可以同时使用 `v-bind` 和 `v-on` 来在表单的输入元素上创建双向绑定：\n\n```vue-html\n<input :value=\"text\" @input=\"onInput\">\n```\n\n<div class=\"options-api\">\n\n```js\nmethods: {\n  onInput(e) {\n    // v-on 处理函数会接收原生 DOM 事件\n    // 作为其参数。\n    this.text = e.target.value\n  }\n}\n```\n\n</div>\n\n<div class=\"composition-api\">\n\n```js\nfunction onInput(e) {\n  // v-on 处理函数会接收原生 DOM 事件\n  // 作为其参数。\n  text.value = e.target.value\n}\n```\n\n</div>\n\n试着在文本框里输入——你会看到 `<p>` 里的文本也随着你的输入更新了。\n\n为了简化双向绑定，Vue 提供了一个 `v-model` 指令，它实际上是上述操作的语法糖：\n\n```vue-html\n<input v-model=\"text\">\n```\n\n`v-model` 会将被绑定的值与 `<input>` 的值自动同步，这样我们就不必再使用事件处理函数了。\n\n`v-model` 不仅支持文本输入框，也支持诸如多选框、单选框、下拉框之类的输入类型。我们在<a target=\"_blank\" href=\"/guide/essentials/forms.html\">指南 - 表单绑定</a>中讨论了更多的细节。\n\n现在，试着用 `v-model` 把代码重构一下吧。\n\n\n\n================================================\nFILE: src/tutorial/src/step-5/_hint/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const text = ref('')\n\n    return {\n      text\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-5/_hint/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      text: ''\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-5/_hint/App/template.html\n================================================\n<input v-model=\"text\" placeholder=\"Type here\">\n<p>{{ text }}</p>\n\n\n\n================================================\nFILE: src/tutorial/src/step-5/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const text = ref('')\n\n    function onInput(e) {\n      text.value = e.target.value\n    }\n\n    return {\n      text,\n      onInput\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-5/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      text: ''\n    }\n  },\n  methods: {\n    onInput(e) {\n      this.text = e.target.value\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-5/App/template.html\n================================================\n<input :value=\"text\" @input=\"onInput\" placeholder=\"Type here\">\n<p>{{ text }}</p>\n\n\n\n================================================\nFILE: src/tutorial/src/step-6/description.md\n================================================\n# 条件渲染 {#conditional-rendering}\n\n我们可以使用 `v-if` 指令来有条件地渲染元素：\n\n```vue-html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n```\n\n这个 `<h1>` 标签只会在 `awesome` 的值为[真值 (Truthy)](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy) 时渲染。若 `awesome` 更改为[假值 (Falsy)](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy)，它将被从 DOM 中移除。\n\n我们也可以使用 `v-else` 和 `v-else-if` 来表示其他的条件分支：\n\n```vue-html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>Oh no 😢</h1>\n```\n\n现在，示例程序同时展示了两个 `<h1>` 标签，并且按钮不执行任何操作。尝试给它们添加 `v-if` 和 `v-else` 指令，并实现 `toggle()` 方法，让我们可以使用按钮在它们之间切换。\n\n更多细节请查阅 `v-if`：<a target=\"_blank\" href=\"/guide/essentials/conditional.html\">指南 - 条件渲染</a>\n\n\n\n================================================\nFILE: src/tutorial/src/step-6/_hint/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const awesome = ref(true)\n\n    function toggle() {\n      awesome.value = !awesome.value\n    }\n\n    return {\n      awesome,\n      toggle\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-6/_hint/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      awesome: true\n    }\n  },\n  methods: {\n    toggle() {\n      this.awesome = !this.awesome\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-6/_hint/App/template.html\n================================================\n<button @click=\"toggle\">Toggle</button>\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>Oh no 😢</h1>\n\n\n\n================================================\nFILE: src/tutorial/src/step-6/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const awesome = ref(true)\n\n    function toggle() {\n      // ...\n    }\n\n    return {\n      awesome,\n      toggle\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-6/App/options.js\n================================================\nexport default {\n  data() {\n    return {\n      awesome: true\n    }\n  },\n  methods: {\n    toggle() {\n      // ...\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-6/App/template.html\n================================================\n<button @click=\"toggle\">Toggle</button>\n<h1>Vue is awesome!</h1>\n<h1>Oh no 😢</h1>\n\n\n\n================================================\nFILE: src/tutorial/src/step-7/description.md\n================================================\n# 列表渲染 {#list-rendering}\n\n我们可以使用 `v-for` 指令来渲染一个基于源数组的列表：\n\n```vue-html\n<ul>\n  <li v-for=\"todo in todos\" :key=\"todo.id\">\n    {{ todo.text }}\n  </li>\n</ul>\n```\n\n这里的 `todo` 是一个局部变量，表示当前正在迭代的数组元素。它只能在 `v-for` 所绑定的元素上或是其内部访问，就像函数的作用域一样。\n\n注意，我们还给每个 todo 对象设置了唯一的 `id`，并且将它作为<a target=\"_blank\" href=\"/api/built-in-special-attributes.html#key\">特殊的 `key` attribute</a> 绑定到每个 `<li>`。`key` 使得 Vue 能够精确地移动每个 `<li>`，以匹配对应的对象在数组中的位置。\n\n更新列表有两种方式：\n\n1. 在源数组上调用[变更方法](https://stackoverflow.com/questions/9009879/which-javascript-array-functions-are-mutating)：\n\n   <div class=\"composition-api\">\n\n   ```js\n   todos.value.push(newTodo)\n   ```\n\n     </div>\n     <div class=\"options-api\">\n\n   ```js\n   this.todos.push(newTodo)\n   ```\n\n   </div>\n\n2. 使用新的数组替代原数组：\n\n   <div class=\"composition-api\">\n\n   ```js\n   todos.value = todos.value.filter(/* ... */)\n   ```\n\n     </div>\n     <div class=\"options-api\">\n\n   ```js\n   this.todos = this.todos.filter(/* ... */)\n   ```\n\n   </div>\n\n这里有一个简单的 todo 列表——试着实现一下 `addTodo()` 和 `removeTodo()` 这两个方法的逻辑，使列表能够正常工作！\n\n关于 `v-for` 的更多细节：<a target=\"_blank\" href=\"/guide/essentials/list.html\">指南 - 列表渲染</a>\n\n\n\n================================================\nFILE: src/tutorial/src/step-7/_hint/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    // 给每个 todo 对象一个唯一的 id\n    let id = 0\n\n    const newTodo = ref('')\n    const todos = ref([\n      { id: id++, text: 'Learn HTML' },\n      { id: id++, text: 'Learn JavaScript' },\n      { id: id++, text: 'Learn Vue' }\n    ])\n\n    function addTodo() {\n      todos.value.push({ id: id++, text: newTodo.value })\n      newTodo.value = ''\n    }\n\n    function removeTodo(todo) {\n      todos.value = todos.value.filter((t) => t !== todo)\n    }\n\n    return {\n      newTodo,\n      todos,\n      addTodo,\n      removeTodo\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-7/_hint/App/options.js\n================================================\n// 给每个 todo 对象一个唯一的 id\nlet id = 0\n\nexport default {\n  data() {\n    return {\n      newTodo: '',\n      todos: [\n        { id: id++, text: 'Learn HTML' },\n        { id: id++, text: 'Learn JavaScript' },\n        { id: id++, text: 'Learn Vue' }\n      ]\n    }\n  },\n  methods: {\n    addTodo() {\n      this.todos.push({ id: id++, text: this.newTodo })\n      this.newTodo = ''\n    },\n    removeTodo(todo) {\n      this.todos = this.todos.filter((t) => t !== todo)\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-7/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    // 给每个 todo 对象一个唯一的 id\n    let id = 0\n\n    const newTodo = ref('')\n    const todos = ref([\n      { id: id++, text: 'Learn HTML' },\n      { id: id++, text: 'Learn JavaScript' },\n      { id: id++, text: 'Learn Vue' }\n    ])\n\n    function addTodo() {\n      // ...\n      newTodo.value = ''\n    }\n\n    function removeTodo(todo) {\n      // ...\n    }\n\n    return {\n      newTodo,\n      todos,\n      addTodo,\n      removeTodo\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-7/App/options.js\n================================================\n// 给每个 todo 对象一个唯一的 id\nlet id = 0\n\nexport default {\n  data() {\n    return {\n      newTodo: '',\n      todos: [\n        { id: id++, text: 'Learn HTML' },\n        { id: id++, text: 'Learn JavaScript' },\n        { id: id++, text: 'Learn Vue' }\n      ]\n    }\n  },\n  methods: {\n    addTodo() {\n      // ...\n      this.newTodo = ''\n    },\n    removeTodo(todo) {\n      // ...\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-7/App/template.html\n================================================\n<form @submit.prevent=\"addTodo\">\n  <input v-model=\"newTodo\" required placeholder=\"new todo\">\n  <button>Add Todo</button>\n</form>\n<ul>\n  <li v-for=\"todo in todos\" :key=\"todo.id\">\n    {{ todo.text }}\n    <button @click=\"removeTodo(todo)\">X</button>\n  </li>\n</ul>\n\n\n\n================================================\nFILE: src/tutorial/src/step-8/description.md\n================================================\n# 计算属性 {#computed-property}\n\n让我们在上一步的 todo 列表基础上继续。现在，我们已经给每一个 todo 添加了切换功能。这是通过给每一个 todo 对象添加 `done` 属性来实现的，并且使用了 `v-model` 将其绑定到复选框上：\n\n```vue-html{2}\n<li v-for=\"todo in todos\">\n  <input type=\"checkbox\" v-model=\"todo.done\">\n  ...\n</li>\n```\n\n下一个可以添加的改进是隐藏已经完成的 todo。我们已经有了一个能够切换 `hideCompleted` 状态的按钮。但是应该如何基于状态渲染不同的列表项呢？\n\n<div class=\"options-api\">\n\n介绍一个新概念：<a target=\"_blank\" href=\"/guide/essentials/computed.html\">计算属性</a>。我们可以使用 `computed` 选项声明一个响应式的属性，它的值由其他属性计算而来：\n\n<div class=\"sfc\">\n\n```js\nexport default {\n  // ...\n  computed: {\n    filteredTodos() {\n      // 根据 `this.hideCompleted` 返回过滤后的 todo 项目\n    }\n  }\n}\n```\n\n</div>\n<div class=\"html\">\n\n```js\ncreateApp({\n  // ...\n  computed: {\n    filteredTodos() {\n      // 根据 `this.hideCompleted` 返回过滤后的 todo 项目\n    }\n  }\n})\n```\n\n</div>\n\n</div>\n<div class=\"composition-api\">\n\n介绍一个新 API：<a target=\"_blank\" href=\"/guide/essentials/computed.html\">`computed()`</a>。它可以让我们创建一个计算属性 ref，这个 ref 会动态地根据其他响应式数据源来计算其 `.value`：\n\n<div class=\"sfc\">\n\n```js{8-11}\nimport { ref, computed } from 'vue'\n\nconst hideCompleted = ref(false)\nconst todos = ref([\n  /* ... */\n])\n\nconst filteredTodos = computed(() => {\n  // 根据 `todos.value` & `hideCompleted.value`\n  // 返回过滤后的 todo 项目\n})\n```\n\n</div>\n<div class=\"html\">\n\n```js{10-13}\nimport { createApp, ref, computed } from 'vue'\n\ncreateApp({\n  setup() {\n    const hideCompleted = ref(false)\n    const todos = ref([\n      /* ... */\n    ])\n\n    const filteredTodos = computed(() => {\n      // 根据 `todos.value` & `hideCompleted.value`\n      // 返回过滤后的 todo 项目\n    })\n\n    return {\n      // ...\n    }\n  }\n})\n```\n\n</div>\n\n</div>\n\n```diff\n- <li v-for=\"todo in todos\">\n+ <li v-for=\"todo in filteredTodos\">\n```\n\n计算属性会自动跟踪其计算中所使用的到的其他响应式状态，并将它们收集为自己的依赖。计算结果会被缓存，并只有在其依赖发生改变时才会被自动更新。\n\n现在，试着添加 `filteredTodos` 计算属性并实现计算逻辑！如果实现正确，在隐藏已完成项目的状态下勾选一个 todo，它也应当被立即隐藏。\n\n\n\n================================================\nFILE: src/tutorial/src/step-8/_hint/App/composition.js\n================================================\nimport { ref, computed } from 'vue'\n\nexport default {\n  setup() {\n    let id = 0\n\n    const newTodo = ref('')\n    const hideCompleted = ref(false)\n    const todos = ref([\n      { id: id++, text: 'Learn HTML', done: true },\n      { id: id++, text: 'Learn JavaScript', done: true },\n      { id: id++, text: 'Learn Vue', done: false }\n    ])\n\n    const filteredTodos = computed(() => {\n      return hideCompleted.value\n        ? todos.value.filter((t) => !t.done)\n        : todos.value\n    })\n\n    function addTodo() {\n      todos.value.push({ id: id++, text: newTodo.value, done: false })\n      newTodo.value = ''\n    }\n\n    function removeTodo(todo) {\n      todos.value = todos.value.filter((t) => t !== todo)\n    }\n\n    return {\n      newTodo,\n      hideCompleted,\n      todos,\n      filteredTodos,\n      addTodo,\n      removeTodo\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-8/_hint/App/options.js\n================================================\nlet id = 0\n\nexport default {\n  data() {\n    return {\n      newTodo: '',\n      hideCompleted: false,\n      todos: [\n        { id: id++, text: 'Learn HTML', done: true },\n        { id: id++, text: 'Learn JavaScript', done: true },\n        { id: id++, text: 'Learn Vue', done: false }\n      ]\n    }\n  },\n  computed: {\n    filteredTodos() {\n      return this.hideCompleted\n        ? this.todos.filter((t) => !t.done)\n        : this.todos\n    }\n  },\n  methods: {\n    addTodo() {\n      this.todos.push({ id: id++, text: this.newTodo, done: false })\n      this.newTodo = ''\n    },\n    removeTodo(todo) {\n      this.todos = this.todos.filter((t) => t !== todo)\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-8/_hint/App/template.html\n================================================\n<form @submit.prevent=\"addTodo\">\n  <input v-model=\"newTodo\" required placeholder=\"new todo\">\n  <button>Add Todo</button>\n</form>\n<ul>\n  <li v-for=\"todo in filteredTodos\" :key=\"todo.id\">\n    <input type=\"checkbox\" v-model=\"todo.done\">\n    <span :class=\"{ done: todo.done }\">{{ todo.text }}</span>\n    <button @click=\"removeTodo(todo)\">X</button>\n  </li>\n</ul>\n<button @click=\"hideCompleted = !hideCompleted\">\n  {{ hideCompleted ? 'Show all' : 'Hide completed' }}\n</button>\n\n\n\n================================================\nFILE: src/tutorial/src/step-8/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    let id = 0\n\n    const newTodo = ref('')\n    const hideCompleted = ref(false)\n    const todos = ref([\n      { id: id++, text: 'Learn HTML', done: true },\n      { id: id++, text: 'Learn JavaScript', done: true },\n      { id: id++, text: 'Learn Vue', done: false }\n    ])\n\n    function addTodo() {\n      todos.value.push({ id: id++, text: newTodo.value, done: false })\n      newTodo.value = ''\n    }\n\n    function removeTodo(todo) {\n      todos.value = todos.value.filter((t) => t !== todo)\n    }\n\n    return {\n      newTodo,\n      hideCompleted,\n      todos,\n      addTodo,\n      removeTodo\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-8/App/options.js\n================================================\nlet id = 0\n\nexport default {\n  data() {\n    return {\n      newTodo: '',\n      hideCompleted: false,\n      todos: [\n        { id: id++, text: 'Learn HTML', done: true },\n        { id: id++, text: 'Learn JavaScript', done: true },\n        { id: id++, text: 'Learn Vue', done: false }\n      ]\n    }\n  },\n  computed: {\n    // ...\n  },\n  methods: {\n    addTodo() {\n      this.todos.push({ id: id++, text: this.newTodo, done: false })\n      this.newTodo = ''\n    },\n    removeTodo(todo) {\n      this.todos = this.todos.filter((t) => t !== todo)\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-8/App/style.css\n================================================\n.done {\n  text-decoration: line-through;\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-8/App/template.html\n================================================\n<form @submit.prevent=\"addTodo\">\n  <input v-model=\"newTodo\" required placeholder=\"new todo\">\n  <button>Add Todo</button>\n</form>\n<ul>\n  <li v-for=\"todo in todos\" :key=\"todo.id\">\n    <input type=\"checkbox\" v-model=\"todo.done\">\n    <span :class=\"{ done: todo.done }\">{{ todo.text }}</span>\n    <button @click=\"removeTodo(todo)\">X</button>\n  </li>\n</ul>\n<button @click=\"hideCompleted = !hideCompleted\">\n  {{ hideCompleted ? 'Show all' : 'Hide completed' }}\n</button>\n\n\n\n================================================\nFILE: src/tutorial/src/step-9/description.md\n================================================\n[Binary file]\n\n\n================================================\nFILE: src/tutorial/src/step-9/_hint/App/composition.js\n================================================\nimport { ref, onMounted } from 'vue'\n\nexport default {\n  setup() {\n    const pElementRef = ref(null)\n\n    onMounted(() => {\n      pElementRef.value.textContent = 'mounted!'\n    })\n\n    return {\n      pElementRef\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-9/_hint/App/options.js\n================================================\nexport default {\n  mounted() {\n    this.$refs.pElementRef.textContent = 'mounted!'\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-9/App/composition.js\n================================================\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const pElementRef = ref(null)\n\n    return {\n      pElementRef\n    }\n  }\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-9/App/options.js\n================================================\nexport default {\n  // ...\n}\n\n\n\n================================================\nFILE: src/tutorial/src/step-9/App/template.html\n================================================\n<p ref=\"pElementRef\">Hello</p>\n\n\n\n================================================\nFILE: .github/dependabot.yml\n================================================\nversion: 2\nupdates:\n  # Enable version updates for npm\n  - package-ecosystem: 'npm'\n    # Look for `package.json` and `lock` files in the `root` directory\n    directory: '/'\n    # Check the npm registry for updates every day (weekdays)\n    schedule:\n      interval: 'daily'\n    open-pull-requests-limit: 10\n    versioning-strategy: lockfile-only\n    allow:\n      - dependency-name: 'vue'\n      - dependency-name: 'vitepress'\n      - dependency-name: '@vue/theme'\n      - dependency-name: '@vue/repl'\n\n\n\n================================================\nFILE: .github/pull_request_template.md\n================================================\n### 在创建 pull request 之前\n\n请确认：\n\n- [ ] 我已经阅读过项目的 [wiki](https://github.com/vuejs-translations/docs-zh-cn/wiki) 了解相关注意事项。\n- [ ] 我对翻译内容的改动不包含基于英文原版的扩展、删减或演绎 (如有，请移步至[英文文档仓库](https://github.com/vuejs/docs)讨论，相关结论会被定期从英文版同步)\n\n### 问题描述\n\n\n\n\n================================================\nFILE: .github/contributing/writing-guide.md\n================================================\n# Vue Docs Writing Guide\n\nWriting documentation is an exercise in empathy. We're not describing an objective reality - the source code already does that. Our job is to help shape the relationship between users and the Vue ecosystem. This ever-evolving guide provides some rules and recommendations on how to do that consistently within the Vue ecosystem.\n\n## Principles\n\n- **A feature doesn't exist until it's well documented.**\n- **Respect users' cognitive capacity (i.e. brain power).** When a user starts reading, they begin with a certain amount of limited brain power and when they run out, they stop learning.\n  - Cognitive capacity is **depleted faster** by complex sentences, having to learn more than one concept at a time, and abstract examples that don't directly relate to a user's work.\n  - Cognitive capacity is **depleted more slowly** when we help them feel consistently smart, powerful, and curious. Breaking things down into digestible pieces and minding the flow of the document can help keep them in this state.\n- **Always try to see from the user's perspective.** When we understand something thoroughly, it becomes obvious to us. This is called _the curse of knowledge_. In order to write good documentation, try to remember what you first needed to know when learning this concept. What jargon did you need to learn? What did you misunderstand? What took a long time to really grasp? Good documentation meets users where they are. It can be helpful to practice explaining the concept to people in person before.\n- **Describe the _problem_ first, then the solution.** Before showing how a feature works, it's important to explain why it exists. Otherwise, users won't have the context to know if this information is important to them (is it a problem they experience?) or what prior knowledge/experience to connect it to.\n- **While writing, don't be afraid to ask questions**, _especially_ if you're afraid that your questions might be \"foolish\". Being vulnerable is hard, but it's the only way for us to more fully understand what we need to explain.\n- **Be involved in feature discussions.** The best APIs come from documentation-driven development, where we build features that are easy to explain, rather than trying to figure out how to explain them later. Asking questions (especially \"foolish\" questions) earlier often helps reveal confusions, inconsistencies, and problematic behavior before a breaking change would be required to fix them.\n\n## Organization\n\n- **Installation/Integration**: Provide a thorough overview of how to integrate the software into as many different kinds of projects as necessary.\n- **Introduction/Getting Started**:\n  - Provide a less than 10 minute overview of the problems the project solves and why it exists.\n  - Provide a less than 30 minute overview of the problems the project solves and how, including when and why to use the project and some simple code examples. At the end, link to both the Installation page and the beginning of the Essentials Guide.\n- **Guide**: Make users feel smart, powerful, and curious, then maintain this state so that users maintain the motivation and cognitive capacity to keep learning more. Guide pages are meant to be read sequentially, so should generally be ordered from the highest to lowest power/effort ratio.\n  - **Essentials**: It should take no longer than 5 hours to read the Essentials, though shorter is better. Its goal is to provide the 20% of knowledge that will help users handle 80% of use cases. Essentials can link to more advanced guides and the API, though, in most cases, you should avoid such links. When they are provided, you need also provide a context so users are aware if they should follow this link on their first reading. Otherwise, many users end up exhausting their cognitive capacity link-hopping, trying to fully learn every aspect of a feature before moving on, and as a result, never finish that first read-through of the Essentials. Remember that a smooth read is more important than being thorough. We want to give people the information they need to avoid a frustrating experience, but they can always come back and read further, or Google a less common problem when they encounter it.\n  - **Advanced**: While the Essentials helps people handle ~80% of use cases, subsequent guides help get users to 95% of use cases, plus more detailed information on non-essential features (e.g. transitions, animations), more complex convenience features (e.g. mixins, custom directives), and dev experience improvements (e.g. JSX, plugins). The final 5% of use cases that are more niche, complex, and/or prone to abuse will be left to the cookbook and API reference, which can be linked to from these advanced guides.\n- **Reference/API**: Provide a complete list of features, including type information, descriptions of the problem each solves, examples of every combination of options, and links to guides, cookbook recipes, and other internal resources providing more detail. Unlike other pages, this one is not meant to be read top-to-bottom, so plenty of detail can be provided. These references must also be more easily skimmable than the guides, so the format should be closer to dictionary entries than the story-telling format of the guides.\n- **Migrations**:\n  - **Versions**: When important changes are made, it's useful to include a full list of changes, including a detailed explanation of why the change was made and how to migrate their projects.\n  - **From other projects**: How does this software compare to similar software? This is important to help users understand what additional problems we might solve or create for them, and to what extent they can transfer knowledge they already have.\n- **Style Guide**: There are necessarily some key pieces in development that need a decision, but are not core to the API. The style guide provides educated, opinionated recommendations to help guide these decisions. They shouldn't be followed blindly, but can help teams save time by being aligned on smaller details.\n- **Cookbook**: Recipes in the cookbook are written with some assumption of familiarity with Vue and its ecosystem. Each is a highly structured document that walks through some common implementation details that a Vue dev might encounter.\n\n## Writing & Grammar\n\n### Style\n\n- **Headings should describe problems**, not solutions. For example, a less effective heading might be \"Using props\", because it describes a solution. A better heading might be \"Passing Data to Child Components with Props\", because it provides the context of the problem props solve. Users won't really start paying attention to the explanation of a feature until they have some idea of why/when they'd use it.\n- **When you assume knowledge, declare it** at the beginning and link to resources for less common knowledge that you're expecting.\n- **Introduce only one new concept at a time whenever possible** (including both text and code examples). Even if many people are able to understand when you introduce more than one, there are also many who will become lost - and even those who don't become lost will have depleted more of their cognitive capacity.\n- **Avoid special content blocks for tips and caveats when possible.** It's generally preferable to blend these more naturally into the main content, e.g. by building on examples to demonstrate an edge case.\n- **Don't include more than two interwoven tips and caveats per page.** If you find that more than two tips are needed in a page, consider adding a caveats section to address these issues. The guide is meant to be read straight through, and tips and caveats can be overwhelming or distracting to someone trying to understand the base concepts.\n- **Avoid appeals to authority** (e.g. \"you should do X, because that's a best practice\" or \"X is best because it gives you full separation of concerns\"). Instead, demonstrate with examples the specific human problems caused and/or solved by a pattern.\n- **When deciding what to teach first, think of what knowledge will provide the best power/effort ratio.** That means teaching whatever will help users solve the greatest pains or greatest number of problems, with the relatively least effort to learn. This helps learners feel smart, powerful, and curious, so their cognitive capacity will drain more slowly.\n- **Unless the context assumes a string template or build system, only write code that works in any environment by the software (e.g. Vue, Vuex, etc).**\n- **Show, don't tell.** For example, \"To use Vue on a page, you can add this to your HTML\" (then show the script tag), instead of \"To use Vue on a page, you can add a script element with a src attribute, the value of which should be a link to Vue's compiled source\".\n- **Almost always avoid humor (for English docs)**, especially sarcasm and pop culture references, as it doesn't translate well across cultures.\n- **Never assume a more advanced context than you have to.**\n- **In most cases, prefer links between sections of the docs over repeating the same content in multiple sections.** Some repetition in content is unavoidable and even essential for learning. However, too much repetition also makes the docs more difficult to maintain, because a change in the API will require changes in many places and it's easy to miss something. This is a difficult balance to strike.\n- **Specific is better than generic.** For example, a `<BlogPost>` component example is better than `<ComponentA>`.\n- **Relatable is better than obscure.** For example, a `<BlogPost>` component example is better than `<CurrencyExchangeSettings>`.\n- **Be emotionally relevant.** Explanations and examples that relate to something people have experience with and care about will always be more effective.\n- **Always prefer simpler, plainer language over complex or jargony language.** For example:\n  - \"you can use Vue with a script element\" instead of \"in order to initiate the usage of Vue, one possible option is to actually inject it via a script HTML element\"\n  - \"function that returns a function\" instead of \"higher order function\"\n- **Avoid language that invalidate struggle**, such as \"easy\", \"just\", \"obviously\", etc. For reference, see [Words To Avoid in Educational Writing](https://css-tricks.com/words-avoid-educational-writing/).\n\n### Grammar\n\n- **Avoid abbreviations** in writing and code examples (e.g. `attribute` is better than `attr`, `message` is better than `msg`), unless you are specifically referencing an abbreviation in an API (e.g. `$attrs`). Abbreviation symbols included on standard keyboards (e.g. `@`, `#`, `&`) are OK.\n- **When referencing a directly following example, use a colon (`:`) to end a sentence**, rather than a period (`.`).\n- **Use the Oxford comma** (e.g. \"a, b, and c\" instead of \"a, b and c\"). ![Why the Oxford comma is important](./oxford-comma.jpg)\n  - Source: [The Serial (Oxford) Comma: When and Why To Use It](https://www.inkonhand.com/2015/10/the-serial-oxford-comma-when-and-why-to-use-it/)\n- **When referencing the name of a project, use the name that the project refers to itself as.** For example, \"webpack\" and \"npm\" should both use lowercase as that's how their documentation refers to them.\n- **Use Title Case for headings** - at least for now, since it's what we use through the rest of the docs. There's research suggesting that sentence case (only first word of the heading starts with a capital) is actually superior for legibility and also reduces the cognitive overhead for documentation writers, since they don't have to try to remember whether to capitalize words like \"and\", \"with\", and \"about\".\n- **Don't use emojis (except in discussions).** Emojis are cute and friendly, but they can be a distraction in documentation and some emojis even convey different meanings in different cultures.\n\n## Iteration & Communication\n\n- **Excellence comes from iteration.** First drafts are always bad, but writing them is a vital part of the process. It's extremely difficult to avoid the slow progression of Bad -> OK -> Good -> Great -> Inspiring -> Transcendent.\n- **Only wait until something is \"Good\" before publishing.** The community will help you push it further down the chain.\n- **Try not to get defensive when receiving feedback.** Our writing can be very personal to us, but if we get upset with the people who help us make it better, they will either stop giving feedback or start limiting the kind of feedback they give.\n- **Proof-read your own work before showing it to others.** If you show someone work with a lot of spelling/grammar mistakes, you'll get feedback about spelling grammar/mistakes instead of more valuable notes about whether the writing is achieving your goals.\n- **When you ask people for feedback, tell reviewers what:**\n  - **you're trying to do**\n  - **your fears are**\n  - **balances you're trying to strike**\n- **When someone reports a problem, there is almost always a problem**, even if the solution they proposed isn't quite right. Keep asking follow-up questions to learn more.\n- People need to feel safe asking questions when contributing/reviewing content. Here's how you can do that:\n  - **Thank people for their contributions/reviews, even if you're feeling grumpy.** For example:\n    - \"Great question!\"\n    - \"Thanks for taking the time to explain. 🙂\"\n    - \"This is actually intentional, but thanks for taking the time to contribute. 😊\"\n  - **Listen to what people are saying and mirror if you're not sure you're understanding correctly.** This can help validate people's feelings and experiences, while also understanding if _you're_ understanding _them_ correctly.\n  - **Use a lot of positive and empathetic emojis.** It's always better to seem a little strange than mean or impatient.\n  - **Kindly communicate rules/boundaries.** If someone behaves in a way that's abusive/inappropriate, respond only with kindness and maturity, but also make it clear that this behavior is not acceptable and what will happen (according to the code of conduct) if they continue behaving poorly.\n\n### Tips, Callouts, Alerts, and Line Highlights\n\nWe have some dedicated styles to denote something that's worth highlighting in a particular way. These are captured [on this page](https://vitepress.dev/guide/markdown#custom-containers). **They are to be used sparingly.**\n\nThere is a certain temptation to abuse these styles, as one can simply add a change inside a callout. However, this breaks up the flow of reading for the user and should only be used in special circumstances. Wherever possible, we should attempt to create a narrative and flow within the page to respect the reader's cognitive load.\n\nUnder no circumstances should two alerts be used next to one another, it's a sign that we're not able to explain context well enough.\n\n### Contributing\n\nWe appreciate small, focused PRs. If you'd like to make an extremely large change, please communicate with team members prior to a pull request. Here's a [writeup that details why this is so critical](https://www.netlify.com/blog/2020/03/31/how-to-scope-down-prs/) for us to work well on this team. Please understand that though we always appreciate contributions, ultimately we have to prioritize what works best for the project as a whole.\n\n## Resources\n\n### Software\n\n- [Grammarly](https://www.grammarly.com/): Desktop app and browser extension for checking spelling and grammar (though grammar checking doesn't catch everything and occasionally shows a false positive).\n- [Code Spell Checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker): An extension for VS Code to help you check spelling within markdown and code examples.\n\n### Books\n\n- [On Writing Well](https://www.amazon.com/Writing-Well-30th-Anniversary-Nonfiction-ebook/dp/B0090RVGW0) (see [popular quotes](https://www.goodreads.com/work/quotes/1139032-on-writing-well-the-classic-guide-to-writing-nonfiction))\n- [Bird by Bird](https://www.amazon.com/Bird-Some-Instructions-Writing-Life/dp/0385480016) (see [popular quotes](https://www.goodreads.com/work/quotes/841198-bird-by-bird-some-instructions-on-writing-and-life))\n- [Cognitive Load Theory](https://www.amazon.com/Cognitive-Explorations-Instructional-Performance-Technologies/dp/144198125X/)\n\n\n\n================================================\nFILE: .github/ISSUE_TEMPLATE/bug_report.yaml\n================================================\nname: 问题报告\ndescription: 报告本站点相关的问题。请认真阅读并填写，否则 issue 将可能被直接关闭。\nlabels: []\nassignees: []\nbody:\n  - type: markdown\n    attributes:\n      value: |\n        这里是 Vue.js 3 官方中文 [cn.vuejs.org](https://cn.vuejs.org/) 仓库，仅处理：\n        1. 文档翻译相关；\n        2. 网络环境和本地化；\n        3. 其他与本仓库直接相关的问题，如译法讨论、流程优化等。\n\n  - type: checkboxes\n    id: terms\n    attributes:\n      label: 提问须知\n      description: 请认真阅读以上说明后，勾选以下字段。\n      options:\n        - label: 我确定这是官方版本 [cn.vuejs.org](https://cn.vuejs.org/) 的 issue，而不是其他非官方翻译版本\n          required: true\n        - label: 我确定这是翻译问题，而不是英文原文的问题 (英文原文的问题请移步至[英文文档仓库](https://github.com/vuejs/docs)讨论，相关结论我们会定期从英文版同步)\n          required: true\n        - label: 我确定这不是 Vue.js 使用方面的问题 (此类问题请在我们的[论坛](https://forum.vuejs.org/c/chinese/7)、[Discord 聊天室](https://chat.vuejs.org/) 或 [StackOverflow](https://stackoverflow.com/tags/vue.js) 上发帖求助)\n          required: true\n\n  - type: dropdown\n    id: issuetype\n    attributes:\n      label: 问题类型\n      description: 请选择本 issue 所涉及的问题类型。\n      options:\n        - 文档翻译相关\n        - 网络环境和本地化\n        - 译法讨论\n        - 流程优化\n        - 其他\n    validations:\n      required: true\n\n  - type: textarea\n    id: desc\n    attributes:\n      label: 问题描述\n      description: 请描述问题，**截图+有效链接更佳**。\n    validations:\n      required: true\n\n\n\n\n================================================\nFILE: .github/scripts/tag-alert-blocks.js\n================================================\n#!/usr/bin/env node\n\nconst { exec } = require('child_process')\n\n/**\n * Execute a command and return stdout as string.\n * @param {string} command\n * @returns {Promise<string>}\n */\nfunction run(command) {\n  return new Promise((resolve, reject) => {\n    exec(command, { encoding: 'utf-8' }, (error, stdout) =>\n      error ? reject(error) : resolve(stdout)\n    )\n  })\n}\n\nconst ALERT_BLOCK = /^\\+\\s*:::\\s?(\\w+)/m\n\nasync function isUsingAlertBlock(base = 'origin/cn') {\n  const result = await run(`git diff --name-only ${base}`)\n  const files = (\n    await Promise.all(\n      result\n        .trim()\n        .split(/\\r?\\n/)\n        .map(file =>\n          run(`git diff ${base} -- ${file}`)\n            .then(diff => ALERT_BLOCK.test(diff))\n            .then(usesAlertBlock => (usesAlertBlock ? file : ''))\n        )\n    )\n  ).filter(Boolean)\n\n  if (files.length) {\n    return true\n  }\n\n  return false\n}\n\nmodule.exports = { isUsingAlertBlock }\n\n\n\n================================================\nFILE: .github/workflows/automerge.yml\n================================================\nname: Dependabot auto-merge\non: pull_request\n\npermissions:\n  pull-requests: write\n  contents: write\n\njobs:\n  dependabot:\n    runs-on: ubuntu-latest\n    if: ${{ github.actor == 'dependabot[bot]' }}\n    steps:\n      - name: Dependabot metadata\n        id: metadata\n        uses: dependabot/fetch-metadata@v1.1.1\n        with:\n          github-token: '${{ secrets.GITHUB_TOKEN }}'\n      - name: Enable auto-merge for theme\n        if: ${{contains(steps.metadata.outputs.dependency-names, '@vue/theme') && steps.metadata.outputs.update-type != 'version-update:semver-major'}}\n        run: gh pr merge --auto --merge \"$PR_URL\"\n        env:\n          PR_URL: ${{github.event.pull_request.html_url}}\n          GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}\n\n\n\n================================================\nFILE: .github/workflows/autosync.yml\n================================================\nname: Auto Sync\n\non:\n  schedule:\n    - cron: '0 0 * * *' # At 00:00.  https://crontab.guru/\n  workflow_dispatch: # on button click\n\njobs:\n  sync:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: TobKed/github-forks-sync-action@master\n        with:\n          github_token: ${{ secrets.UPSTREAM_SYNC_TOKEN }}\n          upstream_repository: vuejs/docs\n          upstream_branch: main\n          target_repository: vuejs-translations/docs-zh-cn\n          target_branch: upstream\n          force: false\n          tags: false\n\n\n\n================================================\nFILE: .github/workflows/ci.yml\n================================================\nname: Node.js CI\n\non:\n  push:\n    branches-ignore: ['gh-pages']\n  pull_request:\n    branches: [main]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n      - uses: pnpm/action-setup@v2\n        with:\n          version: 8\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: 'pnpm'\n      - run: |\n          pnpm install\n          pnpm lint\n\n\n\n================================================\nFILE: .vitepress/config.ts\n================================================\nimport fs from 'fs'\nimport path from 'path'\nimport {\n  defineConfigWithTheme,\n  type HeadConfig,\n  type Plugin\n} from 'vitepress'\nimport type { Config as ThemeConfig } from '@vue/theme'\nimport llmstxt from 'vitepress-plugin-llms'\nimport baseConfig from '@vue/theme/config'\nimport { headerPlugin } from './headerMdPlugin'\n// import { textAdPlugin } from './textAdMdPlugin'\nimport {\n  groupIconMdPlugin,\n  groupIconVitePlugin\n} from 'vitepress-plugin-group-icons'\n\nconst nav: ThemeConfig['nav'] = [\n  {\n    text: '文档',\n    activeMatch: `^/(guide|style-guide|cookbook|examples)/`,\n    items: [\n      { text: '深度指南', link: '/guide/introduction' },\n      { text: '互动教程', link: '/tutorial/' },\n      { text: '示例', link: '/examples/' },\n      { text: '快速上手', link: '/guide/quick-start' },\n      // { text: '风格指南', link: '/style-guide/' },\n      { text: '术语表', link: '/glossary/' },\n      { text: '错误码参照表', link: '/error-reference/' },\n      {\n        text: 'Vue 2 文档',\n        link: 'https://v2.cn.vuejs.org'\n      },\n      {\n        text: '从 Vue 2 迁移',\n        link: 'https://v3-migration.vuejs.org/'\n      }\n    ]\n  },\n  {\n    text: 'API',\n    activeMatch: `^/api/`,\n    link: '/api/'\n  },\n  {\n    text: '演练场',\n    link: 'https://play.vuejs.org'\n  },\n  {\n    text: '生态系统',\n    activeMatch: `^/ecosystem/`,\n    items: [\n      {\n        text: '资源',\n        items: [\n          { text: '合作伙伴', link: '/partners/' },\n          { text: '主题', link: '/ecosystem/themes' },\n          { text: 'UI 组件', link: 'https://ui-libs.vercel.app/' },\n          {\n            text: '插件合集',\n            link: 'https://www.vue-plugins.org/'\n          },\n          {\n            text: '证书',\n            link: 'https://certificates.dev/vuejs/?ref=vuejs-nav'\n          },\n          { text: '找工作', link: 'https://vuejobs.com/?ref=vuejs' },\n          { text: 'T-Shirt 商店', link: 'https://vue.threadless.com/' }\n        ]\n      },\n      {\n        text: '官方库',\n        items: [\n          { text: 'Vue Router', link: 'https://router.vuejs.org/zh/' },\n          { text: 'Pinia', link: 'https://pinia.vuejs.org/zh/' },\n          { text: '工具链指南', link: '/guide/scaling-up/tooling.html' }\n        ]\n      },\n      {\n        text: '视频课程',\n        items: [\n          {\n            text: 'Vue Mastery',\n            link: 'https://www.vuemastery.com/courses/'\n          },\n          {\n            text: 'Vue School',\n            link: 'https://vueschool.io/?friend=vuejs&utm_source=Vuejs.org&utm_medium=Link&utm_content=Navbar%20Dropdown'\n          }\n        ]\n      },\n      {\n        text: '帮助',\n        items: [\n          {\n            text: 'Discord 聊天室',\n            link: 'https://discord.com/invite/HBherRA'\n          },\n          {\n            text: 'GitHub 论坛',\n            link: 'https://github.com/vuejs/core/discussions'\n          },\n          { text: 'DEV Community', link: 'https://dev.to/t/vue' }\n        ]\n      },\n      {\n        text: '动态',\n        items: [\n          { text: '博客', link: 'https://blog.vuejs.org/' },\n          { text: 'Twitter', link: 'https://x.com/vuejs' },\n          { text: '活动', link: 'https://events.vuejs.org/' },\n          { text: '新闻简报', link: '/ecosystem/newsletters' }\n        ]\n      }\n    ]\n  },\n  {\n    text: '关于',\n    activeMatch: `^/about/`,\n    items: [\n      { text: '常见问题', link: '/about/faq' },\n      { text: '团队', link: '/about/team' },\n      { text: '版本发布', link: '/about/releases' },\n      {\n        text: '社区指南',\n        link: '/about/community-guide'\n      },\n      { text: '行为规范', link: '/about/coc' },\n      { text: '隐私政策', link: '/about/privacy' },\n      {\n        text: '纪录片',\n        link: 'https://www.youtube.com/watch?v=OrxmtDw4pVI'\n      }\n    ]\n  },\n  {\n    text: '赞助',\n    link: '/sponsor/'\n  },\n  {\n    text: '合作伙伴',\n    activeMatch: `^/partners/`,\n    link: '/partners/'\n  }\n]\n\nexport const sidebar: ThemeConfig['sidebar'] = {\n  '/guide/': [\n    {\n      text: '开始',\n      items: [\n        { text: '简介', link: '/guide/introduction' },\n        {\n          text: '快速上手',\n          link: '/guide/quick-start'\n        }\n      ]\n    },\n    {\n      text: '基础',\n      items: [\n        {\n          text: '创建一个应用',\n          link: '/guide/essentials/application'\n        },\n        {\n          text: '模板语法',\n          link: '/guide/essentials/template-syntax'\n        },\n        {\n          text: '响应式基础',\n          link: '/guide/essentials/reactivity-fundamentals'\n        },\n        {\n          text: '计算属性',\n          link: '/guide/essentials/computed'\n        },\n        {\n          text: '类与样式绑定',\n          link: '/guide/essentials/class-and-style'\n        },\n        {\n          text: '条件渲染',\n          link: '/guide/essentials/conditional'\n        },\n        { text: '列表渲染', link: '/guide/essentials/list' },\n        {\n          text: '事件处理',\n          link: '/guide/essentials/event-handling'\n        },\n        { text: '表单输入绑定', link: '/guide/essentials/forms' },\n        { text: '侦听器', link: '/guide/essentials/watchers' },\n        { text: '模板引用', link: '/guide/essentials/template-refs' },\n        {\n          text: '组件基础',\n          link: '/guide/essentials/component-basics'\n        },\n        {\n          text: '生命周期',\n          link: '/guide/essentials/lifecycle'\n        }\n      ]\n    },\n    {\n      text: '深入组件',\n      items: [\n        {\n          text: '注册',\n          link: '/guide/components/registration'\n        },\n        { text: 'Props', link: '/guide/components/props' },\n        { text: '事件', link: '/guide/components/events' },\n        { text: '组件 v-model', link: '/guide/components/v-model' },\n        {\n          text: '透传 Attributes',\n          link: '/guide/components/attrs'\n        },\n        { text: '插槽', link: '/guide/components/slots' },\n        {\n          text: '依赖注入',\n          link: '/guide/components/provide-inject'\n        },\n        {\n          text: '异步组件',\n          link: '/guide/components/async'\n        }\n      ]\n    },\n    {\n      text: '逻辑复用',\n      items: [\n        {\n          text: '组合式函数',\n          link: '/guide/reusability/composables'\n        },\n        {\n          text: '自定义指令',\n          link: '/guide/reusability/custom-directives'\n        },\n        { text: '插件', link: '/guide/reusability/plugins' }\n      ]\n    },\n    {\n      text: '内置组件',\n      items: [\n        { text: 'Transition', link: '/guide/built-ins/transition' },\n        {\n          text: 'TransitionGroup',\n          link: '/guide/built-ins/transition-group'\n        },\n        { text: 'KeepAlive', link: '/guide/built-ins/keep-alive' },\n        { text: 'Teleport', link: '/guide/built-ins/teleport' },\n        { text: 'Suspense', link: '/guide/built-ins/suspense' }\n      ]\n    },\n    {\n      text: '应用规模化',\n      items: [\n        { text: '单文件组件', link: '/guide/scaling-up/sfc' },\n        { text: '工具链', link: '/guide/scaling-up/tooling' },\n        { text: '路由', link: '/guide/scaling-up/routing' },\n        {\n          text: '状态管理',\n          link: '/guide/scaling-up/state-management'\n        },\n        { text: '测试', link: '/guide/scaling-up/testing' },\n        {\n          text: '服务端渲染 (SSR)',\n          link: '/guide/scaling-up/ssr'\n        }\n      ]\n    },\n    {\n      text: '最佳实践',\n      items: [\n        {\n          text: '生产部署',\n          link: '/guide/best-practices/production-deployment'\n        },\n        {\n          text: '性能优化',\n          link: '/guide/best-practices/performance'\n        },\n        {\n          text: '无障碍访问',\n          link: '/guide/best-practices/accessibility'\n        },\n        {\n          text: '安全',\n          link: '/guide/best-practices/security'\n        }\n      ]\n    },\n    {\n      text: 'TypeScript',\n      items: [\n        { text: '总览', link: '/guide/typescript/overview' },\n        {\n          text: 'TS 与组合式 API',\n          link: '/guide/typescript/composition-api'\n        },\n        {\n          text: 'TS 与选项式 API',\n          link: '/guide/typescript/options-api'\n        }\n      ]\n    },\n    {\n      text: '进阶主题',\n      items: [\n        {\n          text: '使用 Vue 的多种方式',\n          link: '/guide/extras/ways-of-using-vue'\n        },\n        {\n          text: '组合式 API 常见问答',\n          link: '/guide/extras/composition-api-faq'\n        },\n        {\n          text: '深入响应式系统',\n          link: '/guide/extras/reactivity-in-depth'\n        },\n        {\n          text: '渲染机制',\n          link: '/guide/extras/rendering-mechanism'\n        },\n        {\n          text: '渲染函数 & JSX',\n          link: '/guide/extras/render-function'\n        },\n        {\n          text: 'Vue 与 Web Components',\n          link: '/guide/extras/web-components'\n        },\n        {\n          text: '动画技巧',\n          link: '/guide/extras/animation'\n        }\n        // {\n        //   text: '为 Vue 构建一个库',\n        //   link: '/guide/extras/building-a-library'\n        // },\n        // {\n        //   text: 'Vue for React 开发者',\n        //   link: '/guide/extras/vue-for-react-devs'\n        // }\n      ]\n    }\n  ],\n  '/api/': [\n    {\n      text: '全局 API',\n      items: [\n        { text: '应用实例', link: '/api/application' },\n        {\n          text: '通用',\n          link: '/api/general'\n        }\n      ]\n    },\n    {\n      text: '组合式 API',\n      items: [\n        { text: 'setup()', link: '/api/composition-api-setup' },\n        {\n          text: '响应式: 核心',\n          link: '/api/reactivity-core'\n        },\n        {\n          text: '响应式: 工具',\n          link: '/api/reactivity-utilities'\n        },\n        {\n          text: '响应式: 进阶',\n          link: '/api/reactivity-advanced'\n        },\n        {\n          text: '生命周期钩子',\n          link: '/api/composition-api-lifecycle'\n        },\n        {\n          text: '依赖注入',\n          link: '/api/composition-api-dependency-injection'\n        },\n        {\n          text: '辅助',\n          link: '/api/composition-api-helpers'\n        }\n      ]\n    },\n    {\n      text: '选项式 API',\n      items: [\n        { text: '状态选项', link: '/api/options-state' },\n        { text: '渲染选项', link: '/api/options-rendering' },\n        {\n          text: '生命周期选项',\n          link: '/api/options-lifecycle'\n        },\n        {\n          text: '组合选项',\n          link: '/api/options-composition'\n        },\n        { text: '其他杂项', link: '/api/options-misc' },\n        {\n          text: '组件实例',\n          link: '/api/component-instance'\n        }\n      ]\n    },\n    {\n      text: '内置内容',\n      items: [\n        { text: '指令', link: '/api/built-in-directives' },\n        { text: '组件', link: '/api/built-in-components' },\n        {\n          text: '特殊元素',\n          link: '/api/built-in-special-elements'\n        },\n        {\n          text: '特殊 Attributes',\n          link: '/api/built-in-special-attributes'\n        }\n      ]\n    },\n    {\n      text: '单文件组件',\n      items: [\n        { text: '语法定义', link: '/api/sfc-spec' },\n        { text: '<script setup>', link: '/api/sfc-script-setup' },\n        { text: 'CSS 功能', link: '/api/sfc-css-features' }\n      ]\n    },\n    {\n      text: '进阶 API',\n      items: [\n        { text: '自定义元素', link: '/api/custom-elements' },\n        { text: '渲染函数', link: '/api/render-function' },\n        { text: '服务端渲染', link: '/api/ssr' },\n        { text: 'TypeScript 工具类型', link: '/api/utility-types' },\n        { text: '自定义渲染', link: '/api/custom-renderer' },\n        { text: '编译时标志', link: '/api/compile-time-flags' }\n      ]\n    }\n  ],\n  '/examples/': [\n    {\n      text: '基础',\n      items: [\n        {\n          text: '你好，世界',\n          link: '/examples/#hello-world'\n        },\n        {\n          text: '处理用户输入',\n          link: '/examples/#handling-input'\n        },\n        {\n          text: 'Attribute 绑定',\n          link: '/examples/#attribute-bindings'\n        },\n        {\n          text: '条件与循环',\n          link: '/examples/#conditionals-and-loops'\n        },\n        {\n          text: '表单绑定',\n          link: '/examples/#form-bindings'\n        },\n        {\n          text: '简单组件',\n          link: '/examples/#simple-component'\n        }\n      ]\n    },\n    {\n      text: '实战',\n      items: [\n        {\n          text: 'Markdown 编辑器',\n          link: '/examples/#markdown'\n        },\n        {\n          text: '获取数据',\n          link: '/examples/#fetching-data'\n        },\n        {\n          text: '带有排序和过滤器的网格',\n          link: '/examples/#grid'\n        },\n        {\n          text: '树状视图',\n          link: '/examples/#tree'\n        },\n        {\n          text: 'SVG 图像',\n          link: '/examples/#svg'\n        },\n        {\n          text: '带过渡动效的模态框',\n          link: '/examples/#modal'\n        },\n        {\n          text: '带过渡动效的列表',\n          link: '/examples/#list-transition'\n        }\n      ]\n    },\n    {\n      // https://eugenkiss.github.io/7guis/\n      text: '7 GUIs',\n      items: [\n        {\n          text: '计数器',\n          link: '/examples/#counter'\n        },\n        {\n          text: '温度转换器',\n          link: '/examples/#temperature-converter'\n        },\n        {\n          text: '机票预订',\n          link: '/examples/#flight-booker'\n        },\n        {\n          text: '计时器',\n          link: '/examples/#timer'\n        },\n        {\n          text: 'CRUD',\n          link: '/examples/#crud'\n        },\n        {\n          text: '画圆',\n          link: '/examples/#circle-drawer'\n        },\n        {\n          text: '单元格',\n          link: '/examples/#cells'\n        }\n      ]\n    }\n  ],\n  '/style-guide/': [\n    {\n      text: 'Style Guide',\n      items: [\n        {\n          text: 'Overview',\n          link: '/style-guide/'\n        },\n        {\n          text: 'A - Essential',\n          link: '/style-guide/rules-essential'\n        },\n        {\n          text: 'B - Strongly Recommended',\n          link: '/style-guide/rules-strongly-recommended'\n        },\n        {\n          text: 'C - Recommended',\n          link: '/style-guide/rules-recommended'\n        },\n        {\n          text: 'D - Use with Caution',\n          link: '/style-guide/rules-use-with-caution'\n        }\n      ]\n    }\n  ]\n}\n\nconst i18n: ThemeConfig['i18n'] = {\n  search: '搜索',\n  menu: '菜单',\n  toc: '本页目录',\n  returnToTop: '返回顶部',\n  appearance: '外观',\n  previous: '前一篇',\n  next: '下一篇',\n  pageNotFound: '页面未找到',\n  deadLink: {\n    before: '你打开了一个不存在的链接：',\n    after: '。'\n  },\n  deadLinkReport: {\n    before: '不介意的话请提交到',\n    link: '这里',\n    after: '，我们会跟进修复。'\n  },\n  footerLicense: {\n    before: '',\n    after: ''\n  },\n  ariaAnnouncer: {\n    before: '',\n    after: '已经加载完毕'\n  },\n  ariaDarkMode: '切换深色模式',\n  ariaSkipToContent: '直接跳到内容',\n  ariaToC: '当前页面的目录',\n  ariaMainNav: '主导航',\n  ariaMobileNav: '移动版导航',\n  ariaSidebarNav: '侧边栏导航'\n}\n\nfunction inlineScript(file: string): HeadConfig {\n  return [\n    'script',\n    {},\n    fs.readFileSync(\n      path.resolve(__dirname, `./inlined-scripts/${file}`),\n      'utf-8'\n    )\n  ]\n}\n\nexport default defineConfigWithTheme<ThemeConfig>({\n  extends: baseConfig,\n\n  sitemap: {\n    hostname: 'https://cn.vuejs.org'\n  },\n\n  lang: 'zh-CN',\n  title: 'Vue.js',\n  description: 'Vue.js - 渐进式的 JavaScript 框架',\n  srcDir: 'src',\n  srcExclude: ['tutorial/**/description.md'],\n\n  head: [\n    ['meta', { name: 'theme-color', content: '#3c8772' }],\n    ['meta', { property: 'og:url', content: 'https://vuejs.org/' }],\n    ['meta', { property: 'og:type', content: 'website' }],\n    ['meta', { property: 'og:title', content: 'Vue.js' }],\n    [\n      'meta',\n      {\n        property: 'og:description',\n        content: 'Vue.js - 渐进式的 JavaScript 框架'\n      }\n    ],\n    [\n      'meta',\n      {\n        property: 'og:image',\n        content: 'https://vuejs.org/images/logo.png'\n      }\n    ],\n    ['meta', { name: 'twitter:site', content: '@vuejs' }],\n    ['meta', { name: 'twitter:card', content: 'summary' }],\n    [\n      'link',\n      {\n        rel: 'preconnect',\n        href: 'https://automation.vuejs.org'\n      }\n    ],\n    inlineScript('restorePreference.js'),\n    inlineScript('uwu.js'),\n    [\n      'script',\n      {\n        src: 'https://cdn.usefathom.com/script.js',\n        'data-site': 'ZPMMDSYA',\n        'data-spa': 'auto',\n        defer: ''\n      }\n    ],\n    [\n      'script',\n      {\n        src: 'https://media.bitterbrains.com/main.js?from=vuejs&type=top',\n        async: 'true'\n      }\n    ]\n  ],\n\n  themeConfig: {\n    nav,\n    sidebar,\n    i18n,\n\n    localeLinks: [\n      {\n        link: 'https://vuejs.org',\n        text: 'English',\n        repo: 'https://github.com/vuejs/docs'\n      },\n      {\n        link: 'https://ja.vuejs.org',\n        text: '日本語',\n        repo: 'https://github.com/vuejs-translations/docs-ja'\n      },\n      {\n        link: 'https://ua.vuejs.org',\n        text: 'Українська',\n        repo: 'https://github.com/vuejs-translations/docs-uk'\n      },\n      {\n        link: 'https://fr.vuejs.org',\n        text: 'Français',\n        repo: 'https://github.com/vuejs-translations/docs-fr'\n      },\n      {\n        link: 'https://ko.vuejs.org',\n        text: '한국어',\n        repo: 'https://github.com/vuejs-translations/docs-ko'\n      },\n      {\n        link: 'https://pt.vuejs.org',\n        text: 'Português',\n        repo: 'https://github.com/vuejs-translations/docs-pt'\n      },\n      {\n        link: 'https://bn.vuejs.org',\n        text: 'বাংলা',\n        repo: 'https://github.com/vuejs-translations/docs-bn'\n      },\n      {\n        link: 'https://it.vuejs.org',\n        text: 'Italiano',\n        repo: 'https://github.com/vuejs-translations/docs-it'\n      },\n      {\n        link: 'https://fa.vuejs.org',\n        text: 'فارسی',\n        repo: 'https://github.com/vuejs-translations/docs-fa'\n      },\n      {\n        link: 'https://ru.vuejs.org',\n        text: 'Русский',\n        repo: 'https://github.com/vuejs-translations/docs-ru'\n      },\n      {\n        link: 'https://cs.vuejs.org',\n        text: 'Čeština',\n        repo: 'https://github.com/vuejs-translations/docs-cs'\n      },\n      {\n        link: 'https://zh-hk.vuejs.org',\n        text: '繁體中文',\n        repo: 'https://github.com/vuejs-translations/docs-zh-hk'\n      },\n      {\n        link: 'https://pl.vuejs.org',\n        text: 'Polski',\n        repo: 'https://github.com/vuejs-translations/docs-pl'\n      },\n      {\n        link: '/translations/',\n        text: '帮助我们翻译！',\n        isTranslationsDesc: true\n      }\n    ],\n\n    algolia: {\n      indexName: 'vuejs_cn2',\n      appId: 'UURH1MHAF7',\n      apiKey: 'c23eb8e7895f42daeaf2bf6f63eb4bf6',\n      searchParameters: {\n        facetFilters: ['version:v3']\n      },\n      placeholder: '搜索文档',\n      translations: {\n        button: {\n          buttonText: '搜索'\n        },\n        modal: {\n          searchBox: {\n            resetButtonTitle: '清除查询条件',\n            resetButtonAriaLabel: '清除查询条件',\n            cancelButtonText: '取消',\n            cancelButtonAriaLabel: '取消'\n          },\n          startScreen: {\n            recentSearchesTitle: '搜索历史',\n            noRecentSearchesText: '没有搜索历史',\n            saveRecentSearchButtonTitle: '保存到搜索历史',\n            removeRecentSearchButtonTitle: '从搜索历史中移除',\n            favoriteSearchesTitle: '收藏',\n            removeFavoriteSearchButtonTitle: '从收藏中移除'\n          },\n          errorScreen: {\n            titleText: '无法获取结果',\n            helpText: '你可能需要检查你的网络连接'\n          },\n          footer: {\n            selectText: '选择',\n            navigateText: '切换',\n            closeText: '关闭',\n            searchByText: '搜索供应商'\n          },\n          noResultsScreen: {\n            noResultsText: '无法找到相关结果',\n            suggestedQueryText: '你可以尝试查询',\n            reportMissingResultsText: '你认为这个查询应该有结果？',\n            reportMissingResultsLinkText: '向我们反馈'\n          }\n        }\n      }\n    },\n\n    // carbonAds: {\n    //   code: 'CEBDT27Y',\n    //   placement: 'vuejsorg'\n    // },\n\n    socialLinks: [\n      { icon: 'github', link: 'https://github.com/vuejs/' },\n      { icon: 'twitter', link: 'https://x.com/vuejs' },\n      { icon: 'discord', link: 'https://discord.com/invite/vue' }\n    ],\n\n    editLink: {\n      repo: 'vuejs-translations/docs-zh-cn',\n      text: '在 GitHub 上编辑此页'\n    },\n\n    footer: {\n      license: {\n        text: '版权声明',\n        link: 'https://github.com/vuejs-translations/docs-zh-cn#%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E'\n      },\n      copyright:\n        '本中文文档采用 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议  (CC BY-NC-SA 4.0) 进行许可。'\n    }\n  },\n\n  markdown: {\n    theme: 'github-dark',\n    config(md) {\n      md.use(headerPlugin).use(groupIconMdPlugin)\n      // .use(textAdPlugin)\n    }\n  },\n\n  vite: {\n    define: {\n      __VUE_OPTIONS_API__: false\n    },\n    optimizeDeps: {\n      include: ['gsap', 'dynamics.js'],\n      exclude: ['@vue/repl']\n    },\n    // @ts-ignore\n    ssr: {\n      external: ['@vue/repl']\n    },\n    server: {\n      host: true,\n      fs: {\n        // for when developing with locally linked theme\n        allow: ['../..']\n      }\n    },\n    build: {\n      chunkSizeWarningLimit: Infinity\n    },\n    json: {\n      stringify: true\n    },\n    plugins: [\n      llmstxt({\n        ignoreFiles: [\n          'about/team/**/*',\n          'about/team.md',\n          'about/privacy.md',\n          'about/coc.md',\n          'developers/**/*',\n          'ecosystem/themes.md',\n          'examples/**/*',\n          'partners/**/*',\n          'sponsor/**/*',\n          'index.md'\n        ],\n        customLLMsTxtTemplate: `\\\n# Vue.js\n\nVue.js - The Progressive JavaScript Framework\n\n## Table of Contents\n\n{toc}`\n      }) as Plugin,\n      groupIconVitePlugin({\n        customIcon: {\n          cypress: 'vscode-icons:file-type-cypress',\n          'testing library': 'logos:testing-library'\n        }\n      }) as Plugin\n    ]\n  }\n})\n\n\n\n================================================\nFILE: .vitepress/env.d.ts\n================================================\n/// <reference types=\"vitepress/client\" />\n/// <reference types=\"vue/macros-global\" />\n\ndeclare module '@vue/theme/config' {\n  import { UserConfig } from 'vitepress'\n  const config: () => Promise<UserConfig>\n  export default config\n}\n\ndeclare module '@vue/theme/highlight' {\n  const createHighlighter: () => Promise<(input: string) => string>\n  export default createHighlighter\n}\n\n\n\n================================================\nFILE: .vitepress/headerMdPlugin.ts\n================================================\n/**\n * A markdown-it plugin to support custom header metadata\n * Headers that end with * are Options API only\n * Headers that end with ** are Composition API only\n * This plugin strips the markers and augments the extracted header data,\n * which can be then used by the theme to filter headers.\n *\n * TODO: we will likely also need special syntax for preserving the same anchor\n * links across translations similar to the one at\n * https://github.com/vitejs/docs-cn/tree/main/.vitepress/markdown-it-custom-anchor\n */\n\nimport MarkdownIt from 'markdown-it'\nimport { Header } from 'vitepress'\n\nexport interface AugmentedHeader extends Header {\n  compositionOnly?: boolean\n  optionsOnly?: boolean\n}\n\nexport const headerPlugin = (md: MarkdownIt) => {\n  md.renderer.rules.heading_open = (tokens, i, options, env, self) => {\n    for (const child of tokens[i + 1].children!) {\n      if (child.type === 'text' && child.content.endsWith('*')) {\n        child.content = child.content.replace(/\\s*\\*+$/, '')\n      }\n    }\n    return self.renderToken(tokens, i, options)\n  }\n\n  const render = md.render\n  md.render = (content, env) => {\n    const res = render(content, env)\n\n    if (env && env.headers) {\n      processHeaders(env.headers)\n    }\n\n    return res\n  }\n}\n\nfunction processHeaders(headers: AugmentedHeader[]) {\n  for (const h of headers) {\n    if (h.title.endsWith('*')) {\n      if (h.title.endsWith('**')) {\n        h.compositionOnly = true\n      } else {\n        h.optionsOnly = true\n      }\n      h.title = h.title.replace(/\\s*\\*+$/, '')\n    }\n    if (h.children) {\n      processHeaders(h.children)\n    }\n  }\n}\n\n\n\n================================================\nFILE: .vitepress/textAdMdPlugin.ts\n================================================\nimport MarkdownIt from 'markdown-it'\n\nconst excludedPages = [\n  'guide/introduction.md',\n  // 'guide/quick-start.md',\n  // 'guide/essentials/computed.md',\n  // 'guide/essentials/conditional.md',\n  // 'guide/essentials/list.md',\n  // 'guide/essentials/event-handling.md',\n  // 'guide/essentials/forms.md',\n  // 'guide/components/registration.md',\n  // 'guide/components/props.md',\n  // 'guide/components/events.md',\n  // 'guide/components/slots.md',\n  // 'guide/built-ins/teleport.md',\n  'about/faq.md',\n  'about/team.md',\n  'about/releases.md',\n  'about/community-guide.md',\n  'about/coc.md',\n  'sponsor/index.md',\n  'translations/index.md'\n]\n\nexport const textAdPlugin = (md: MarkdownIt) => {\n  md.renderer.rules.heading_close = (tokens, i, options, env, self) => {\n    const relativePath = env.relativePath\n    const renderedContent = self.renderToken(tokens, i, options)\n\n    return excludedPages.includes(relativePath)\n      ? renderedContent\n      : renderedContent.replace(/<\\/h1>/, '</h1><TextAd/>')\n  }\n}\n\n\n\n================================================\nFILE: .vitepress/inlined-scripts/restorePreference.js\n================================================\n;(() => {\n  const restore = (key, cls, def = false) => {\n    const saved = localStorage.getItem(key)\n    if (saved ? saved !== 'false' : def) {\n      document.documentElement.classList.add(cls)\n    }\n  }\n  restore('vue-docs-prefer-composition', 'prefer-composition', true)\n  restore('vue-docs-prefer-sfc', 'prefer-sfc', true)\n\n  // window.__VUE_BANNER_ID__ = ''\n  // restore(`vue-docs-banner-${__VUE_BANNER_ID__}`, 'banner-dismissed')\n})()\n\n\n\n================================================\nFILE: .vitepress/inlined-scripts/uwu.js\n================================================\nif (location.search.includes('?uwu')) {\n  document.documentElement.classList.add('uwu')\n}\n\n\n\n================================================\nFILE: .vitepress/theme/index.ts\n================================================\nimport './styles/index.css'\nimport { h, App } from 'vue'\nimport { VPTheme } from '@vue/theme'\nimport PreferenceSwitch from './components/PreferenceSwitch.vue'\nimport SecurityUpdateBtn from './components/SecurityUpdateBtn.vue'\nimport {\n  preferComposition,\n  preferSFC,\n  filterHeadersByPreference\n} from './components/preferences'\nimport SponsorsAside from './components/SponsorsAside.vue'\n// import VueSchoolLink from './components/VueSchoolLink.vue'\nimport ScrimbaLink from './components/ScrimbaLink.vue'\nimport WwAds from './components/WwAds.vue'\n// import Banner from './components/Banner.vue'\n// import TextAd from './components/TextAd.vue'\n\nimport 'vitepress/dist/client/theme-default/styles/components/vp-code-group.css'\nimport 'virtual:group-icons.css'\n\nexport default Object.assign({}, VPTheme, {\n  Layout: () => {\n    // @ts-ignore\n    return h(VPTheme.Layout, null, {\n      // banner: () => h(Banner),\n      'sidebar-top': () => h(PreferenceSwitch),\n      'sidebar-bottom': () => h(SecurityUpdateBtn),\n      'aside-mid': () => h(SponsorsAside),\n      'aside-bottom': () => h(WwAds)\n    })\n  },\n  enhanceApp({ app }: { app: App }) {\n    app.provide('prefer-composition', preferComposition)\n    app.provide('prefer-sfc', preferSFC)\n    app.provide('filter-headers', filterHeadersByPreference)\n    // app.component('VueSchoolLink', VueSchoolLink)\n    app.component('ScrimbaLink', ScrimbaLink)\n    // app.component('TextAd', TextAd)\n  }\n})\n\n\n\n================================================\nFILE: .vitepress/theme/components/Banner.vue\n================================================\n<script setup>\n/**\n * Adding a new banner:\n * 1. uncomment the banner slot in ../index.ts\n * 2. uncomment and update BANNER_ID in ../../inlined-scripts/restorePreferences.ts\n * 3. update --vt-banner-height if necessary\n */\nimport { ref } from 'vue'\nimport { VTIconPlus } from '@vue/theme'\n\nconst open = ref(true)\n\n/**\n * Call this if the banner is dismissible\n */\nfunction dismiss() {\n  open.value = false\n  document.documentElement.classList.add('banner-dismissed')\n  localStorage.setItem(`vue-docs-banner-${__VUE_BANNER_ID__}`, 'true')\n}\n</script>\n\n<template>\n  <div class=\"banner\" v-if=\"open\">\n    <a target=\"_blank\"></a>\n    <button @click=\"dismiss\">\n      <VTIconPlus class=\"close\" />\n    </button>\n  </div>\n</template>\n\n<style>\nhtml:not(.banner-dismissed) {\n  --vt-banner-height: 30px;\n}\n</style>\n\n<style scoped>\n.banner {\n  position: fixed;\n  z-index: var(--vp-z-index-banner);\n  box-sizing: border-box;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: var(--vt-banner-height);\n  line-height: var(--vt-banner-height);\n  text-align: center;\n  font-size: 13px;\n  font-weight: 600;\n  color: #fff;\n  background-color: var(--vt-c-green);\n  background: linear-gradient(\n    90deg,\n    rgba(66, 184, 131, 1) 0%,\n    rgba(39, 179, 137, 1) 19%,\n    rgba(100, 126, 255, 1) 100%\n  );\n}\n\n.banner-dismissed .banner {\n  display: none;\n}\n\na:hover {\n  text-decoration: underline;\n}\n\nbutton {\n  position: absolute;\n  right: 0;\n  top: 0;\n  padding: 5px;\n}\n\n.close {\n  width: 20px;\n  height: 20px;\n  fill: #fff;\n  transform: rotate(45deg);\n}\n/*\n@media (max-width: 720px) {\n  a > span {\n    display: none;\n  }\n} */\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/CallToActionSection.vue\n================================================\n<script setup lang=\"ts\">\nwithDefaults(defineProps<{\n  title?: string\n  description?: string\n  link?: string\n  linkText?: string\n  showDivider?: boolean\n}>(), {\n  showDivider: true\n})\n</script>\n\n<template>\n  <section class=\"cta-section\">\n    <div v-if=\"showDivider\" class=\"cta-divider\"></div>\n    <div class=\"cta-content\">\n      <h2 v-if=\"title\" class=\"cta-title\">{{ title }}</h2>\n      <p v-if=\"description\" class=\"cta-description\">{{ description }}</p>\n      <a v-if=\"link\" :href=\"link\" target=\"_blank\" class=\"cta-link\">{{ linkText }}</a>\n      <slot></slot>\n    </div>\n  </section>\n</template>\n\n<style scoped>\n.cta-section {\n  text-align: center;\n  max-width: 688px;\n  margin: 0 auto;\n}\n\n.cta-divider {\n  width: 100px;\n  margin: 0 auto;\n  border-top: 1px solid var(--vt-c-divider-light);\n}\n\n.cta-content {\n  padding: 28px 28px 96px;\n}\n\n.cta-title {\n  font-size: 34px;\n  font-weight: 600;\n  letter-spacing: -0.5px;\n  line-height: 1.2;\n  margin: 0.5em 0 1em;\n}\n\n.cta-description {\n  color: var(--vt-c-text-2);\n}\n\n.cta-link {\n  margin-top: 2em;\n  display: inline-block;\n  padding: 12px 24px;\n  background-color: var(--vt-c-bg-mute);\n  color: var(--vt-c-text-code);\n  font-weight: 600;\n  border-radius: 6px;\n  text-decoration: none;\n  transition: background-color 0.5s, color 0.5s;\n}\n\n.cta-link:hover {\n  background-color: var(--vt-c-gray-light-4);\n}\n\n.dark .cta-link:hover {\n  background-color: var(--vt-c-gray-dark-3);\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/CardList.vue\n================================================\n<script setup lang=\"ts\">\nimport { computed, onMounted, ref, shallowRef } from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    items: Array<any>\n    filter?: (item: any) => boolean\n    cardComponent: any\n    showLinkToAll?: boolean\n    shuffleItems?: boolean\n    browseLinkText?: string\n    browseLinkUrl?: string\n    splitBy?: string\n  }>(),\n  {\n    showLinkToAll: false,\n    shuffleItems: false,\n    splitBy: 'platinum'\n  }\n)\n\nconst isMounted = ref(false)\nconst items = shallowRef([...props.items])\n\nconst filteredItems = computed(() =>\n  props.filter ? items.value.filter(props.filter) : items.value\n)\n\nonMounted(() => {\n  isMounted.value = true\n  items.value = processItems([...items.value], props.splitBy, props.shuffleItems)\n})\n\nfunction processItems(items: Array<any>, splitBy: string, shouldShuffle: boolean) {\n  const splitItems = items.filter(item => item[splitBy])\n  const otherItems = items.filter(item => !item[splitBy])\n\n  if (shouldShuffle) {\n    shuffleArray(splitItems)\n    shuffleArray(otherItems)\n  }\n\n  return [...splitItems, ...otherItems]\n}\n\nfunction shuffleArray(array: Array<any>) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1)); // don't remove semicolon\n    [array[i], array[j]] = [array[j], array[i]]\n  }\n}\n</script>\n\n<template>\n  <div v-show=\"isMounted\" class=\"card-list\">\n    <!-- to skip SSG since the partners are shuffled -->\n    <ClientOnly>\n      <component\n        :is=\"cardComponent\"\n        v-for=\"item in filteredItems\"\n        :key=\"item.id || item.name\"\n        :data=\"item\"\n      />\n    </ClientOnly>\n\n    <a\n      v-if=\"showLinkToAll && filteredItems.length % 2\"\n      :href=\"browseLinkUrl\"\n      class=\"browse-all-link\"\n    >\n      {{ browseLinkText }}\n    </a>\n  </div>\n</template>\n\n<style scoped>\n.card-list {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-between;\n}\n\n.browse-all-link {\n  display: block;\n  width: 48.5%;\n  margin-bottom: 36px;\n  padding-top: 240px;\n  font-size: 1.2em;\n  text-align: center;\n  color: var(--vt-c-text-2);\n  border: 1px solid var(--vt-c-divider-light);\n  border-radius: 4px;\n  transition: color 0.5s ease;\n}\n\n.browse-all-link:hover {\n  color: var(--vt-c-text-1);\n}\n\n@media (max-width: 768px) {\n  .browse-all-link {\n    display: none;\n  }\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/Home.vue\n================================================\n<script setup lang=\"ts\">\nimport { onMounted } from 'vue'\nimport SiteMap from './SiteMap.vue'\n// import NewsLetter from './NewsLetter.vue'\nimport { load, data, base } from './sponsors'\nimport SponsorsGroup from './SponsorsGroup.vue'\n// NOTE: hide the home video\n// https://github.com/vuejs-translations/docs-zh-cn/issues/177\n// import VueMasteryModal from './VueMasteryModal.vue'\n\nonMounted(load)\n</script>\n\n<template>\n  <section id=\"hero\">\n    <img id=\"uwu\" alt=\"Vue.js Kawaii Logo by @icarusgkx\" />\n    <h1 class=\"tagline\">\n      <span class=\"accent\">渐进式</span>\n      <br />JavaScript 框架\n    </h1>\n    <p class=\"description\">\n      易学易用，性能出色，适用场景丰富的 Web 前端框架。\n    </p>\n    <p class=\"actions\">\n      <!-- NOTE: hide the home video -->\n      <!-- <VueMasteryModal /> -->\n      <a class=\"get-started\" href=\"/guide/introduction.html\">\n        快速上手\n        <svg\n          class=\"icon\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          width=\"10\"\n          height=\"10\"\n          viewBox=\"0 0 24 24\"\n        >\n          <path\n            d=\"M13.025 1l-2.847 2.828 6.176 6.176h-16.354v3.992h16.354l-6.176 6.176 2.847 2.828 10.975-11z\"\n          />\n        </svg>\n      </a>\n      <a class=\"setup\" href=\"/guide/quick-start.html\">安装</a>\n      <a class=\"security\" href=\"https://v2.cn.vuejs.org/eol/\" target=\"_blank\">\n        获取针对 Vue 2 的安全更新\n        <svg\n          class=\"icon\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          viewBox=\"0 0 512 512\"\n        >\n          <path\n            d=\"M320 0c-17.7 0-32 14.3-32 32s14.3 32 32 32h82.7L201.4 265.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L448 109.3V192c0 17.7 14.3 32 32 32s32-14.3 32-32V32c0-17.7-14.3-32-32-32H320zM80 32C35.8 32 0 67.8 0 112V432c0 44.2 35.8 80 80 80H400c44.2 0 80-35.8 80-80V320c0-17.7-14.3-32-32-32s-32 14.3-32 32V432c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16H192c17.7 0 32-14.3 32-32s-14.3-32-32-32H80z\"\n          />\n        </svg>\n      </a>\n    </p>\n  </section>\n\n  <section v-if=\"data && data.platinum_china\" id=\"special-sponsor\">\n    <h3>中国区铂金赞助</h3>\n    <div id=\"special-sponsor-container\">\n      <template v-for=\"{ url, url_cn, img, name, height, description } of data.platinum_china\"\n      >\n        <a class=\"logo\" :href=\"url_cn || url\" target=\"_blank\" rel=\"sponsored noopener\">\n          <picture v-if=\"img.endsWith('png')\">\n            <source\n              type=\"image/avif\"\n              :srcset=\"`${base}/images/${img.replace(/\\.png$/,'.avif')}`\"\n            />\n            <img :src=\"`${base}/images/${img}`\" :alt=\"name\" :style=\"{ height: height || '50px' }\" />\n          </picture>\n          <img\n            width=\"168\"\n            height=\"42\"\n            v-else\n            :src=\"`${base}/images/${img}`\"\n            :alt=\"name\"\n          />\n        </a>\n        <span>{{ description }}</span>\n      </template>\n    </div>\n  </section>\n  <section v-else id=\"special-spsr\">\n    <span>\n      <a href=\"/sponsor/#tier-benefits\">\n        中国区铂金赞助位现已空缺-立即咨询\n      </a>\n    </span>\n  </section>\n\n  <section id=\"highlights\" class=\"vt-box-container\">\n    <div class=\"vt-box\">\n      <h2>易学易用</h2>\n      <p>\n        基于标准 HTML、CSS 和 JavaScript 构建，提供容易上手的 API\n        和一流的文档。\n      </p>\n    </div>\n    <div class=\"vt-box\">\n      <h2>性能出色</h2>\n      <p>经过编译器优化、完全响应式的渲染系统，几乎不需要手动优化。</p>\n    </div>\n    <div class=\"vt-box\">\n      <h2>灵活多变</h2>\n      <p>\n        丰富的、可渐进式集成的生态系统，可以根据应用规模在库和框架间切换自如。\n      </p>\n    </div>\n  </section>\n\n  <section id=\"spsrs\">\n    <h2>Platinum Sponsors</h2>\n    <SponsorsGroup tier=\"platinum\" placement=\"landing\" />\n    <h2>Gold Sponsors</h2>\n    <SponsorsGroup tier=\"gold\" placement=\"landing\" />\n  </section>\n\n  <SiteMap />\n  <!-- <NewsLetter /> -->\n</template>\n\n<style scoped>\nsection {\n  padding: 42px 32px;\n}\n\n#hero {\n  padding: 96px 32px;\n  text-align: center;\n}\n\n.tagline {\n  font-size: 76px;\n  line-height: 1.25;\n  font-weight: 900;\n  letter-spacing: -1.5px;\n  max-width: 960px;\n  margin: 0px auto;\n}\n\nhtml:not(.dark) .accent,\n.dark .tagline {\n  background: -webkit-linear-gradient(315deg, #42d392 25%, #647eff);\n  background-clip: text;\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n}\n\n.description {\n  max-width: 960px;\n  line-height: 1.5;\n  color: var(--vt-c-text-2);\n  transition: color 0.5s;\n  font-size: 22px;\n  margin: 24px auto 40px;\n}\n\n.actions a {\n  font-size: 16px;\n  display: inline-block;\n  background-color: var(--vt-c-bg-mute);\n  padding: 8px 18px;\n  font-weight: 500;\n  border-radius: 8px;\n  transition: background-color 0.5s, color 0.5s;\n}\n\n.actions .security {\n  background: linear-gradient(var(--vt-c-bg-mute), var(--vt-c-bg-mute)) padding-box,\n    linear-gradient(45deg, #42d392, #647eff) border-box;\n  border: 2px solid transparent;\n}\n\n.actions .security:hover {\n  background: linear-gradient(var(--vt-c-gray-light-4), var(--vt-c-gray-light-4)) padding-box,\n    linear-gradient(45deg, #42d392, #647eff) border-box;\n}\n\n.dark .actions .security:hover {\n  background: linear-gradient(var(--vt-c-gray-dark-3), var(--vt-c-gray-dark-3)) padding-box,\n    linear-gradient(45deg, #42d392, #647eff) border-box;\n}\n\n.actions .security .icon {\n  width: 12px;\n  height: 12px;\n  margin-left: 4px;\n}\n\n.actions .get-started,\n.actions .setup {\n  margin-right: 18px;\n}\n\n.actions .icon {\n  display: inline;\n  position: relative;\n  top: -1px;\n  margin-left: 2px;\n  fill: currentColor;\n  transition: transform 0.2s;\n}\n\n.actions .get-started:hover {\n  transition-duration: 0.2s;\n}\n\n.actions .get-started:hover .icon {\n  transform: translateX(2px);\n}\n\n.actions .get-started,\n.actions .setup,\n.actions .security {\n  color: var(--vt-c-text-code);\n}\n\n.actions .get-started:hover,\n.actions .setup:hover,\n.actions .security:hover {\n  background-color: var(--vt-c-gray-light-4);\n  transition-duration: 0.2s;\n}\n\n.dark .actions .get-started:hover,\n.dark .actions .setup:hover,\n.dark .actions .security:hover {\n  background-color: var(--vt-c-gray-dark-3);\n}\n\n/* NOTE: via #vuemastery-action in VueMasteryModal.vue */\n\n.actions .get-started {\n  font-size: 16px;\n  display: inline-block;\n  border-radius: 8px;\n  transition: background-color 0.5s, color 0.5s;\n  position: relative;\n  font-weight: 600;\n  background-color: var(--vt-c-green);\n  color: #fff;\n  margin-right: 18px;\n  padding: 8px 1em;\n}\n\n.dark .actions .get-started {\n  color: var(--vt-c-indigo);\n}\n\n.actions .get-started:hover {\n  background-color: var(--vt-c-green-dark);\n  transition-duration: 0.2s;\n}\n\n.dark .actions .get-started:hover {\n  background-color: var(--vt-c-green-light);\n}\n\n/* end NOTE */\n\n#special-sponsor {\n  border-top: 1px solid var(--vt-c-divider-light);\n  border-bottom: 1px solid var(--vt-c-divider-light);\n  padding: 12px 24px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n#special-sponsor h3 {\n  text-align: center;\n  font-size: 13px;\n  font-weight: 500;\n}\n\n#special-sponsor-container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n#special-sponsor .logo {\n  display: flex;\n  justify-content: center;\n  padding: 0 20px;\n}\n\n#special-sponsor span {\n  color: var(--vt-c-text-2);\n  font-weight: 500;\n  font-size: 13px;\n  vertical-align: middle;\n  flex: 1;\n}\n\n#special-spsr span:first-child {\n  text-align: right;\n}\n\n\n#special-sponsor a {\n  display: flex;\n  justify-content: center;\n  padding: 0 24px;\n}\n\n#special-spsr img {\n  height: 42px;\n  margin: -6px 0;\n}\n\n.dark #special-spsr img {\n  filter: grayscale(1) invert(1);\n}\n\n#highlights {\n  max-width: 960px;\n  margin: 0px auto;\n  color: var(--vt-c-text-2);\n}\n\n#highlights h2 {\n  font-weight: 600;\n  font-size: 20px;\n  letter-spacing: -0.4px;\n  color: var(--vt-c-text-1);\n  transition: color 0.5s;\n  margin-bottom: 0.75em;\n}\n\n#highlights p {\n  font-weight: 400;\n  font-size: 15px;\n}\n\n#highlights .vt-box {\n  background-color: transparent;\n}\n\n#spsrs {\n  max-width: 900px;\n  margin: 0px auto;\n}\n\n#spsrs h2 {\n  font-size: 20px;\n  font-weight: 600;\n  margin-bottom: 1em;\n}\n\n#spsrs .spsr-container {\n  margin-bottom: 3em;\n}\n\n@media (max-width: 960px) {\n  .tagline {\n    font-size: 64px;\n    letter-spacing: -0.5px;\n  }\n  .description {\n    font-size: 18px;\n    margin-bottom: 48px;\n  }\n}\n\n@media (max-width: 794px) {\n  .tagline {\n    font-size: 48px;\n    letter-spacing: -0.5px;\n  }\n  .actions .security {\n    margin-top: 18px;\n  }\n}\n\n@media (max-width: 576px) {\n  #hero {\n    padding: 56px 32px;\n  }\n  .description {\n    font-size: 16px;\n    margin: 18px 0 30px;\n  }\n  #special-spsr {\n    flex-direction: column;\n    height: auto;\n  }\n  #special-spsr img {\n    height: 36px;\n    margin: 8px 0;\n  }\n  #special-spsr span {\n    text-align: center !important;\n  }\n  #highlights h3 {\n    margin-bottom: 0.6em;\n  }\n  #highlights .vt-box {\n    padding: 20px 36px;\n  }\n  .actions a {\n    margin: 18px 0;\n  }\n  .actions .security {\n    margin-top: 0;\n  }\n}\n\n@media (max-width: 370px) {\n  .tagline {\n    font-size: 36px;\n  }\n}\n\n#uwu {\n  display: none;\n}\n\n.uwu #uwu {\n  display: block;\n  width: 100%;\n  max-width: 720px;\n  margin: -120px auto -20px;\n  aspect-ratio: 192 / 108;\n  content: url(/logo-uwu.png);\n}\n\n@media (max-width: 576px) {\n  .uwu #uwu {\n    margin: -60px auto -10px;\n  }\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/NewsLetter.vue\n================================================\n<script setup lang=\"ts\">\nimport { VTLink } from '@vue/theme'\n</script>\n\n<template>\n  <section id=\"newsletter\" class=\"NewsLetter\">\n    <div class=\"container\">\n      <h2 class=\"title\">订阅我们的每周新闻。</h2>\n\n      <div class=\"form\">\n        <form\n          class=\"box\"\n          id=\"revue-form\"\n          name=\"revue-form\"\n          method=\"post\"\n          action=\"https://www.getrevue.co/profile/vuenewsletter/add_subscriber\"\n          rel=\"noopener\"\n          target=\"_blank\"\n        >\n          <input\n            class=\"input\"\n            id=\"member_email\"\n            name=\"member[email]\"\n            type=\"email\"\n            placeholder=\"邮箱地址\"\n            required\n          />\n\n          <div class=\"action\">\n            <input\n              class=\"button\"\n              id=\"member_submit\"\n              name=\"member[subscribe]\"\n              type=\"submit\"\n              value=\"订阅\"\n            />\n          </div>\n        </form>\n      </div>\n\n      <p class=\"help\">\n        你可以在\n        <VTLink\n          class=\"link\"\n          href=\"https://news.vuejs.org/\"\n          no-icon\n          >news.vuejs.org</VTLink> 阅读之前的期刊并收听我们的播客。你也可以在\n        <VTLink class=\"link\" href=\"https://twitter.com/vuejs\" no-icon>Twitter</VTLink> 关注我们，或加入我们的\n        <VTLink class=\"link\" href=\"https://discord.com/invite/vue\" no-icon>Discord</VTLink> 家园。\n      </p>\n    </div>\n  </section>\n</template>\n\n<style scoped>\n.NewsLetter {\n  border-top: 1px solid transparent;\n  border-bottom: 1px solid var(--vt-c-divider-light);\n  padding: 32px 24px;\n  background: var(--vt-c-bg-soft);\n  transition: border-color 0.5s, background-color 0.5s;\n}\n\n.dark .NewsLetter {\n  border-top-color: var(--vt-c-divider-light);\n  border-bottom-color: transparent;\n  background: var(--vt-c-bg);\n}\n\n@media (min-width: 768px) {\n  .NewsLetter {\n    padding: 48px 32px;\n  }\n}\n\n.container {\n  margin: 0 auto;\n  max-width: 512px;\n}\n\n.title {\n  text-align: center;\n  font-size: 14px;\n  font-weight: 500;\n  color: var(--vt-c-text-2);\n  transition: color 0.5s;\n}\n\n@media (min-width: 375px) {\n  .title {\n    font-size: 16px;\n  }\n}\n\n.form {\n  padding-top: 8px;\n}\n\n@media (min-width: 375px) {\n  .form {\n    padding-top: 16px;\n  }\n}\n\n.box {\n  position: relative;\n  width: 100%;\n}\n\n.input {\n  border: 1px solid var(--vt-c-divider);\n  border-radius: 8px;\n  padding: 11px 128px 11px 16px;\n  font-size: 16px;\n  width: 100%;\n  color: var(--vt-c-text-1);\n  transition: border-color 0.25s, background-color 0.25s;\n}\n\n.input:hover,\n.input:focus {\n  border-color: var(--vt-c-brand);\n}\n\n.input:focus {\n  background-color: var(--vt-c-white);\n}\n\n.dark .input {\n  background-color: var(--vt-c-bg);\n}\n\n.dark .input:focus {\n  background-color: var(--vt-c-black-pure);\n}\n\n.input::placeholder {\n  font-weight: 500;\n  color: var(--vt-c-text-3);\n  transition: color 0.25s;\n}\n\n.action {\n  position: absolute;\n  top: 6px;\n  right: 6px;\n}\n\n.button {\n  border-radius: 4px;\n  padding: 0 12px;\n  letter-spacing: 0.8px;\n  line-height: 36px;\n  font-size: 13px;\n  font-weight: 500;\n  color: var(--vt-c-text-dark-1);\n  background-color: var(--vt-c-brand);\n  transition: background-color 0.25s;\n  cursor: pointer;\n}\n\n.button:hover {\n  background-color: var(--vt-c-brand-dark);\n}\n\n.help {\n  margin: 0 auto;\n  padding: 8px;\n  max-width: 480px;\n  text-align: center;\n  line-height: 20px;\n  font-size: 12px;\n  font-weight: 500;\n  color: var(--vt-c-text-2);\n  transition: color 0.5s;\n}\n\n@media (min-width: 375px) {\n  .help {\n    padding-top: 16px;\n  }\n}\n\n.link {\n  color: var(--vt-c-brand);\n  transition: color 0.25s;\n}\n\n.link:hover {\n  color: var(--vt-c-brand-dark);\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/PageHero.vue\n================================================\n<template>\n  <div class=\"page-hero\">\n    <h1 class=\"page-hero__title\">\n      <slot name=\"title\" />\n    </h1>\n    <div class=\"page-hero__lead\">\n      <slot name=\"lead\" />\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.page-hero {\n  padding: 48px 24px;\n  text-align: center;\n  margin: 0 auto;\n  max-width: 688px;\n}\n\n.page-hero__title,\n.page-hero__lead,\n.page-hero :deep(.link) {\n  transition: color 0.25s;\n}\n\n.page-hero__title {\n  line-height: 32px;\n  font-size: 32px;\n  font-weight: 500;\n  margin-bottom: 0.3em;\n}\n\n.page-hero__lead {\n  padding-top: 8px;\n  font-size: 16px;\n  font-weight: 500;\n  color: var(--vt-c-text-2);\n}\n\n.page-hero__lead a {\n  color: var(--vt-c-brand);\n}\n\n.page-hero :deep(.link) {\n  color: var(--vt-c-brand);\n}\n\n.page-hero :deep(.link:hover) {\n  color: var(--vt-c-brand-dark);\n}\n\n/* Media Queries */\n@media (min-width: 768px) {\n  .page-hero {\n    padding: 64px 32px;\n  }\n\n  .page-hero__title {\n    line-height: 40px;\n    font-size: 40px;\n  }\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/PageShowcaseListLayout.vue\n================================================\n<script setup lang=\"ts\">\nconst props = defineProps<{\n  spotlightTitle?: string\n  featuredTitle?: string\n  browseLinkText?: string\n  browseLinkUrl?: string\n}>()\n</script>\n\n<template>\n  <div class=\"showcase-layout\">\n    <!-- Hero Section -->\n    <slot name=\"hero\"></slot>\n\n    <!-- Spotlight Section -->\n    <div class=\"showcase-layout__spotlight\">\n      <div class=\"spotlight-content\">\n        <h2 v-if=\"props.spotlightTitle\" class=\"section-title\">{{ props.spotlightTitle }}</h2>\n        <slot name=\"spotlight\"></slot>\n      </div>\n    </div>\n\n    <!-- Featured Section -->\n    <div class=\"showcase-layout__featured\">\n      <!-- Optional Actions Section -->\n      <div v-if=\"$slots.actions\" class=\"featured-actions\">\n        <slot name=\"actions\"></slot>\n      </div>\n      <h2 v-if=\"props.featuredTitle\" class=\"section-title\">{{ props.featuredTitle }}</h2>\n      <slot name=\"featured-list\"></slot>\n      <slot name=\"featured-cta\">\n        <div v-if=\"browseLinkUrl\" class=\"browse-more\">\n          <a class=\"accent-button\" :href=\"props.browseLinkUrl\">{{ props.browseLinkText }}</a>\n        </div>\n      </slot>\n    </div>\n\n    <!-- Join Section -->\n    <slot name=\"join\"></slot>\n  </div>\n</template>\n\n<style scoped>\n.showcase-layout {\n  padding-bottom: 16px;\n}\n\n.showcase-layout__spotlight {\n  background-color: var(--vt-c-bg-soft);\n}\n\n.spotlight-content {\n  padding: 36px 48px;\n  max-width: 1280px;\n  margin: 0 auto;\n}\n\n.section-title {\n  font-size: 1.1em;\n  font-weight: 600;\n  margin-bottom: 1.5em;\n  color: var(--vt-c-text-2);\n}\n\n.showcase-layout__featured {\n  padding: 36px 48px;\n  max-width: 960px;\n  width: 100%;\n  margin: 0 auto;\n}\n\n.featured-actions {\n  width: 100%;\n  margin-bottom: 1.5em;\n}\n\n.browse-more {\n  margin: 1.5rem auto;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n\n.accent-button,\n:deep(.accent-button) {\n  display: block;\n  width: fit-content;\n  min-width: 240px;\n  text-align: center;\n  background-color: var(--vt-c-brand);\n  color: var(--vt-c-bg);\n  padding: 12px 24px;\n  font-weight: 600;\n  border-radius: 6px;\n  transition: background-color 0.5s, color 0.5s;\n  text-decoration: none;\n}\n\n.accent-button:hover,\n:deep(.accent-button):hover {\n  background-color: var(--vt-c-brand-dark);\n}\n\n/* Media Queries */\n@media (max-width: 768px) {\n  .spotlight-content,\n  .showcase-layout__featured {\n    padding: 36px 28px;\n  }\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/preferences.ts\n================================================\nimport { ref } from 'vue'\nimport { AugmentedHeader } from '../../headerMdPlugin'\n\nexport const inBrowser = typeof window !== 'undefined'\nconst get = (key: string, defaultValue = false): boolean =>\n  inBrowser\n    ? JSON.parse(localStorage.getItem(key) || String(defaultValue))\n    : defaultValue\n\nexport const preferCompositionKey = 'vue-docs-prefer-composition'\nexport const preferComposition = ref(get(preferCompositionKey, true))\n\nexport const preferSFCKey = 'vue-docs-prefer-sfc'\nexport const preferSFC = ref(get(preferSFCKey, true))\n\nexport function filterHeadersByPreference(h: AugmentedHeader) {\n  return preferComposition.value ? !h.optionsOnly : !h.compositionOnly\n}\n\n\n\n================================================\nFILE: .vitepress/theme/components/PreferenceSwitch.vue\n================================================\n<script setup lang=\"ts\">\nimport { VTSwitch, VTIconChevronDown } from '@vue/theme'\nimport { useRoute } from 'vitepress'\nimport { ref, computed, inject, Ref } from 'vue'\nimport {\n  preferCompositionKey,\n  preferComposition,\n  preferSFCKey,\n  preferSFC\n} from './preferences'\nimport PreferenceTooltip from './PreferenceTooltip.vue'\n\nconst route = useRoute()\nconst show = computed(() =>\n  /^\\/(guide|tutorial|examples|style-guide)\\//.test(route.path)\n)\nconst showSFC = computed(() => !/^\\/guide|style-guide/.test(route.path))\n\nlet isOpen = ref(true)\n\nconst toggleOpen = () => {\n  isOpen.value = !isOpen.value\n}\n\nconst removeOutline = (e: Event) => {\n  ;(e.target as HTMLElement).classList.add('no-outline')\n}\n\nconst restoreOutline = (e: Event) => {\n  ;(e.target as HTMLElement).classList.remove('no-outline')\n}\n\nconst toggleCompositionAPI = useToggleFn(\n  preferCompositionKey,\n  preferComposition,\n  'prefer-composition'\n)\nconst toggleSFC = useToggleFn(preferSFCKey, preferSFC, 'prefer-sfc')\nconst closeSideBar = inject('close-sidebar') as () => void\n\nfunction useToggleFn(\n  storageKey: string,\n  state: Ref<boolean>,\n  className: string\n) {\n  if (typeof localStorage === 'undefined') {\n    return () => {}\n  }\n  const classList = document.documentElement.classList\n  return (value = !state.value) => {\n    if ((state.value = value)) {\n      classList.add(className)\n    } else {\n      classList.remove(className)\n    }\n    localStorage.setItem(storageKey, String(state.value))\n  }\n}\n</script>\n\n<template>\n  <div v-if=\"show\" class=\"preference-switch\">\n    <button\n      class=\"toggle\"\n      aria-label=\"偏好切换开关\"\n      aria-controls=\"preference-switches\"\n      :aria-expanded=\"isOpen\"\n      @click=\"toggleOpen\"\n      @mousedown=\"removeOutline\"\n      @blur=\"restoreOutline\"\n    >\n      <span>API 风格偏好</span>\n      <VTIconChevronDown class=\"vt-link-icon\" :class=\"{ open: isOpen }\" />\n    </button>\n    <div id=\"preference-switches\" :hidden=\"!isOpen\" :aria-hidden=\"!isOpen\">\n      <div class=\"switch-container\">\n        <label class=\"options-label\" @click=\"toggleCompositionAPI(false)\"\n          >选项式</label\n        >\n        <VTSwitch\n          class=\"api-switch\"\n          aria-label=\"偏好组合式 API\"\n          :aria-checked=\"preferComposition\"\n          @click=\"toggleCompositionAPI()\"\n        />\n        <label\n          class=\"composition-label\"\n          @click=\"toggleCompositionAPI(true)\"\n          >组合式</label\n        >\n        <a\n          class=\"switch-link\"\n          title=\"关于 API 风格偏好\"\n          href=\"/guide/introduction.html#api-styles\"\n          @click=\"closeSideBar\"\n          >?</a\n        >\n        <PreferenceTooltip />\n      </div>\n      <div class=\"switch-container\" v-if=\"showSFC\">\n        <label class=\"no-sfc-label\" @click=\"toggleSFC(false)\">HTML</label>\n        <VTSwitch\n          class=\"sfc-switch\"\n          aria-label=\"偏好单文件组件\"\n          :aria-checked=\"preferSFC\"\n          @click=\"toggleSFC()\"\n        />\n        <label class=\"sfc-label\" @click=\"toggleSFC(true)\">单文件组件</label>\n        <a\n          class=\"switch-link\"\n          title=\"关于单文件组件\"\n          href=\"/guide/scaling-up/sfc.html\"\n          @click=\"closeSideBar\"\n          >?</a\n        >\n      </div>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.preference-switch {\n  font-size: 12px;\n  border-bottom: 1px solid var(--vt-c-divider-light);\n  transition: border-color 0.5s, background-color 0.5s ease;\n  margin-bottom: 20px;\n  position: sticky;\n  top: -0.5px;\n  background-color: var(--vt-c-bg);\n  padding-top: 10px;\n  z-index: 10;\n}\n\n.toggle {\n  color: var(--vt-c-text-2);\n  transition: color 0.5s;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding-bottom: 2px;\n  width: 100%;\n  font-weight: 600;\n}\n\n.toggle:hover {\n  color: var(--vt-c-text-1);\n}\n\n.no-outline {\n  outline: 0;\n}\n\n.vt-link-icon {\n  position: relative;\n  top: 1px;\n}\n\n.vt-link-icon.open {\n  transform: rotate(180deg);\n}\n\n#preference-switches {\n  padding: 12px 16px;\n  background-color: var(--vt-c-bg-soft);\n  transition: background-color 0.5s;\n  margin: 6px 0 12px;\n  border-radius: 8px;\n  font-weight: 600;\n}\n\n.switch-container {\n  display: flex;\n  align-items: center;\n}\n\n@media(max-width: 959px){\n  .switch-container {\n    padding: 0 1em;\n  }\n}\n\n.switch-container:nth-child(2) {\n  margin-top: 10px;\n}\n\n.vt-switch {\n  margin-right: 5px;\n  transform: scale(0.8);\n}\n\n.switch-container label {\n  transition: color 0.5s;\n  cursor: pointer;\n}\n\n.switch-container label:first-child {\n  width: 50px;\n}\n\n.switch-link {\n  margin-left: 8px;\n  font-size: 11px;\n  min-width: 14px;\n  height: 14px;\n  line-height: 13px;\n  text-align: center;\n  color: var(--vt-c-green);\n  border: 1px solid var(--vt-c-green);\n  border-radius: 50%;\n}\n\n@media (max-width: 1439px) {\n  #preference-switches {\n    font-size: 11px;\n    padding: 8px 4px;\n  }\n\n  .vt-switch {\n    margin: auto;\n  }\n\n  .switch-link {\n    margin-left: auto;\n  }\n  .switch-container label:first-child {\n    width: 46px;\n  }\n}\n</style>\n\n<style>\n.composition-api,\n.sfc {\n  display: none;\n}\n\n.prefer-composition .options-api,\n.prefer-sfc .html {\n  display: none;\n}\n\n.prefer-composition .composition-api,\n.prefer-sfc .sfc {\n  display: initial;\n}\n\n.prefer-composition .api-switch .vt-switch-check {\n  transform: translateX(18px);\n}\n\n.composition-label,\n.sfc-label,\n.prefer-composition .options-label,\n.prefer-sfc .no-sfc-label {\n  color: var(--vt-c-text-3);\n}\n\n.prefer-composition .composition-label,\n.prefer-sfc .sfc-label {\n  color: var(--vt-c-text-1);\n}\n\n.prefer-sfc .sfc-switch .vt-switch-check {\n  transform: translateX(18px);\n}\n\n.tip .options-api,\n.tip .composition-api {\n  color: var(--vt-c-text-code);\n  /* transition: color 0.5s; */\n  font-weight: 600;\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/PreferenceTooltip.vue\n================================================\n<script setup lang=\"ts\">\nimport { onMounted, ref, watch } from 'vue'\nimport {\n  inBrowser,\n  preferComposition,\n  preferCompositionKey\n} from './preferences'\nimport { useData, type Header } from 'vitepress'\n\nconst show = ref(false)\nconst { page } = useData()\n\ntype Source = 'url-query' | 'url-header' | 'default'\nlet source: Source | false =\n  inBrowser && localStorage.getItem(preferCompositionKey) === null\n    ? 'default'\n    : false\n\nif (inBrowser) {\n  // 1. check if URL contains explicit preference\n  const match = location.search.match(/[\\?&]api=(\\w+)/)\n  const preference = match && match[1]\n  if (preference === 'composition') {\n    setPreference(true, 'url-query')\n  } else if (preference === 'options') {\n    setPreference(false, 'url-query')\n  } else {\n    // 2. check if target header only exists for a certain API\n    if (location.hash) {\n      const h = findHeader(page.value.headers, location.hash)\n      if (h && h.optionsOnly) {\n        setPreference(false, 'url-header')\n      } else if (h && h.compositionOnly) {\n        setPreference(true, 'url-header')\n      }\n    }\n  }\n}\n\nfunction findHeader(\n  headers: Header[],\n  link: string\n):\n  | (Header & {\n      optionsOnly?: boolean\n      compositionOnly?: boolean\n    })\n  | undefined {\n  for (const h of headers) {\n    if (h.link === link) {\n      return h\n    }\n    if (h.children) {\n      const c = findHeader(h.children, link)\n      if (c) return c\n    }\n  }\n}\n\nfunction setPreference(capi: boolean, s: Source) {\n  if (capi && !preferComposition.value) {\n    source = s\n    preferComposition.value = true\n    document.documentElement.classList.add('prefer-composition')\n  } else if (!capi && preferComposition.value) {\n    source = s\n    preferComposition.value = false\n    document.documentElement.classList.remove('prefer-composition')\n  }\n}\n\nonMounted(() => {\n  if (\n    !page.value.relativePath.startsWith('tutorial/') &&\n    source !== false\n  ) {\n    show.value = true\n    // dismiss if user switches with the tooltip open\n    const stop = watch(preferComposition, () => {\n      show.value = false\n      stop()\n    })\n  }\n})\n\nfunction dismiss() {\n  show.value = false\n  // save if default\n  if (source === 'default') {\n    localStorage.setItem(\n      preferCompositionKey,\n      String(preferComposition.value)\n    )\n  }\n}\n</script>\n\n<template>\n  <Transition name=\"fly-in\">\n    <div class=\"preference-tooltip\" v-if=\"show\">\n      <template v-if=\"source === 'default'\">\n        <p>现在将默认使用组合式 API 风格。</p>\n        <p>\n          一些页面根据所选的 API 风格将包含不同的内容。可以通过此开关在它们之间切换。\n        </p>\n      </template>\n      <template v-if=\"source && source.startsWith('url')\">\n        <p>\n          正在显示\n          {{ preferComposition ? '组合式' : '选项式' }} API 的内容，这是因为\n          {{\n            source === 'url-query'\n              ? '通过 URL 查询参数指定了。'\n              : '目标章节仅适用于此 API。'\n          }}\n        </p>\n        <p>\n          这与你已保存的首选项不同，且仅会影响当前的浏览会话。\n        </p>\n      </template>\n      <p class=\"actions\">\n        <a href=\"/guide/introduction#api-styles\">了解详情</a>\n        <button @click=\"dismiss\">知道了</button>\n      </p>\n      <div class=\"arrow-top\"></div>\n      <div class=\"arrow-top inner\"></div>\n    </div>\n  </Transition>\n</template>\n\n<style scoped>\n.preference-tooltip {\n  font-weight: 500;\n  line-height: 1.6;\n  position: absolute;\n  padding: 12px 20px 12px 36px;\n  width: 100%;\n  background-color: var(--vt-c-bg-soft);\n  top: 7.5em;\n  border: 1px solid var(--vt-c-green);\n  border-radius: 8px;\n  box-shadow: var(--vt-shadow-3);\n  z-index: 10;\n}\n\n.preference-tooltip:before {\n  content: 'ⓘ';\n  position: absolute;\n  font-weight: 600;\n  font-size: 14px;\n  top: 9px;\n  left: 13px;\n}\n\n.dark .preference-tooltip {\n  box-shadow: var(--vt-shadow-1);\n}\n\np {\n  margin-bottom: 8px;\n}\n\n.arrow-top {\n  width: 0;\n  height: 0;\n  border: 6px solid transparent;\n  border-bottom: 9px solid var(--vt-c-green);\n  position: absolute;\n  top: -16px;\n  left: 18px;\n}\n\n.prefer-composition .arrow-top {\n  left: 130px;\n}\n\n@media (max-width: 1439px) {\n  .arrow-top {\n    left: 16px;\n  }\n  .prefer-composition .arrow-top {\n    left: 136px;\n  }\n}\n\n.arrow-top.inner {\n  border-bottom-color: var(--vt-c-bg-soft);\n  top: -14px;\n}\n\n.actions {\n  text-align: right;\n  margin-top: 14px;\n  margin-bottom: 0;\n}\n\na {\n  color: var(--vt-c-green);\n  text-decoration: underline;\n  margin-right: 1.5em;\n}\n\nbutton {\n  color: var(--vt-c-bg-soft);\n  font-weight: 500;\n  box-shadow: var(--vt-shadow-2);\n  padding: 2px 8px;\n  border-radius: 6px;\n  background-color: var(--vt-c-green);\n}\n\n.fly-in-enter-active {\n  transition: all 0.2s ease-out;\n}\n\n.fly-in-leave-active {\n  transition: all 0.15s ease-in;\n}\n\n.fly-in-enter-from,\n.fly-in-leave-to {\n  opacity: 0;\n  transform: translateY(16px);\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/ReplLoading.vue\n================================================\n<template>\n  <div class=\"repl-loading\">\n    <div class=\"lds-ring\">\n      <div></div>\n      <div></div>\n      <div></div>\n      <div></div>\n    </div>\n    <div>正在加载 Repl 环境...</div>\n  </div>\n</template>\n\n<style>\n.repl-loading {\n  font-weight: 600;\n  font-size: 16px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  height: 66vh;\n}\n.lds-ring {\n  display: inline-block;\n  position: relative;\n  width: 40px;\n  height: 40px;\n  margin-bottom: 10px;\n}\n.lds-ring div {\n  box-sizing: border-box;\n  display: block;\n  position: absolute;\n  width: 32px;\n  height: 32px;\n  margin: 4px;\n  border: 4px solid;\n  border-radius: 50%;\n  animation: lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;\n  border-color: var(--vt-c-brand) transparent transparent transparent;\n}\n.lds-ring div:nth-child(1) {\n  animation-delay: -0.45s;\n}\n.lds-ring div:nth-child(2) {\n  animation-delay: -0.3s;\n}\n.lds-ring div:nth-child(3) {\n  animation-delay: -0.15s;\n}\n@keyframes lds-ring {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/ScrimbaLink.vue\n================================================\n<template>\n  <div class=\"scrimba\">\n    <a\n      :href=\"href\"\n      target=\"_blank\"\n      rel=\"sponsored noopener\"\n      :title=\"title\"\n    >\n      <slot>Watch a free interactive tutorial on Scrimba</slot>\n    </a>\n  </div>\n</template>\n<script>\nexport default {\n  props: {\n    href: { type: String, required: true },\n    title: { type: String, required: true }\n  }\n}\n</script>\n<style scoped>\n.scrimba {\n  margin: 28px 0;\n  background-color: var(--vt-c-bg-soft);\n  padding: 1em 1.25em;\n  border-radius: 2px;\n  position: relative;\n  display: flex;\n  border-radius: 8px;\n}\n.scrimba a {\n  color: var(--c-text);\n  position: relative;\n  padding-left: 36px;\n}\n.scrimba a:before {\n  content: '';\n  position: absolute;\n  display: block;\n  width: 30px;\n  height: 30px;\n  top: calc(50% - 15px);\n  left: -4px;\n  border-radius: 50%;\n  background-color: #73abfe;\n}\n.scrimba a:after {\n  content: '';\n  position: absolute;\n  display: block;\n  width: 0;\n  height: 0;\n  top: calc(50% - 5px);\n  left: 8px;\n  border-top: 5px solid transparent;\n  border-bottom: 5px solid transparent;\n  border-left: 8px solid #fff;\n}\n</style> \n\n\n================================================\nFILE: .vitepress/theme/components/SecurityUpdateBtn.vue\n================================================\n<script setup lang=\"ts\">\n</script>\n\n<template>\n  <div class=\"container\">\n    <a \n      class=\"security\" \n      href=\"https://www.herodevs.com/support/nes-vue?utm_source=vuejs_org&utm_medium=sidebar_link&utm_campaign=vue2eol\"\n      target=\"_blank\"\n    >\n      获取针对 Vue 2 的安全更新\n      <svg \n        class=\"icon\"\n        xmlns=\"http://www.w3.org/2000/svg\" \n        viewBox=\"0 0 512 512\"\n      >\n        <path \n          d=\"M320 0c-17.7 0-32 14.3-32 32s14.3 32 32 32h82.7L201.4 265.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L448 109.3V192c0 17.7 14.3 32 32 32s32-14.3 32-32V32c0-17.7-14.3-32-32-32H320zM80 32C35.8 32 0 67.8 0 112V432c0 44.2 35.8 80 80 80H400c44.2 0 80-35.8 80-80V320c0-17.7-14.3-32-32-32s-32 14.3-32 32V432c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V112c0-8.8 7.2-16 16-16H192c17.7 0 32-14.3 32-32s-14.3-32-32-32H80z\"\n        />\n      </svg>\n    </a>\n  </div>\n</template>\n\n<style scoped>\n  .container {\n    margin-top: 20px;\n  }\n  .container .security {\n    font-size: 12px;\n    display: inline-block;\n    padding: 4px 8px;\n    font-weight: 500;\n    border-radius: 8px;\n    background: linear-gradient(var(--vt-c-bg-mute), var(--vt-c-bg-mute)) padding-box, \n      linear-gradient(45deg, #42d392, #647eff) border-box;\n    border: 2px solid transparent;\n    color: var(--vt-c-text-code);\n    transition: background-color 0.5s, color 0.5s;\n  }\n  .container .security:hover {\n    background: linear-gradient(var(--vt-c-gray-light-4), var(--vt-c-gray-light-4)) padding-box, \n      linear-gradient(45deg, #42d392, #647eff) border-box;\n    transition-duration: 0.2s;\n  }\n  .dark .container .security:hover {\n    background: linear-gradient(var(--vt-c-gray-dark-3), var(--vt-c-gray-dark-3)) padding-box, \n      linear-gradient(45deg, #42d392, #647eff) border-box;\n  }\n  .container .security .icon {\n    width: 12px;\n    height: 12px;\n    margin-left: 4px;\n    display: inline;\n    position: relative;\n    fill: currentColor;\n    transition: transform 0.2s;\n\n  }\n  .dark .container .security:hover {\n    background-color: var(--vt-c-gray-dark-3);\n  }\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/SiteMap.vue\n================================================\n<script setup lang=\"ts\">\nimport { VTLink } from '@vue/theme'\nimport { useData } from 'vitepress'\n\nconst data = useData()\nconst nav = data.site.value.themeConfig.nav\nconst ecosystem = nav.find((i: any) => i.activeMatch?.includes('ecosystem'))\nconst items = nav\n  .filter((i: any) => i !== ecosystem && i.items)\n  .concat(ecosystem.items)\n</script>\n\n<template>\n  <section id=\"sitemap\">\n    <div class=\"container\">\n      <div class=\"sitemap-col\" v-for=\"col in items\">\n        <h4>{{ col.text }}</h4>\n        <ul>\n          <li v-for=\"row in col.items\">\n            <VTLink :href=\"row.link\">{{ row.text }}</VTLink>\n          </li>\n        </ul>\n      </div>\n    </div>\n  </section>\n</template>\n\n<style>\n#sitemap {\n  background: var(--vt-c-bg-soft);\n}\n\n#sitemap .container {\n  max-width: 900px;\n  margin: 0 auto;\n  columns: 1;\n  padding: 24px 32px;\n}\n\n@media (min-width: 768px) {\n  #sitemap .container {\n    columns: 2;\n  }\n}\n\n@media (min-width: 1024px) {\n  #sitemap .container {\n    columns: 3;\n  }\n}\n\n#sitemap h4 {\n  font-weight: 500;\n  color: var(--vt-c-text-1);\n  margin-bottom: 0.25em;\n}\n\n.sitemap-col {\n  margin-bottom: 2em;\n  break-inside: avoid;\n}\n\n#sitemap .vt-link {\n  font-size: 0.9em;\n  color: var(--vt-c-text-2);\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/sponsors.ts\n================================================\n// shared data across instances so we load only once\n\nimport { ref } from 'vue'\n\ndeclare global {\n  const fathom: {\n    trackGoal: (id: string, value: number) => any\n  }\n}\n\nexport interface Sponsor {\n  url: string\n  url_cn: string\n  img: string\n  name: string\n  description?: string\n  priority?: boolean\n  height?: string\n}\n\nexport interface SponsorData {\n  special: Sponsor[]\n  platinum: Sponsor[]\n  platinum_china: Sponsor[]\n  gold: Sponsor[]\n  silver: Sponsor[]\n  bronze: Sponsor[]\n}\n\nexport const data = ref<SponsorData>()\nexport const pending = ref<boolean>(false)\n\nexport const base = `https://automation.vuejs.org`\n\nexport const load = async () => {\n  if (!pending.value) {\n    pending.value = true\n    data.value = await (await fetch(`${base}/data.json`)).json()\n  }\n}\n\n\n\n================================================\nFILE: .vitepress/theme/components/SponsorsAside.vue\n================================================\n<script setup lang=\"ts\">\nimport SponsorsGroup from './SponsorsGroup.vue'\nimport { useData } from 'vitepress'\nconst { frontmatter } = useData()\n</script>\n\n<template>\n  <div v-if=\"frontmatter.sponsors !== false\">\n    <a class=\"sponsors-aside-text\" href=\"/sponsor/\">赞助位</a>\n    <SponsorsGroup tier=\"platinum_china\" />\n  </div>\n</template>\n\n<style>\na.sponsors-aside-text {\n  color: var(--vt-c-text-3);\n  display: block;\n  margin: 3em 0 1em;\n  font-weight: 700;\n  font-size: 11px;\n  text-transform: uppercase;\n  letter-spacing: 0.4px;\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/SponsorsGroup.vue\n================================================\n<script setup lang=\"ts\">\nimport { ref, onMounted, onUnmounted } from 'vue'\nimport { SponsorData, data, base, load } from './sponsors'\n\ntype Placement = 'aside' | 'page' | 'landing'\n\nconst props = withDefaults(\n  defineProps<{\n    tier: keyof SponsorData\n    placement?: Placement\n  }>(),\n  {\n    placement: 'aside'\n  }\n)\n\nconst container = ref<HTMLElement>()\nconst visible = ref(false)\n\nonMounted(async () => {\n  // only render when entering view\n  const observer = new IntersectionObserver(\n    (entries) => {\n      if (entries[0].isIntersecting) {\n        visible.value = true\n        observer.disconnect()\n      }\n    },\n    { rootMargin: '0px 0px 300px 0px' }\n  )\n  observer.observe(container.value!)\n  onUnmounted(() => observer.disconnect())\n\n  // load data\n  await load()\n})\n\n// fathom events\nconst eventMap: Record<Placement, string> = {\n  aside: '4QUPDDRU',\n  landing: '58FLAR2Z',\n  page: 'ZXLO3IUT'\n}\n\nfunction track(interest?: boolean) {\n  fathom.trackGoal(interest ? `Y2BVYNT2` : eventMap[props.placement], 0)\n}\n\nfunction resolveList(data: SponsorData) {\n  let currentTier = data[props.tier] || []\n  // in aside, treat platinum+priority as special\n  if (props.placement === 'aside') {\n    if (props.tier === 'platinum') {\n      currentTier = currentTier.filter((s) => !s.priority)\n    } else if (props.tier === 'special') {\n      currentTier = [\n        ...currentTier,\n        ...data.platinum.filter((s) => s.priority)\n      ]\n    }\n  }\n  return currentTier\n}\n</script>\n\n<template>\n  <div\n    ref=\"container\"\n    class=\"spsr-container\"\n    :class=\"[tier === 'platinum_china' ? 'special' : tier, placement]\"\n  >\n    <template v-if=\"data && visible\">\n      <a\n        v-for=\"{ url, url_cn, img, name } of resolveList(data)\"\n        class=\"spsr-item\"\n        :href=\"url_cn || url\"\n        target=\"_blank\"\n        rel=\"sponsored noopener\"\n        @click=\"track()\"\n      >\n        <picture v-if=\"img.endsWith('png')\">\n          <source\n            type=\"image/avif\"\n            :srcset=\"`${base}/images/${img.replace(/\\.png$/, '.avif')}`\"\n          />\n          <img :src=\"`${base}/images/${img}`\" :alt=\"name\" />\n        </picture>\n        <img v-else :src=\"`${base}/images/${img}`\" :alt=\"name\" />\n      </a>\n    </template>\n    <a\n      v-if=\"placement !== 'page' && tier !== 'special'\"\n      href=\"/sponsor/\"\n      class=\"spsr-item action\"\n      @click=\"track(true)\"\n      >成为赞助商</a\n    >\n    <a\n      v-if=\"tier === 'special' && data && !data[tier]?.length\"\n      href=\"/sponsor/#tier-benefits\"\n      class=\"spsr-item action\"\n      @click=\"track(true)\"\n      >Inquire about Special Sponsorship</a\n    >\n  </div>\n</template>\n\n<style scoped>\n.spsr-container {\n  --max-width: 100%;\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(var(--max-width), 1fr));\n  column-gap: 4px;\n}\n\n.spsr-container.platinum {\n  --max-width: 240px;\n}\n.spsr-container.gold {\n  --max-width: 180px;\n}\n.spsr-container.silver {\n  --max-width: 140px;\n}\n\n.spsr-item {\n  margin: 2px 0;\n  background-color: var(--vt-c-white-soft);\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  border-radius: 2px;\n  transition: background-color 0.2s ease;\n  height: calc(var(--max-width) / 2 - 6px);\n}\n.spsr-item.action {\n  font-size: 11px;\n  color: var(--vt-c-text-3);\n}\n.spsr-container.page .spsr-item.action {\n font-size: 16px;\n}\n.spsr-item img {\n  max-width: calc(var(--max-width) - 30px);\n  max-height: calc(var(--max-width) / 2 - 20px);\n}\n.special .spsr-item {\n  height: 160px;\n}\n.special .spsr-item img {\n  max-width: 300px;\n  max-height: 150px;\n}\n\n/* dark mode */\n.dark .aside .spsr-item,\n.dark .landing .spsr-item {\n  background-color: var(--vt-c-bg-soft);\n}\n.aside .spsr-item img,\n.landing .spsr-item img {\n  transition: filter 0.2s ease;\n}\n.dark .aside .spsr-item img,\n.dark .landing .spsr-item img {\n  filter: grayscale(1) invert(1);\n}\n.dark .aside .spsr-item:hover,\n.dark .landing .spsr-item:hover {\n  color: var(--vt-c-indigo);\n  background-color: var(--vt-c-white-mute);\n}\n.dark .spsr-item:hover img {\n  filter: none;\n}\n\n/* aside mode (on content pages) */\n.spsr-container.platinum.aside {\n  --max-width: 110px;\n  column-gap: 1px;\n}\n.aside .spsr-item {\n  margin: 1px 0;\n}\n.aside .special .spsr-item {\n  width: 100%;\n  height: 70px;\n}\n.aside .special .spsr-item img {\n  max-width: 120px;\n  max-height: 48px;\n}\n.aside .platinum .spsr-item {\n  width: 111px;\n  height: 50px;\n}\n.aside .platinum .spsr-item img {\n  max-width: 88px;\n}\n\n/* narrow, aside will be hidden under this state so it's mutually exclusive */\n@media (max-width: 720px) {\n  .spsr-container.platinum {\n    --max-width: 180px;\n  }\n  .spsr-container.gold {\n    --max-width: 140px;\n  }\n  .spsr-container.silver {\n    --max-width: 120px;\n  }\n}\n\n@media (max-width: 480px) {\n  .spsr-container.platinum {\n    --max-width: 150px;\n  }\n  .spsr-container.gold {\n    --max-width: 120px;\n  }\n  .spsr-container.silver {\n    --max-width: 100px;\n  }\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/TextAd.vue\n================================================\n<script setup lang=\"ts\">\nfunction track() {\n  fathom.trackGoal('7QLWSAAZ', 0)\n}\n</script>\n\n<template>\n  <div class=\"text-ad\">\n    <span class=\"label\">广告</span>\n    <a\n      href=\"https://aircode.io\"\n      target=\"_blank\"\n      rel=\"noopener nofollow\"\n      @click=\"track\"\n      >Try it → Build and deploy your own ChatGPT bot with JavaScript in 5 minutes</a\n    >\n  </div>\n</template>\n\n<style scoped>\n.text-ad {\n  font-size: 13px;\n  margin-bottom: 28px;\n  background-color: var(--vt-c-bg-soft);\n  padding: 0.75rem;\n  position: relative;\n  display: flex;\n  border-radius: 8px;\n}\n\n.label {\n  white-space: nowrap;\n  display: inline-block;\n  color: var(--vt-c-blue);\n  font-size: 12px;\n  border: 1px solid var(--vt-c-blue);\n  border-radius: 4px;\n  padding: 0 4px;\n  margin-right: 0.75rem;\n  height: 22px;\n}\n\n.text-ad a {\n  color: var(--vt-c-text-2);\n}\n\n@media (max-width: 512px) {\n  .text-ad {\n    font-size: 12px;\n    letter-spacing: -0.1px;\n  }\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/VueJobs.vue\n================================================\n<script lang=\"ts\">\nimport { ref } from 'vue'\n\n// shared data across instances so we load only once\nconst base = 'https://app.vuejobs.com/feed/vuejs/docs?format=json'\n\nconst items = ref<Jobs[]>([])\n\ntype Jobs = {\n  organization: Organization\n  title: string\n  link: string\n  locations: string[]\n  remote: false | 'ALLOWED' | 'ONLY'\n}\n\ntype Organization = {\n  name: string\n  avatar: string\n}\n</script>\n\n<script setup lang=\"ts\">\nimport { onMounted, computed } from 'vue'\n\nconst openings = computed(() =>\n  items.value.sort(() => 0.5 - Math.random()).slice(0, 2)\n)\n\nonMounted(async () => {\n  if (!items.value.length) {\n    items.value = (await (await fetch(`${base}`)).json()).data\n  }\n})\n</script>\n\n<template>\n  <div class=\"vuejobs-wrapper\">\n    <div class=\"vj-container\">\n      <a\n        class=\"vj-item\"\n        v-for=\"(job, n) in openings\"\n        :key=\"n\"\n        :href=\"job.link\"\n        target=\"_blank\"\n      >\n        <div class=\"vj-company-logo\">\n          <img\n            :src=\"job.organization.avatar\"\n            :alt=\"`Logo for ${job.organization.name}`\"\n          />\n        </div>\n        <div\n          style=\"\n            overflow: hidden;\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n          \"\n        >\n          <div class=\"vj-job-title\">{{ job.title }}</div>\n          <div class=\"vj-job-info\">\n            {{ job.organization.name }} <span>· </span>\n            <span>{{ job.remote ? 'Remote' : job.locations[0] }}</span>\n          </div>\n        </div>\n      </a>\n    </div>\n    <div class=\"vj-link\">\n      Jobs by\n      <a\n        href=\"https://vuejobs.com/?utm_source=vuejs&utm_medium=referral&utm_campaign=jobs_widget&utm_content=bottom_link\"\n        target=\"_blank\"\n        title=\"Hire Vue.js developers\"\n        >vuejobs.com</a\n      >\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.vuejobs-wrapper {\n  margin: 28px 0;\n}\n\n.vj-container {\n  display: grid;\n  gap: 15px;\n}\n\n.vj-item:nth-child(2) {\n  display: none;\n}\n\n@media (min-width: 640px) {\n  .vj-container {\n    grid-template-columns: repeat(2, minmax(0, 1fr));\n  }\n\n  .vj-item:nth-child(2) {\n    display: flex;\n  }\n}\n\n.vj-item {\n  background-color: var(--vt-c-bg-soft);\n  padding: 14px;\n  border-radius: 8px;\n  overflow: hidden;\n  font-size: 12px;\n  color: var(--vt-c-text-1);\n  display: flex;\n  width: 100%;\n}\n\n.vuejobs-wrapper p,\n.vuejobs-wrapper a {\n  transition: color 0.2s ease;\n}\n\n.vuejobs-wrapper a:hover {\n  color: var(--vt-c-brand);\n}\n\n.vj-job-link {\n  font-size: 12px;\n  color: var(--vt-c-text-1);\n  display: flex;\n  width: 100%;\n}\n\n.vj-job-title {\n  font-size: 13px;\n  line-height: 14px;\n  font-weight: 600;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n}\n\n.vj-job-info {\n  font-size: 11px;\n  color: var(--vt-c-text-2);\n  margin-top: 4px;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  white-space: nowrap;\n  line-height: 1;\n}\n\n.vj-company-logo {\n  width: 32px;\n  height: 32px;\n  border-radius: 4px;\n  overflow: hidden;\n  margin-right: 10px;\n  flex-shrink: 0;\n}\n\n.vj-company-logo img {\n  width: 100%;\n  height: 100%;\n  object-fit: contain;\n  object-position: center center;\n}\n\n.vj-link {\n  font-size: 10px;\n  line-height: 1;\n  margin-top: 10px;\n  text-align: right;\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/VueMasteryModal.vue\n================================================\n<script setup lang=\"ts\">\nimport { ref, watch } from 'vue'\n\nconst VIDEO_SOURCE = 'https://player.vimeo.com/video/647441538?autoplay=1'\nconst showWhyVue = ref(false)\n\nwatch(\n  () => showWhyVue,\n  (value) => {\n    value\n      ? (document.documentElement.style.overflow = 'hidden')\n      : (document.documentElement.style.overflow = 'auto')\n  }\n)\n</script>\n\n<template>\n  <a\n    id=\"vuemastery-action\"\n    class=\"why-vue\"\n    @click=\"showWhyVue = true\"\n    href=\"javascript:;\"\n  >\n    <svg\n      class=\"icon-play\"\n      aria-labelledby=\"simpleicons-play-icon\"\n      role=\"img\"\n      viewBox=\"0 0 100 125\"\n      fill=\"#FFFFFF\"\n    >\n      <title id=\"simpleicons-play-icon\" lang=\"en\">Play icon</title>\n      <path\n        d=\"M50,3.8C24.5,3.8,3.8,24.5,3.8,50S24.5,96.2,50,96.2S96.2,75.5,96.2,50S75.5,3.8,50,3.8z M71.2,53.3l-30.8,18  c-0.6,0.4-1.3,0.5-1.9,0.5c-0.6,0-1.3-0.1-1.9-0.5c-1.2-0.6-1.9-1.9-1.9-3.3V32c0-1.4,0.8-2.7,1.9-3.3c1.2-0.6,2.7-0.6,3.8,0  l30.8,18c1.2,0.6,1.9,1.9,1.9,3.3S72.3,52.7,71.2,53.3z\"\n      ></path>\n    </svg>\n    Why Vue\n  </a>\n  <Teleport v-if=\"showWhyVue\" to=\"body\">\n    <div\n      @click=\"showWhyVue = false\"\n      class=\"vuemastery-modal-mask\"\n    >\n      <div class=\"vuemastery-modal-wrapper\">\n        <div class=\"vuemastery-modal-container\">\n          <div class=\"vuemastery-modal-content\">\n            <div class=\"vuemastery-video-space\">\n              <iframe\n                :src=\"VIDEO_SOURCE\"\n                style=\"\n                  height: 100%;\n                  left: 0;\n                  position: absolute;\n                  top: 0;\n                  width: 100%;\n                  border-radius: 6px;\n                \"\n                frameborder=\"0\"\n                webkitallowfullscreen\n                mozallowfullscreen\n                allowfullscreen\n                allow=\"autoplay\"\n              ></iframe>\n            </div>\n          </div>\n\n          <div class=\"vuemastery-modal-footer\">\n            <p class=\"vuemastery-modal-footer-text\">\n              Video by\n              <a\n                href=\"https://www.vuemastery.com\"\n                target=\"_blank\"\n                rel=\"sponsored noopener\"\n                title=\"Vue.js Courses on Vue Mastery\"\n              >\n                Vue Mastery.</a\n              > Watch Vue Mastery’s free\n              <a\n                href=\"https://www.vuemastery.com/courses/intro-to-vue-3/intro-to-vue3\"\n                target=\"_blank\"\n                rel=\"sponsored noopener\"\n                title=\"Vue.js Courses on Vue Mastery\"\n              >\n                Intro to Vue course.</a\n              >\n            </p>\n          </div>\n        </div>\n      </div>\n    </div>\n  </Teleport>\n</template>\n\n<style scoped>\n#vuemastery-action {\n  font-size: 16px;\n  display: inline-block;\n  border-radius: 8px;\n  transition: background-color 0.5s, color 0.5s;\n  position: relative;\n  font-weight: 600;\n  background-color: var(--vt-c-green);\n  color: #fff;\n  margin-right: 18px;\n  padding: 8px 1em 8px 3em;\n}\n\n.dark #vuemastery-action {\n  color: var(--vt-c-indigo);\n}\n\n#vuemastery-action:hover {\n  background-color: var(--vt-c-green-dark);\n  transition-duration: 0.2s;\n}\n\n.dark #vuemastery-action:hover {\n  background-color: var(--vt-c-green-light);\n}\n\n.icon-play {\n  display: inline;\n  position: absolute;\n  left: 15px;\n  top: 8px;\n  margin-left: 2px;\n  fill: currentColor;\n  width: 1.5em;\n}\n\n.vuemastery-modal-mask {\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background: rgba(0, 0, 0, 0.2);\n  z-index: 30;\n  transition: opacity 0.3s ease;\n}\n\n.vuemastery-modal-wrapper {\n  display: block;\n  box-sizing: border-box;\n  border-radius: 8px;\n  position: fixed;\n  width: 75%;\n  height: auto;\n  padding: 0.5em;\n  background-color: #f9f9f9;\n  box-shadow: 0 0 10px rgb(0 0 0 / 20%);\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  z-index: 40;\n}\n\n.dark .vuemastery-modal-wrapper {\n  background-color: var(--vt-c-bg-soft);\n}\n\n.vuemastery-modal-content {\n  margin-bottom: 10px;\n}\n\n.vuemastery-video-space {\n  position: relative;\n  padding: 56.25% 0 0 0;\n}\n\n.vuemastery-modal-footer-text {\n  color: var(--vt-c-text-2);\n  margin-bottom: 0.5em;\n  text-align: center;\n  word-spacing: 0.05em;\n  font-size: 12px;\n}\n\n.vuemastery-modal-footer-text a {\n  color: #42b983;\n  font-weight: 600;\n}\n\n.dark .vuemastery-modal-footer-text {\n  color: var(--vt-c-text-2);\n  font-weight: 600;\n}\n\n@media (max-width: 576px) {\n  #vuemastery-action {\n    display: block;\n    margin: 0px auto;\n    width: 150px;\n  }\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/VueSchoolLink.vue\n================================================\n<template>\n  <div class=\"vueschool\">\n    <a\n      :href=\"`${href}?friend=vuejs`\"\n      target=\"_blank\"\n      rel=\"sponsored noopener\"\n      :title=\"title\"\n    >\n      <slot>在 Vue School 上观看免费课程</slot>\n    </a>\n  </div>\n</template>\n<script>\nexport default {\n  props: {\n    href: { type: String, required: true },\n    title: { type: String, required: true }\n  }\n}\n</script>\n<style scoped>\n.vueschool {\n  margin: 28px 0;\n  background-color: var(--vt-c-bg-soft);\n  padding: 1em 1.25em;\n  border-radius: 2px;\n  position: relative;\n  display: flex;\n  border-radius: 8px;\n}\n.vueschool a {\n  color: var(--c-text);\n  position: relative;\n  padding-left: 36px;\n}\n.vueschool a:before {\n  content: '';\n  position: absolute;\n  display: block;\n  width: 30px;\n  height: 30px;\n  top: calc(50% - 15px);\n  left: -4px;\n  border-radius: 50%;\n  background-color: #73abfe;\n}\n.vueschool a:after {\n  content: '';\n  position: absolute;\n  display: block;\n  width: 0;\n  height: 0;\n  top: calc(50% - 5px);\n  left: 8px;\n  border-top: 5px solid transparent;\n  border-bottom: 5px solid transparent;\n  border-left: 8px solid #fff;\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/components/WwAds.vue\n================================================\n<script setup lang=\"ts\">\nimport { onMounted } from 'vue'\n\nonMounted(() => {\n  const s = document.createElement('script')\n  s.async = true\n  s.src = `https://cdn.wwads.cn/js/makemoney.js`\n  document.querySelector('.wwads-container')!.appendChild(s)\n})\n</script>\n\n<template>\n  <div class=\"wwads-container\">\n    <div class=\"wwads-cn wwads-vertical\" data-id=\"53\"></div>\n  </div>\n</template>\n\n<style>\n.wwads-container {\n  padding: 1px 15px 10px;\n  margin-top: 20px;\n  background-color: var(--vt-c-bg-soft);\n}\n.wwads-vertical {\n  background-color: transparent !important;\n}\n.wwads-text {\n  color: var(--vt-c-text-2) !important;\n}\n</style>\n\n\n\n================================================\nFILE: .vitepress/theme/styles/badges.css\n================================================\n.vt-badge.wip:before {\n  content: 'WIP';\n}\n\n.vt-badge.ts {\n  background-color: #3178c6;\n}\n.vt-badge.ts:before {\n  content: 'TS';\n}\n\n.vt-badge.dev-only,\n.vt-badge.experimental {\n  color: var(--vt-c-text-light-1);\n  background-color: var(--vt-c-yellow);\n}\n\n.vt-badge.dev-only:before {\n  content: 'Dev only';\n}\n\n.vt-badge.experimental:before {\n  content: 'Experimental';\n}\n\n.vt-badge[data-text]:before {\n  content: attr(data-text);\n}\n\n\n\n================================================\nFILE: .vitepress/theme/styles/index.css\n================================================\n@import \"./zh-cn.css\";\n@import \"./pages.css\";\n@import \"./badges.css\";\n@import \"./options-boxes.css\";\n@import \"./inline-demo.css\";\n@import \"./utilities.css\";\n@import \"./style-guide.css\";\n@import \"./vars.css\";\n\n\n\n================================================\nFILE: .vitepress/theme/styles/inline-demo.css\n================================================\n.vt-doc a[href^=\"https://play.vuejs.org\"]:before\n{\n  content: '▶';\n  width: 20px;\n  height: 20px;\n  display: inline-flex;\n  border-radius: 10px;\n  vertical-align: middle;\n  position: relative;\n  top: -2px;\n  color: var(--vt-c-green);\n  border: 2px solid var(--vt-c-green);\n  margin-right: 8px;\n  margin-left: 4px;\n  line-height: 16px;\n  padding-left: 4.2px;\n  font-size: 11px;\n}\n\n.demo {\n  padding: 22px 24px;\n  border-radius: 8px;\n  box-shadow: var(--vt-shadow-2);\n  margin-bottom: 1.2em;\n  transition: background-color 0.5s ease;\n}\n\n.dark .demo {\n  background-color: var(--vt-c-bg-soft);\n}\n\n.demo p {\n  margin: 0;\n}\n\n.demo button {\n  background-color: var(--vt-c-bg-mute);\n  transition: background-color 0.5s;\n  padding: 5px 12px;\n  border: 1px solid var(--vt-c-divider);\n  border-radius: 8px;\n  font-size: 0.9em;\n  font-weight: 600;\n}\n\n.demo button + button {\n  margin-left: 1em;\n}\n\n.demo input,\n.demo textarea,\n.demo select {\n  border: 1px solid var(--vt-c-divider);\n  border-radius: 4px;\n  padding: 0.2em 0.6em;\n  margin-top: 10px;\n  background: transparent;\n  transition: background-color 0.5s;\n}\n\n.dark .demo select {\n  background: var(--vt-c-bg-soft);\n}\n\n.dark .demo select option {\n  background: transparent;\n}\n\n.demo input:not([type]):focus,\n.demo textarea:focus,\n.demo select:focus {\n  outline: 1px solid blue;\n}\n\n.demo select {\n  /* this was set by normalize.css */\n  -webkit-appearance: listbox;\n}\n\n.demo label {\n  margin: 0 1em 0 0.4em;\n}\n\n.demo select[multiple] {\n  width: 100px;\n}\n\n.demo h1 {\n  margin: 10px 0 0;\n}\n\n\n\n================================================\nFILE: .vitepress/theme/styles/options-boxes.css\n================================================\n.next-steps {\n  margin-top: 3rem;\n}\n\n.next-steps .vt-box {\n  border: 1px solid var(--vt-c-bg-soft);\n}\n\n.next-steps .vt-box:hover {\n  border-color: var(--vt-c-green-light);\n  transition: border-color 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);\n}\n\n.vt-doc .next-steps-link {\n  font-size: 20px;\n  line-height: 1.4;\n  letter-spacing: -0.02em;\n  margin-bottom: 0.75em;\n  display: block;\n  color: var(--vt-c-green);\n}\n\n.vt-doc .next-steps-caption {\n  margin-bottom: 0;\n  color: var(--vt-c-text-2);\n  transition: color 0.5s;\n}\n\n\n\n================================================\nFILE: .vitepress/theme/styles/pages.css\n================================================\n/* always show anchors on /api/ and /style-guide/ pages */\n.vt-doc.api h2 .header-anchor,\n.vt-doc.style-guide h2 .header-anchor {\n  opacity: 1;\n}\n\n.vt-doc.sponsor h3 {\n  text-align: center;\n  padding-bottom: 1em;\n  border-bottom: 1px solid var(--vt-c-divider-light);\n}\n\n.vt-doc.sponsor h3 .header-anchor {\n  display: none;\n}\n\n\n\n================================================\nFILE: .vitepress/theme/styles/style-guide.css\n================================================\n.style-example {\n  border-radius: 8px 8px 12px 12px;\n  margin: 1.6em 0;\n  padding: 1.6em 1.6em 0.1px;\n  position: relative;\n  border: 1px solid transparent;\n  transition: background-color 0.25s ease, border-color 0.25s ease;\n}\n\n.vt-doc .style-example h3 {\n  margin: 0;\n  font-size: 1.1em;\n}\n\n.style-example-bad {\n  background: #f7e8e8;\n}\n.dark .style-example-bad {\n  background: transparent;\n  border-color: var(--vt-c-red);\n}\n\n.style-example-bad h3 {\n  color: var(--vt-c-red);\n}\n\n.style-example-good {\n  background: #ecfaf7;\n}\n.dark .style-example-good {\n  background: transparent;\n  border-color: var(--vt-c-green);\n}\n\n.style-example-good h3 {\n  color: var(--vt-c-green);\n}\n\n.details summary {\n  font-weight: bold !important;\n}\n\n.style-verb {\n  font-size: 0.6em;\n  display: inline-block;\n  border-radius: 6px;\n  font-size: 0.65em;\n  line-height: 1;\n  font-weight: 600;\n  padding: 0.35em 0.4em 0.3em;\n  position: relative;\n  top: -0.15em;\n  margin-right: 0.5em;\n  color: var(--vt-c-bg);\n  transition: color 0.5s;\n  background-color: var(--vt-c-brand);\n}\n\n.style-verb.avoid {\n  background-color: var(--vt-c-red);\n}\n.vt-doc summary {\n  width: fit-content;\n  cursor: pointer;\n}\n\n\n================================================\nFILE: .vitepress/theme/styles/utilities.css\n================================================\n.nowrap {\n  white-space: nowrap;\n}\n\n.sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  border: 0;\n}\n\n\n\n================================================\nFILE: .vitepress/theme/styles/vars.css\n================================================\n:root {\n  --vp-code-tab-active-bar-color: var(--vt-c-green);\n  --vp-code-tab-active-text-color: var(--vt-c-text-inverse-1);\n  --vp-code-tab-text-color: var(--vt-c-text-inverse-2);\n  --vp-code-tab-hover-text-color: var(--vt-c-text-inverse-1);\n  --vp-code-tab-bg: #292d3ef0;\n  --vp-code-block-bg: #292d3ef0;\n}\n\n.dark {\n  --vp-code-tab-text-color: var(--vt-c-text-2);\n  --vp-code-tab-hover-text-color: var(--vt-c-text-1);\n  --vp-code-tab-active-text-color: var(--vt-c-text-1);\n  --vp-code-tab-bg: var(--vt-c-black-mute);\n  --vp-code-block-bg: var(--vt-c-black-mute);\n}\n\n\n\n================================================\nFILE: .vitepress/theme/styles/vue-mastery.css\n================================================\n.vue-mastery-link {\n  background-color: var(--vt-c-bg-soft);\n  border-radius: 8px;\n  padding: 8px 16px 8px 8px;\n  transition: color 0.5s, background-color 0.5s;\n}\n\n.vue-mastery-link a {\n  display: flex;\n  align-items: center;\n}\n\n.vue-mastery-link .banner {\n  background-color: var(--vt-c-white-soft);\n  border-radius: 4px;\n  width: 96px;\n  height: 56px;\n  object-fit: cover;\n}\n\n.vue-mastery-link .description {\n  flex: 1;\n  font-weight: 500;\n  font-size: 14px;\n  line-height: 20px;\n  color: var(--vt-c-text-1);\n  margin: 0 0 0 16px;\n  transition: color 0.5s;\n}\n\n.vue-mastery-link .description span {\n  color: var(--vt-c-brand);\n}\n\n.vue-mastery-link .logo-wrapper {\n  position: relative;\n  width: 48px;\n  height: 48px;\n  border-radius: 50%;\n  background-color: var(--vt-c-white);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.vue-mastery-link .logo-wrapper img {\n  width: 25px;\n  object-fit: contain;\n}\n\n@media (max-width: 576px) {\n  .vue-mastery-link .banner {\n    width: 56px;\n  }\n\n  .vue-mastery-link .description {\n    font-size: 12px;\n    line-height: 18px;\n  }\n  .vue-mastery-link .logo-wrapper {\n    position: relative;\n    width: 32px;\n    height: 32px;\n  }\n}\n\n\n\n================================================\nFILE: .vitepress/theme/styles/zh-cn.css\n================================================\n/* 中英文弯引号共享 Unicode 码位，确保引号使用中文字体渲染 */\n@font-face {\n  font-family: Quotes;\n  src: local('PingFang SC Regular'), local('PingFang SC'), local('SimHei'),\n    local('Source Han Sans SC');\n  unicode-range: U+2018, U+2019, U+201C, U+201D; /* 分别是 ‘’“” */\n}\n\nbody {\n  /* 1. 添加 Quotes 字体以修改引号 */\n  /* 2. 暂时删除 Inter 以修复斜体不生效问题，等 vuejs/theme 同步 https://github.com/vuejs/vitepress/pull/777 后观察是否可使用 'Inter var experimental', 'Inter var' 替代 */\n  --vt-font-family-base: Quotes, -apple-system, BlinkMacSystemFont,\n    'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Fira Sans',\n    'Droid Sans', 'Helvetica Neue', sans-serif;\n\n  /* 修复斜体不生效问题 #574 */\n  text-rendering: unset !important;\n  font-synthesis: unset !important;\n}\n\n/**\n * 不用 --vt-font-family-base 因为如果元素本身没有设置 font-family，会继承外部的 font-family，\n * 在这里设置 --vt-font-family-base 是无效的。不用 :lang(en) 因为这样可以把 font-family 设置范\n * 围控制得小一点。\n */\n[lang|='en'] {\n  font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n    Oxygen, Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n}\n\n\n"
      }
    ],
    "graphData": null
  },
  {
    "id": "1768755681377",
    "title": "Vue",
    "description": "新的空白知识库，等待您导入内容。",
    "tag": "General",
    "progress": 10,
    "status": "未开始",
    "lastUpdated": "2026/1/19",
    "files": [
      {
        "id": "17687556854600.7066677049230822",
        "name": "Vue.js_前端开发_快速入门与专业应用.pdf",
        "type": "pdf",
        "size": "3667.2 KB",
        "date": "2026/1/19",
        "content": "[PDF Content Placeholder - Text extraction required]"
      }
    ],
    "graphData": {
      "nodes": [
        {
          "id": "node1",
          "label": "Vue.js",
          "x": 400,
          "y": 100
        },
        {
          "id": "node2",
          "label": "渐进式框架",
          "x": 200,
          "y": 200
        },
        {
          "id": "node3",
          "label": "响应式数据绑定",
          "x": -200,
          "y": 200
        },
        {
          "id": "node4",
          "label": "组件系统",
          "x": -200,
          "y": 400
        },
        {
          "id": "node5",
          "label": "单文件组件(.vue)",
          "x": -400,
          "y": 400
        },
        {
          "id": "node6",
          "label": "Vue CLI",
          "x": -400,
          "y": 300
        },
        {
          "id": "node7",
          "label": "Vue Router",
          "x": -200,
          "y": 300
        },
        {
          "id": "node8",
          "label": "Vuex",
          "x": 0,
          "y": -200
        },
        {
          "id": "node9",
          "label": "前端开发",
          "x": 400,
          "y": 300
        },
        {
          "id": "node10",
          "label": "MVVM模式",
          "x": 200,
          "y": -200
        },
        {
          "id": "node11",
          "label": "虚拟DOM",
          "x": 0,
          "y": 400
        },
        {
          "id": "node12",
          "label": "指令系统",
          "x": 0,
          "y": 200
        },
        {
          "id": "node13",
          "label": "生态系统",
          "x": 400,
          "y": 400
        }
      ],
      "edges": [
        {
          "source": "node1",
          "target": "node2",
          "label": "属于"
        },
        {
          "source": "node1",
          "target": "node3",
          "label": "核心特性"
        },
        {
          "source": "node1",
          "target": "node4",
          "label": "核心特性"
        },
        {
          "source": "node1",
          "target": "node9",
          "label": "应用于"
        },
        {
          "source": "node1",
          "target": "node10",
          "label": "基于"
        },
        {
          "source": "node1",
          "target": "node12",
          "label": "包含"
        },
        {
          "source": "node1",
          "target": "node13",
          "label": "拥有"
        },
        {
          "source": "node4",
          "target": "node5",
          "label": "实现方式"
        },
        {
          "source": "node6",
          "target": "node5",
          "label": "支持创建"
        },
        {
          "source": "node13",
          "target": "node6",
          "label": "包含"
        },
        {
          "source": "node13",
          "target": "node7",
          "label": "包含"
        },
        {
          "source": "node13",
          "target": "node8",
          "label": "包含"
        },
        {
          "source": "node3",
          "target": "node11",
          "label": "结合"
        },
        {
          "source": "node7",
          "target": "node1",
          "label": "用于"
        },
        {
          "source": "node8",
          "target": "node1",
          "label": "用于"
        }
      ]
    },
    "learningPath": {
      "modules": [
        {
          "id": "module_1",
          "title": "Vue.js核心概念与基础",
          "description": "本模块旨在帮助学习者建立对Vue.js框架的整体认知，理解其核心设计理念和基础工作模式，为后续深入学习奠定基础。",
          "nodeIds": [
            "node1",
            "node2",
            "node9",
            "node10",
            "node11",
            "node3"
          ],
          "status": "active"
        },
        {
          "id": "module_2",
          "title": "Vue.js应用开发基础",
          "description": "本模块将深入学习Vue.js的核心功能，包括指令系统和组件系统，掌握构建基础Vue应用页面的能力。",
          "nodeIds": [
            "node12",
            "node4",
            "node5"
          ],
          "status": "locked"
        },
        {
          "id": "module_3",
          "title": "Vue.js工程化与工具链",
          "description": "本模块介绍Vue.js的官方开发工具和工程化支持，学习如何使用现代前端工具链高效地创建和管理Vue项目。",
          "nodeIds": [
            "node6",
            "node13"
          ],
          "status": "locked"
        },
        {
          "id": "module_4",
          "title": "Vue.js高级应用与状态管理",
          "description": "本模块聚焦于构建复杂单页应用所需的核心技术，包括路由管理和全局状态管理，以开发更完整的前端应用。",
          "nodeIds": [
            "node7",
            "node8"
          ],
          "status": "locked"
        }
      ]
    }
  }
]